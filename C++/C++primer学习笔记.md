**全局变量初始化为0，全局指针初始化为NULL；局部变量（包括指针变量）如果未显式初始化，其值都是未定的**

## C++primer中的对象和广义上的对象不同

C++primer中的对象和广义上的对象不同，C++primer中的对象包括变量，而广义上的对象指的是类（非内置类型）。

## 柔性数组

**1、什么是柔性数组？**

柔性数组既数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建柔性数组。

**2、柔性数组有什么用途 ？**

它的主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题。

**3、用法**：在一个结构体的最后 ，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名

本身不占空间，它只是一个偏移量， 数组名这个符号本身代 表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！

对于柔性数组的这个特点，很容易构造出变成结构体，如缓冲区，数据包等等：

```
typedef struct _SoftArray
{
    Int len;
    int array[];
}SoftArray;
```

### **柔性数组用途**

  这样的变长数组常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量，比如我要发送1024字节的数据，如果用定长包，假设定长包的长度为2048，就会浪费1024个字节的空间，也会造成不必要的流量浪费。

## 类中有几个构造函数

一个类会默认生成四个函数，

**当我们自定义了构造函数时，默认情况下就不会再隐含生成默认构造函数**，**只是不再生成默认构造函数！但是其他三个函数依然会生成（拷贝构造函数，析构函数，重载赋值运算符）！！！！！**

原题：
  有如下类定义：
    class MyClass{
      int value;
    public：
      MyClass(int n)：value(n) { }
      int getValue() const { return value；}
    };
  则类MyClass的构造函数的个数是（）。
  A.1个
  B.2个
  C.3个
  D.4个
  【未来教育解析】本题考查类的默认构造函数和自定义的构造函数。本题中MyClass(int n)：value(n){ }为自定义的构造函数，加上默认构造函数，一共有2个构造函数。故本题答案为B选项。

  【个人解析】根据C++的标准，如果程序已定义构造函数，默认情况下编译器就不再隐含生成默认构造函数。如果此时依然希望编译器隐含生成默认构造函数，可以使用“=default”。如：
  class MyClass{
    int value;
  public：
    MyClass() = default;
    MyClass(int n)：value(n) { }
  };
  此时类MyClass一共有三个构造函数：自定义的构造函数和编译器隐含生成的默认构造函数和默认复制构造函数。

  未来教育给的答案虽然是正确的，但是解析是错误的。原题的正确解析应该是：**有两个构造函数，自定义构造函数和默认复制构造函数**。

## 函数签名

 C++中的函数签名(function signature)：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间。**普通函数签名并不包含函数返回值部分，如果两个函数仅仅只有函数返回值不同，那么系统是无法区分这两个函数的**，此时编译器会提示语法错误。**函数签名用于识别不同的函数**，函数的名字只是函数签名的一部分。



## C++中重载、重写和重定义

三者的不同详细

重载(overload):是函数名相同，参数列表不同，只是在类的内部存在。

重写(override),也叫覆盖。子类重新定义父类中有相同名称和参数的虚函数(virtual)。在继承关系之间。C++利用虚函数实现多态。

重写的特点: 

​     1 被重写的函数不能是static的。**必须是virtual的**

​     2 重写函数必须有***相同的类型，名称和参数列表***

​     3 重写函数的***\*访问修饰符可以不同\****。尽管父类的virtual方法是private的，派生类中重写改写为public,protected也是可以的

重定义(redefining)，也叫隐藏。子类重新定义父类有相同名称的非虚函数(**参数列表可以不同**)。

子类若有和父类相同的函数，那么，这个类将会隐藏其父类的方法。除非你在调用的时候，强制转换成父类类型。**在子类和父类之间尝试做类似重载的调用时不能成功的**。

![image-20201201141708682](C:\Users\leeb\AppData\Roaming\Typora\typora-user-images\image-20201201141708682.png)

C++         			Java
虚函数 -------- 普通函数
纯虚函数 -------- 抽象函数
抽象类 -------- 抽象类
虚基类 -------- 接口

在C++中如果想要重写父类的方法，该方法必须被声明为virtual的；而java中不需要virtual，所有方法默认是虚函数，所有方法都可以被子类重写。

virtual=0对应于java中的abstract关键字，在C++中被声明为virtual=0的方法为纯虚函数，包含纯虚函数的类为抽象类，该类无法被实例化，所派生的子类如果不将所有纯虚函数重写，那么该子类也是抽象类。在java中被声明为abstract的方法为抽象方法，包含抽象方法的类为抽象类，也可以直接用abstract定义抽象类。

C++中**仅含**有纯虚函数的类称为接口类

- 没有任何数据成员

- 仅有成员函数
- 成员函数都是纯虚函数

java中使用interface关键字表示接口

- ![image-20210906211328131](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210906211328131.png)

在C++中，指针或引用可以调用什么函数是由静态类型决定的，只能调用静态类型的函数，不能调用动态类型所特有的函数。对于普通函数，在运行中实际调用的函数版本就是静态类型的版本。对于虚函数，运行中实际调用的函数版本是动态类型的函数版本。

```cpp
#include<iostream>
#include<memory>
using namespace std;
class base {
public:
	void fuck() {
		cout << "base" << endl;
	}
	void fuck_overload(int a,int b) {
		cout << "base_overload" << endl;
	}
	virtual void vfuck() {
		cout << "base_virtual" << endl;
	}
};
class sub:public base {
public:
	// 重定义，子类和父类的非虚函数名字相同就行了，不需要参数列表相同
	// 此时在子类中，子类定义的函数就会把从父类继承来的函数给隐藏
	// 子类对象对该函数的调用就是对子类定义的版本的调用
	// 除非调用时，显式地指定作用域
	void fuck() {
		cout << "sub" << endl;
	}
	// 子类不能重载父类的函数，只要名字相同，就是对父类函数进行隐藏！
	void fuck_overload(double b) {
		cout << "sub_overload" << endl;
	}
	virtual void vfuck() {
		cout << "sub_virtual" << endl;
	}
};
int main() {
	sub a;
	// 子类对重定义函数的调用默认是子类中的版本
	a.fuck();
	// 只有调用时显式地指定作用域，才能调用父类中的版本
	a.base::fuck();
	// 调用无法成功，在子类和父类之间进行重载是不行的
	a.fuck_overload(10,10);
	a.fuck_overload(10.0);
	base* p1 = static_cast<base*>( new sub());
	// 如果调用的是普通函数，不发生动态绑定，调用静态类型的函数版本
	p1->fuck();
	// 如果调用的是虚函数，发送动态绑定，调用动态类型的函数版本
	p1->vfuck();

	sub* p2 = new base();// 错误，从父类到子类不能进行隐式类型转换
}
```



## 显式转换

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

当把一个较小的算术类型赋值给较大的类型时，会自动执行隐式类型转换。当把较大的算术类型赋值给较小的算术类型时，会造成精度损失，编译器会给出警告信息，此时static_cast就非常有用，会进行显式的强制类型转换，警告信息就会被关闭。

1. **static_cast 作用和C语言风格强制转换的效果基本一样**，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。
2. 可以用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进**行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的**。

下行转换不安全的原因：指针或引用可以调用什么函数是由静态类型决定的，转换后静态类型变为了派生类，就可以调用派生类的所有函数，而编译器不会报错

- 如果基类指针的动态类型是派生类（先从派生类隐式转换为基类），那么就是安全的。
- 如果基类指针的动态类型不是派生类，那么转换后如果调用派生类所特有的函数，那么就会出问题。

```cpp
class B {
public:
    virtual void Test() {}
};
class D : public B {};
void f(B* pb) {
    D* pd2 = static_cast<D*>(pb);
}
int main() {
    // 基类指针的动态类型为派生类，安全
    f(new D);
    // 基类指针的动态类型为基类，不安全
    f(new B);
}
```



`dynamic_cast`有动态类型检查，**一般专门使用它来进行下行转换**（把基类指针或引用转换成派生类表示）。`dynamic_cast`只适用于引用或指针，**除了下行转换之外，上行转换的行为和`static_cast` 一样**。

- 如被转换的对象真的指向派生类对象，dynamic_cast和static_cast效果一样；如果被转换对象指向基类对象，dynamic_cast返回null，因为dynamic_cast有动态类型检查。

  ```cpp
  class B {
  public:
      virtual void Test() {}
  };
  class D : public B {};
  void f(B* pb) {
      D* pd1 = dynamic_cast<D*>(pb);
      cout << pd1 << endl;
      D* pd2 = static_cast<D*>(pb);
  }
  int main() {
      // dynamic_cast转换成功，因为动态类型是派生类，可以转换
      f(new D);
      // dynamic_cast转换的值为nullptr，因为动态类型是基类，基类无法转换为派生类
      f(new B);
  }
  ```

  

总结：

内置类型从小的赋值到大的类型可以隐式转换，从大的类型赋值到小的需要使用static_cast强制转换。

类类型只有指针或引用才能进行相互之间的类型转换，普通类型不能直接进行转换。

- 从派生类到基类的转换很安全，使用static_cast，

- 从基类到派生类的转换有可能不安全：

  - 如果基类指针的动态类型是派生类（先从派生类隐式转换为基类），那么就是安全的。
  - 如果基类指针的动态类型不是派生类，那么转换后如果调用派生类所特有的函数，那么就会出问题。

  所以此时需要用dynamic_cast。

```cpp
class B {
public:
    virtual void Test() {}
};
class A {
public:
    int c = 0;
    void func() {
        cout << "fuck" << endl;
    }
};
class D : public B {};
int main() {
    B p1;
    // 错误！只有指针或引用才能进行类型转换，普通类型不能直接进行转换
    A p2 = (A)p1;
    // 子类和父类进行相互转换

    // 子类可以直接隐式转换为父类，安全
    B* pb = new D;
    // 父类不能隐式转换为子类
    D* pd = new B;// 错误
    // 可以使用static_cast强转为子类，可以通过编译但是危险
    D* pd2 = static_cast<D*>(new B); 
    // 两个不相关的类也可以进行相互转换，但是不安全
    A* pa = (A*)new B;
    B* pb = (B*)new A;
    // 使用dynamic_cast，转换结果为null
}
```

**在C++的转换规则中，不能隐式地将void\*转换为char\*，因此，需要使用`reinterpret_cast`进行类型转换。** 

## 成员变量的隐藏

在编写子类时，我们仍然可以声明成员变量，如果所声明的成员变量的名字和父类继承来的成员变量的名字相同(类型可以不同)，那么子类就会隐藏所继承的成员变量

特点：
1、子类对象以及子类自己定义的方法操作与父类同名的成员变量是指子类重新声明的这个成员变量
2、子类继承的方法所操作的成员变量一定是被子类继承或隐藏的成员变量

子类继承的方法只能操作子类继承和隐藏的成员变量
子类新定义的方法可以操作子类继承和子类新声明的成员变量，无法直接操作子类隐藏的成员变量（需使用super关键字）

以上规则与C++中相同，与之相对应，C++中如果子类想操作被隐藏的父类的成员变量或方法必须使用作用域运算符。

在java中只有父类成员变量才能被隐藏，父类方法只能被重载或重写

而C++中方法父类的成员变量可以被隐藏，父类的方法也可以被隐藏或重写，但是不能被重载。

java中只有重载和重写，可以重载父类的方法（函数名相同，参数不同），只能重写父类的方法（函数签名相同，返回值要可兼容）

c++中有重载，重写，重定义，重载只能对同一个类中的方法进行，不能对父类进行，而重定义是指隐藏了父类中同名的函数，在子类中无法直接调用父类的该函数，要使用父类作用域。

## 类内static初始化： 

- 类外初始化，且不再带有 static 关键字
- 类内初始化设置，必须为const，且integral
- 不可通过构造函数的初始化参数列表进行初始化
  - static 不属于某一特定的类实例，而是属于类，显然不能通过构造函数的初始化参数列表进行 static 变量的初始化



## 类的提前声明

这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下，只要做好提前声明，也可以先使用。

但是应当注意，类的提前声明的使用范围是有限的，**只有在正式声明一个类以后才能用它去创建对象**。如果在上面程序的第4行之后增加如下所示的一条语句，编译器就会报错：

Address addr; //**企图使用不完整的类来创建对象**

因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。**在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关**。



## 初始化

![image-20210814160327297](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210814160327297.png)

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

### 列表初始化

C++11之前主要有以下几种初始化方式：

```cpp
//小括号初始化
string str("hello");
 
//等号初始化
string str="hello";
 
//POD对象与POD数组列表初始化
struct Studnet
{
    char* name;
    int age;
};
Studnet s={"dablelv",18}; //纯数据（Plain of Data,POD）类型对象
Studnet sArr[]={{"dablelv",18},{"tommy",19}};  //POD数组
 
//构造函数的初始化列表
class Class
{
    int x;
public:
    Class(): x(0){} 
};
```

从C++11开始，对列表初始化（List Initialization）的功能进行了扩充，可以作用于任何类型对象的初始化，至此，列表初始化方式完成了天下大一统。

```c++
class Test
{
    int a;
    int b;
public:    
    C(int i, int j);    
};    
Test t{0,0};                    //C++11 only，相当于 Test t(0,0);    
Test* pT=new Test{1,2};         //C++11 only，相当于 Test* pT=new Test(1,2);
int* a = new int[3]{1,2,0};    //C++11 only
```

此外，C++11列表初始化还可以应用于容器，终于可以摆脱 push_back() 调用了，C++11中可以直观地初始化容器：

```cpp
//C++11 container initializer

vector<string> vs={"first", "second", "third"};    

map<string,string> singers ={{"Lady Gaga", "+1 (212) 555-7890"},{"Beyonce Knowles", "+1 (212) 555-0987"}};
```

因此，可以将C++11提供的列表初始化作为统一的初始化方式，既降低了记忆难度，也提高的代码的统一度。

### 默认初始化

如果定义变量时没有指定初值，则变量被默认初始化( default initialized)， 此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

- 内置类型：

  - 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量（**全局变量和静态变量**）被初始化为0。定义在函数体内部的内置类型变量（**局部变量**）将**不被初始化(uninitialized)**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

- 类

  - 类的对象如果没有显式初始化，则其值由类决定。**类对象的默认初始化由默认构造函数完成**。

    - 如果类中有默认构造函数，则该对象的值为默认构造函数中的值。
    - **如果类中没有默认构造函数，如果试图拷贝或以其他形式访问此类值则会引发错误**。

    例如，以刚刚所见为例，string 类规定如果没有指定初值则生成一一个空串:

    ```c++
    std::string empty; // empty 非显式地初始化为一个空串
    Sales_item item; //被默认初始化的Sales_item 对象.
    ```

    

#### 默认构造函数

我们一般会认为默认构造函数就是编译器自动生成的那个构造函数，其实这种理解不全面。准确的说，**默认构造函数就是在调用时不需要显示地传入实参的构造函数**。根据这个原则，下面2种构造函数都是默认构造函数：

```cpp
class Sample {
public:
    // 默认构造函数。
    Sample() {
        // do something
    }
};
```

```cpp
class Sample {
public:
    // 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。
    Sample(int m = 10) {
        // do something
    }
};
```

**默认构造函数什么时候被调用？**
如果定义一个对象时没有使用初始化式，编译器就会使用默认构造函数。如：

```c++
Sample s;
```

##### 类内初始值

C++11新标准规定，可以为数据成员提供一个**类内初始值(in-class initializer)**。 创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。因此当定义Sales_ data的对象时，units_ sold 和revenue都将初始化为0，bookNo将初始化为空字符串。

```c++
struct Sales_data{
	std: :string bookNo;
	unsigned units sold = 0;
	double revenue = 0. 0;
};
```

我们没有为这些对象提供初始值，因此我们知道它们执行了默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数( default constructor)**。默认构造函数无须任何实参。
如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为**合成的默认构造函数( synthesized defaultconstructor)**。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员:

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

因为`Sales_data` 为`units_sold` 和`revenue`提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把`bookNo`默认初始化成一个空字符串。

#### 某些类不能依赖于合成的默认构造函数

- 对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型(比如数组和指针)的对象被默认初始化(参见2.2.1 节，第40页)，则它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。**因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值.**如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。
- 还有一个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，**如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员**。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。

**下面几种情况下，编译需要生成默认构造函数：**

1.当该类的类对象数据成员有默认构造函数时。
2.当该类的基类有默认构造函数时。
3.当该类的基类为虚基类时。
4.当该类有虚函数时。

## 拷贝构造函数和赋值运算符

**C++拷贝构造函数的参数类型必须要是引用类型**。因为如果通过按值传递机制传递实参。在可以传递对象cigar之前，**编译器需要安排创建该对象的副本。因此，编译器为了处理复制构造函数的这条调用语句，需要调用复制构造函数来创建实参的副本。**但是，由于是按值传递，第二次调用同样需要创建实参的副本，因此还得调用复制构造函数，就这样持续不休。最终得到的是对复制构造函数的无穷调用。（**其实就是创建副本也是需要调用复制构造函数的**）

拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个**已经存在的实例**。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。**调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符**。

调用拷贝构造函数主要有以下场景：

- 对象作为函数的参数，以值传递的方式传给函数。　
- 对象作为函数的返回值，以值的方式从函数返回
- 使用一个对象给另一个对象**初始化**

```cpp
int main()
{
	Person p;
	Person p1 = p;    // 拷贝构造：虽然使用了=，但是执行的是构造操作
	Person p2;
	p2 = p;           // 赋值运算符：对已有对象赋值
	f(p2);            // 拷贝构造
	p2 = f1();        // 调用f1函数，返回时调用了一次拷贝构造，创建了一个临时的person对象
    				  // 再将临时对象赋值给p2，调用了赋值运算符
	Person p3 = f1(); // 拷贝构造
	return 0;
}
```

如果自己没有定义复制构造函数和赋值操作符，编译器会自动帮我们写，在大多数情况下和我们自己写的差不多，但是当类中的成员属性有**指针**时则必须自己写。原因如下：编译器生成的默认构造函数对指针进行的是浅拷贝（即直接拷贝指针），而复制构造函数和赋值操作符的根本目的是拷贝指针指向的对像(即深拷贝)

```cpp
class noname
{
private:
	string* pstring;
	int i;
	double d;
public:
	noname() :pstring(new string), i(0), d(0) {};
	noname(const noname& other)
		//:pstring(other.pstring)编译器的写法
		:pstring(new string(*(other.pstring))), i(other.i), d(other.d)
	{
		cout << "复制构造函数" << endl;
	}
	noname& operator=(const noname& rhs)
	{
		//pstring = rhs.pstring;编译器的写法
		pstring = new string(*(rhs.pstring));
		i = rhs.i;
		d = rhs.d;
		return *this;
	}
	~noname();
};
noname::~noname()
{
	delete pstring;
}
```



## C++初始化方式

1. 默认初始化

   默认初始化是指定义变量时没有指定初值时进行的初始化操作。例如

   ```cpp
   int a; 
   Sales_data myData;
   ```

   这些变量被定义了而不是仅仅被声明（因为没有extern关键字修饰），而且没有显式的赋予初值。

   - 特别的，如果采用动态分配内存的方式（即采用new关键字）创建的变量，不加括号时（如int *p=new int;）也是默认初始化，加了括号（如int *p=new int()）为值初始化。

     ```cpp
     int *p=new int;//默认初始化
     int *p=new int();//值初始化
     ```

     以上两种方式都是调用默认构造函数（即不需要传入参数的构造函数）

     **使用new动态分配的对象执行默认初始化，所以内置类型的值是未定义的，而类类型使用默认构造函数进行初始化**。

   默认初始化变量的值与变量的类型与定义的位置有关系。

   - 对于内置类型变量（如int，double，bool等），如果是全局或静态变量，则变量被默认初始化为0；如果是局部变量，变量将拥有未定义的值。

   - 对于类类型的变量（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数（要么是编译器生成的默认构造函数，要么是自己定义的不需要传入参数的构造函数）。
     - 如果类的默认构造函数是编译器生成的
       - 如果类的成员变量如果有类内初始值，就按照类内初始值初始化
       - 如果类的成员变量没有类内初始值，执行默认初始化
         - **如果是内置类型，那么不会初始化（未定义的值）**
         - 如果是类类型，那么调用该类的默认构造函数
     - 如果类的默认构造函数是自定义的，那么按照自定义的构造函数初始化成员变量
     - 如果该类没有默认构造函数，则会引发错误。因此，建议为每个类都定义一个默认构造函数（=default）。

2. 数组初始化（并不算一个初始化方式）

   - 如果定义数组时提供了初始值列表，未定义的元素执行默认初始化

   - 如果定义数组时未提供初始化列表，则每个元素执行默认初始化
     - 默认初始化：类类型调用默认构造函数，内置类型如果是局部变量不初始化，如果是全局变量初始化为0；

   ```cpp
   class Cat {
    public:
       int age;
   };
   
   int main() {
       /* 内置类型在函数内部默认初始化, 随机值 */
       int int_array[5];
       for (int i = 0; i < 5; i++) {
           std::cout << int_array[i] << std::endl;  // 全都是随机值
       }
   
       /* 定义数组使用初始值列表, 除了前两个元素外都是0 */
       int int_array2[5] = { 22, 33 };
       for (int i = 0; i < 5; i++) {
           std::cout << int_array2[i] << std::endl;  // 22,33,0,0,0
       }
   
       /* 定义数组使用初始值列表, 都是0 */
       int int_array3[5] = {};
       for (int i = 0; i < 5; i++) {
           std::cout << int_array3[i] << std::endl;  // 0,0,0,0,0
       }
   
       /* 数组元素为类且使用初始值列表时 */
       Cat *my_cat = new Cat;
       Cat cat_array[5] = { *my_cat };
       for (int i = 0; i < 5; i++) {
           std::cout << cat_array[i].age << std::endl;  // 随机值,0,0,0,0
       }
   
       return 0;
   }
   ```

3. 值初始化

   值初始化是值**使用了初始化器（即使用了圆括号或花括号）但却没有提供初始值**的情况。应该称为广义缺省初始化。例如，

   ```cpp
   int *p=new int();
   vector<string> vec(10);
   vector v1(10);//v1有10个元素，每个的值都是0
   ```

   - 如果T有用户定义的缺省构造函数，直接调用；
   - 如果T有编译器生成的缺省构造函数，先0值初始化再调用；
   - 如果T根本不是类，直接0值初始化。

   **对于类类型而言，不指定初始值下会调用它的默认构造函数，因此不存在默认初始化和值初始化的区别。但是对于内置类型值初始化和默认初始化不同，值初始化的内置类型对象具有良好定义的值，而默认初始化的对象的值则是未定义的**

   ```cpp
   int *pi1 = new int;               // 默认初始化: *pi1的值未定义
   int *pi2 = new int();             // 值初始化: *pi2的值为0
   
   int *pia1 = new int[10];          // 10个默认初始化的int: 值未定义
   int *pia2 = new int[10]();        // 10个值初始化的int: 值都为0
   
   string *psa1 = new string[10];    // 10个默认初始化的string: 都为空
   string *psa2 = new string[10]();  // 10个值初始化的string: 都为空
   ```

   

4.  直接初始化与拷贝初始化  

   直接初始化与拷贝初始化对应，其内部实现机理不同。

   - 直接初始化是指采用小括号的方式进行变量初始化（小括号里一定要有初始值，如**果没提供初始值，那就是值初始化**）。例如

     ```cpp
     int a(12);
     Sales_data myData(para);
     vector<int> ivec(ivec2);
     string s("123456");
     ```

   - 拷贝初始化是指采用等号（=）进行初始化的方式。例如

     ```cpp
     int a=12;string s=string("123456");
     ```

     **拷贝初始化看起来像是给变量赋值，实际上是执行了初始化操作，与先定义再赋值本质不同**。

   对于内置类型变量（如int，double，bool等），直接初始化与拷贝初始化差别可以忽略不计。

   对于类类型的变量（如string或其他自定义类型），直接初始化调用类的构造函数（调用参数类型最佳匹配的那个），拷贝初始化调用类的拷贝构造函数。

5. 列表初始化

   列表初始化是C++ 11 新引进的初始化方式，它采用一对花括号（即｛｝）进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化。列表初始化的应用场景有：

   ```cpp
   int a{12};
   string s{"123"};
   vector<int> vec{1,2,3};
   ```

   vector中圆括号与花括号的初始化：圆括号是通过调用vector的构造函数进行初始化的，如果使用了花括号那么初始化过程会尽可能会把花括号内的值当做元素初始值的列表来处理。如果初始化时使用了花括号但是提供的值又无法用来列表初始化，那么就考虑用这些值来调用vector的构造函数了。

   ```cpp
   #include <string>
   #include <vector>
   
   int main() {
       std::vector<std::string> v1{"tomo", "cat", "tomocat"};  // 列表初始化: 包含3个string元素的vector
       // std::vector<std::string> v2("a", "b", "c");          // 错误: 找不到合适的构造函数
   
       std::vector<std::string> v3(10, "tomocat");             // 10个string元素的vector, 每个string初始化为"tomocat"
       std::vector<std::string> v4{10, "tomocat"};             // 10个string元素的vector, 每个string初始化为"tomocat"
   
       std::vector<int> v5(10);     // 10个int元素, 每个都初始化为0
       std::vector<int> v6{10};     // 1个int元素, 该元素的值时10
       std::vector<int> v7(10, 1);  // 10个int元素, 每个都初始化为1
       std::vector<int> v8{10, 1};  // 2个int元素, 值分别是10和1
   }
   ```

尽管C++11将列表初始化应用于所有对象的初始化，但是内置类型习惯于用等号初始化，类类型习惯用构造函数圆括号显式初始化，vector、map和set等容器类习惯用列表初始化。

```cpp
#include <string>
#include <vector>
#include <set>
#include <map>

class Cat {
 public:
    std::string name;
    Cat() = default;
    explicit Cat(const std::string &s) : name(s) {}
};

int main() {
    // 内置类型初始化(包括string等标准库简单类类型)
    int i = 10;
    long double ld = 3.1415926;
    std::string str = "tomocat";

    // 类类型初始化
    Cat cat1();
    Cat cat2("tomocat");

    // 容器类型初始化(当然也可以用圆括号初始化, 列表初始化用于显式指明容器内元素)
    std::vector<std::string> v{"tomo", "cat", "tomocat"};
    int arr[] = {1, 2, 3, 4, 5};
    std::set<std::string> s = {"tomo", "cat"};
    std::map<std::string, std::string> m = {{"k1", "v1"}, {"k2", "v2"}, {"k3", "v3"}};
    std::pair<std::string, std::string> p = {"tomo", "cat"};

    // 动态分配对象的列表初始化
    int *pi = new int {10};
    std::vector<int> *pv = new std::vector<int>{0, 1, 2, 3, 4};

    // 动态分配数组的列表初始化
    int *parr = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
}
```

## 隐式的类类型转换

**如果一个类A中的某个构造函数只有一个实参（类型为B），它实际上定义了从类型B到类A的隐式转换机制**，有时我们将这种构造函数称为转换构造函数（converting constructor）。也就是说，**在需要使用类A的地方可以使用类型B代替**。

![image-20210907180057245](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210907180057245.png)

在`sales_data` 类中，接受`string`的构造函数和接受`istream`的构造函数分别定义了从这两种类型向`Sales_data` 隐式转换的规则。也就是说，**在需要使用`Sales_data` 的地方，我们可以使用`string`或者`istream`作为替代**:

```cpp
string null_book = "9-999-99999-9";
//构造一个临时的Sales_data对象,该对象的units_sold和revenue等于0，bookNo等于null_book
//原本需要使用Sales_data对象，此时只需要传入string即可
item.combine(null_book) ;
```

在这里我们用一个string实参调用了Sales_data 的combine成员。该调用是合法的，**编译器用给定的string自动创建了一个Sales_data 对象。新生成的这个(临时) Sales_data对象被传递给combine**。因为combine的参数是一个常量引用，所以我们可以给该参数传递一个临时量。

### 只允许一步类型转换

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210907180823187.png" alt="image-20210907180823187" style="zoom:67%;" />

### 抑制构造函数定义的隐式类型转换

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210907180936196.png" alt="image-20210907180936196" style="zoom:67%;" />

![image-20210907185719856](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210907185719856.png)、

第一排使用了Sales_data中的参数为string的构造函数，所以正确。

第二排想要使用Sales_data中的拷贝构造函数，但是拷贝构造函数的参数为Sales_data，并且此时构造函数变为explicit，null_book无法从string类型隐式转成Sales_data类型，也就无法调用拷贝构造函数。

使用了explicit后虽然不能进行隐式类型转换，但是可以使用类似`static_cast<>`进行强制类型转换。

![image-20210907190010407](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210907190010407.png)

## 动态内存

### 智能指针

动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄漏;有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针。
为了更容易(同时也更安全)地使用动态内存,新的标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，**重要的区别是它负责自动释放所指向的对象**。

- `shared_ptr`允许多个指针指向同一个对象 
- `unique_ptr`则“独占”所指向的对象。
- 标准库还定义了一个名为`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。

这三种类型都定义在memory头文件中。

详见C++学习文件

## RAII

**RAII**，全称**资源获取即初始化**（英语：**R**esource **A**cquisition **I**s **I**nitialization），RAII要求，资源的有效期与持有资源的对象（通常是持有资源的函数）的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄漏问题。

**使用局部对象来管理资源**的技术称为资源获取即初始化，这些资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？就可以使用RAII。

**RAII也适用于在一个函数内部成对进行的操作**，比如malloc和free，new和delete，对磁盘内容的修改（先从磁盘读到内存，再将修改完的内容写回磁盘），对文件和套接字的使用等。而程序员经常会忘记后面一个操作，比如我在写gitlet时，经常需要修改文件的内容，需要先把文件的内容读入内存，进行一系列操作后却忘记了应该把内存中修改的内容再写回文件，就可以采用这种方法。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20230217162806492.png" alt="image-20230217162806492" style="zoom:50%;" />

RAII在C++中的应用非常广泛，如C++标准库中的lock_guard便是用RAII方式来控制互斥量:

```C++
template <class Mutex> class lock_guard {
private:
    Mutex& mutex_;

public:
    lock_guard(Mutex& mutex) : mutex_(mutex) { mutex_.lock(); }
    ~lock_guard() { mutex_.unlock(); }

    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};
```

程序员可以非常方便地使用lock_guard，而不用担心异常安全问题

```C++
extern void unsafe_code();  // 可能抛出异常

using std::mutex;
using std::lock_guard;

mutex g_mutex;

void access_critical_section()
{
    lock_guard<mutex> lock(g_mutex);
    unsafe_code();
}
```

注意！只有调用new的时候对象才会在堆上开辟，其余的时候都是在栈上开辟，如：

```
lock_guard<mutex> lock(g_mutex);
```

以上情况实例化的对象就是在栈上开辟的，只有将RAII对象开辟在栈上才能正确执行RAII的功能

函数结束后析构lock_guard对象时会自动将mutex解锁。

整个RAII过程我总结四个步骤：

1. 设计一个类封装资源
2. 在构造函数中初始化
3. 在析构函数中执行销毁操作
4. 使用时声明一个该对象的类

注意，RAII的对象通常要把拷贝构造函数和赋值运算符delete。因为RAII对象拷贝的时候必须一并复制它所管理的资源，并且这个复制必须要是深拷贝，即重新创建和这些资源内容一样的对象，而自动生成的拷贝构造函数是浅拷贝，即只拷贝指针。所以为了防止误拷贝时使用了自动生成的拷贝构造函数，一般都要将拷贝构造函数和赋值运算符delete

```cpp
    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
```

浅拷贝会出现的问题：

```
void test(){
	lock_guard<Mutex> lock1(new Mutex());
	lock_guard<Mutex> lock2(lock1);
	return;
}
```

以上写法没有delete拷贝构造函数，如果使用了默认的拷贝构造函数就会导致浅拷贝，lock2和lock1内部指向同一个对象，test函数结束后lock1和lock2都要进行析构，那么内部的对象就会被delete两次，同一块内存将会被多次释放，程序当然会崩溃。

## 对象移动

### 右值引用

右值引用就是必须绑定到右值的引用，我们通过`&&`来获取右值引用。

左值和右值是表达式的属性，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。

左值有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时变量。也就是说右值引用只能绑定到一个将要销毁的临时对象。比如：运算表达式，字面常量等。所以我们可以得知：

- 所引用的对象将要被销毁
- 该对象没有别的用户

```cpp
inti=42;
int&r=i;//正确:r引用i
int &&rr = i;//错误:不能将一个右值引用绑定到一个左值上
int&r2=i*42;//错误: i*42是一个右值
const int&r3=i*42;//正确:我们可以将一个const的引用绑定到一个右值上
int&&rr2=i*42; //正确:将rr2绑定到乘法结果上
```

![image-20210909165136963](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210909165136963.png)

变量是左值，我们不能将一个右值引用直接绑定到一个变量上，即便这个变量是右值引用类型也不行。

### move函数

move函数可以显式地获取绑定在左值上的右值（~引用）。实际上就是将一个变量中的值取出来，作为临时值返回，再将这个变量置为空。在调用了move后，输入的左值（移后源对象）被置为空，所以不能再使用它的值，只能对它进行赋新值或销毁。

- C++ 标准库使用比如`vector::push_back` 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建。通过std::move，直接对参数的对象push_back，可以避免不必要的拷贝操作。
- `std::move`是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。

原str中的值在move后被转移，所以再次输出时为空字符串

```cpp
int main()
{
    std::string str = "Hello";
    std::vector<std::string> v;
    //调用常规的拷贝构造函数，新建字符数组，拷贝数据
    v.push_back(str);
    std::cout << str << "\"\n";
    //调用移动构造函数，掏空str，掏空后，最好不要使用str
    v.push_back(std::move(str));
    std::cout << str << "\"\n";//被转移后，值为空
}
```



### 动态分配数组

当给定的条件不同时，二维数组的动态分配方式不同。例如，已知二维数组的行数（即第一维维度）为多少的情况下对其进行动态分配，与知道列数（第二维维度），或者两个维度都未知的情况下，二维数组的动态分配方式都不同，对应的释放方式也不同。下面我们就来一一介绍。

1. 已知二维数组的行数

   既然已知行数，那么先静态分配指针数组（内部的值为指针的数组，数组的长度是二维数组的行），再动态分配二维数组的列

   ```cpp
   const int ROW=3;//已知行数
   int *a[ROW];//指针数组
   
   int col; //列数为未知，动态输入
   cin>>col;
   
   //动态分配
   for(int i=0;i<ROW;i++){
       a[i]=new int[col];
       /*输入数组元素
       for (int j = 0; j < col; j++){
           cin >> a[i][j];
       }*/
   }
   //释放
   for(int i=0;i<ROW;i++){
       delete[] a[i];
   }
   ```

   上述方法中指针指向的数组在内存中并不一定是连续存放的，如果需要保持内存的连续性，则需要一次分配内存

2. 已知二维数组的行数，一次分配内存（保持内存的连续性）

   ```cpp
   const int ROW=3;//已知行数
   int *a[ROW];//指针数组
   
   int col; //列数为未知，动态输入
   cin<<col;
   
   //动态分配
   a[0]=new int[ROW*col];
   for(int i=1;i<ROW;i++){
       a[i]=a[i-1]+col;
   }
   
   //释放
   delete[] a[0];
   ```

3. 已知二维数组的列数

   先静态分配一个数组指针（指向数组的指针，数组的长度就是二维数组的列），再动态分配行

   ```cpp
   const int COL=2;//已知列数
   int (*a)[COL];//数组指针
   int row;//行数为未知，动态输入
   cin<<row;
   //动态分配
   a=new int[row][COL];
   //释放
   delete[] a;
   ```

4. 未知二维数组的行数和列数

   **行和列都要动态分配，先动态分配一个指针数组（此数组的长度为二维数组的行），再对指针数组进行遍历，对每一个成员再分配一个数组（此数组的长度为二维数组的列）**

   ```cpp
   int **a;//指针的指针
   
   int row,col;//未知行数和列数，动态输入
   cin<<row<<col;
   
   //动态分配
   a=new int*[row];//给a分配了一个指针数组的首地址
   for(int i=0;i<row;i++){
       a[i]=new int[col];//对指针数组中的每一个成员再进行动态内存分配
   }
   //释放
   for(int i=0;i<row;i++){
       delete[] a[i];
   }
   delete[] a;
   ```

5. 未知二维数组的行数和列数，一次分配内存（保持内存的连续性）

   ```cpp
   int **a;//指针的指针
   int row,col;//未知行数和列数，动态输入
   cin<<row<<col;
   //动态分配
   a=new int*[row];
   a[0]=new int[row*col]
   for(int i=1;i<row;i++){
       a[i]=a[i-1]+col;
   }
   //释放
   delete[] a[0];
   delete[] a;
   ```

   

## 头文件不应包含using声明

>位于头文件的代码(参见2.6.3 节，第67页) 一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明, 
>那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。





## 值初始化
>通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会
>创建一个值初始化的( value-initialized)元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。如果vector对象的元素是内置类型，比如int,则元素初始值自动设为0。如果元素是某种类类型，比如string，则元素由类默认初始化:

```cpp
vector<int> ivec(10) ;
// 10个元素，每个都初始化为0
vector<string> svec(10) ;
// 10个元素，每个都是空string对象
```

>对这种初始化的方式有特殊限制:**有些类要求必须明确地提供初始值(参见2.2.1节，第40页)，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说,只提供元素的数量而不设定初始值无法完成初始化工作。**

P94
>**关于下标必须明确的一点是:只能对确知已存在的元素执行下标操作**。例如，

```cpp
vector<int> ivec;
//空vector对象
cout << ivec[0] ;
//错误: ivec不包含任何元素
vector<int> ivec2 (10) ;
//含有10个元素的vector对象
cout << ivec2[10] ;
//错误: ivec2元素的合法索引是从0到9
```

>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发
>现，而是在运行时产生一个不可预知的值。

P99
## 某些对vector对象的操作会使迭代器失效
>3.3.2节(第90页)曾经介绍过，虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，**比如push_ back，都会使该
>vector对象的迭代器失效**。

### 编写改变容器的循环程序

c++中STL容器vector/list/map/set/deque/string等删除元素的问题，迭代器容易出现以下错误，示例代码如下：

```cpp
std::vector<int> arrayList;
...
std::vector<int>::iterator it = arrayList.begin();
for ( ; it != arrayList.end(); it++)
{
    if (...)
        arrayList.erase(it);
}
```

根本原因是：当容器中的一个元素被删除时，指向该元素后续的迭代器变得无效。上面的代码中，只要执行了erase(it),那么it就会变得无效，那么执行it++就肯定会出错。

因为迭代器的本质是在一个叫Iterator的对象内部维护了遍历容器的索引，从而通过此对象来访问容器内的数据

- 对于顺序容器如vector，string，deque内部所维护的是当前所遍历到的位置下标。对于顺序容器的删除，插入操作会导致当前元素以及后面元素位置的改变，所以在修改操作之前维护的，当前元素以及后面元素的迭代器都会失效，即指向错误的位置
- 对于节点式容器如list，set，map，内部所维护的是指向当前所遍历到的节点的指针。此类容器插入和删除操作只会导致所指向元素的迭代器失效，其他元素的迭代器不受影响

对于节点容器的遍历删除正确写法：

```cpp
std::map<int, struct> mapInfo;
...
std::map<int, struct>::iterator it = mapInfo.begin();
while (it != mapInfo.end())
{
    if (...)
    {
        // 删除节点的前，对迭代器进行后移的操作，因为其他元素不会失效
        mapInfo.erase(it++);
        // 在C++11后也可使用下面的方式
        // it = mapInfo.erase(it);
    }
    else
    {
        it++;
    }
}
```

对于顺序容器的遍历删除正确写法：

```cpp
std::vector<int> arrayInt;
...
std::vector<int>::iterator it = arrayInt.begin();
while (it != arrayInt.end())
{
    if (...)
    {
        // 需要注意的是，因为顺序式容器会使本身和后面的元素迭代器都失效，所以不能简单的++操作
        // 顺序式容器的erase()会返回紧随被删除元素的下一个元素的有效迭代器（节点式容器的erase()的返回值是void（在C++11后节点式容器的返回值也是被删除元素的下一个元素））
        it = arrayInt.erase(it);
    }
    else
    {
        it++;
    }
}
```



>添加/删除vector、string 或deque元素的循环程序必须考虑迭代器、引用和针可能失效的问题。**程序必须保证每个循环步中都更新迭代器、引用或指针**。如果循环中调用的是insert或erase，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201019185737284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk4ODMz,size_16,color_FFFFFF,t_70#pic_center)

>此程序删除vector中的偶数值元素，并复制每个奇数值元素。**我们在调用insert 和erase后都更新迭代器，因为两者都会使迭代器失效**。
>在调用erase后，不必递增迭代器，因为erase
>返回的迭代器已经指向序列中下一个元素。调用insert后，需要递增迭代器两次。记住，insert在给定位置之前插入新元素，然后返回指向新插入元素的迭代器。因此，在调用insert后，iter指向新插入元素，位于我们正在处理的元素之前。我们将迭代器递增两次，恰好越过了新添加的元素和正在处理的元素，指向下一个未处理的元素。

### 不要保存end返回的迭代器

>当我们添加/删除vector或string的元素后,或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。**因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当作容器末尾使用**。通常C++标准库的实现中end()操作都很快，部分就是因为这个原因。

---

## 

P103

```cpp
int *ptrs[10] ;
//ptrs是含有10个整型指针的数组
int &refs[10] = /* ?*/;
//错误:不存在引用的数组
int (*Parray) [10] = &arr;
// Parray 指向一个含有10个整数的数组
int (&arrRef) [10] = arr;
// arrRef引用一个含有10个整数的数组
```
P109
字符串字面值是一.种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串(C-style character string)。C风格字符串不是一种类型， 而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束(nullterminated)。以空字符结束的意思是在字符串最后一个字符后面跟着-一个空字符(' \0' )。
一般利用指针来操作这些字符串。

传入此类函数的指针必须指向以空字符作为结束的数组:
char ca[] = {'C', '+', '+' };
//不以空字符结束
cout << strlen(ca) << endl ;
//严重错误: ca没有以空字符结束
此例中，ca虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下来。

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径
庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符:
string s1 = "A string example";
string s2 = "A different string";
if(s1<s2)//false:s2小于s1
如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身:
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (cal < ca2) // 未定义的:试图比较两个无关地址
谨记之前介绍过的，当使用数组的时候其实真正用的是指向数组首元素的指针

P193
>**如果我们传给print函数的是一一个数组，则实参自动地转换成指向数组首元素的指针,
>数组的大小对函数的调用没有影响。**

P201
**不要返回局部对象的引用或指针**

## 类

### 构造函数

#### 构造函数初始值列表

```c
struct Sales_data{
	std: :string bookNo;
	unsigned units sold = 0;
	double revenue = 0. 0;
};
```

**没有出现在构造函数初始值列表中的成员将通过相应的类内初始值(如果存在的话)初始化，或者执行默认初始化**。对于Sales_ data 来说，这意味着一旦函数开始执行，则bookNo将被初始化成空string对象，而units_ sold和revenue将是0。

就对象的数据成员而言，初始化和赋值也有类似的区别。**如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化**。例如:

```c++
//Sales_data构造函数的正确写法，对数据成员进行了初始化
Sales_data::Sales_data(const string&s,unsigned cnt,double price):bookno(s),units_sold(cnt),revenue(price){}
//Sales_data构造函数的一种写法，虽然合法但比较草率：没有使用构造函数初始值
Sales_ data::Sales_ data (const string &s,unsigned cnt， double price){
	bookNo = s ;
	units_ sold = cnt ;
	revenue = cnt * price;
}
```

当构造函数完成后，数据成员的值相同。**区别是原来的版本初始化了它的数据成员,而这个版本是先对数据成员进行了初始化（如果有类内初始值就通过类内初始值初始化，如果没有，就进行默认初始化），然后在函数体内再进行赋值操作。**

#### =default的含义

![image-20210814184319340](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210814184319340.png)

#### 构造函数初始值列表有时必不可少
有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样**。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。**例如:

```c++
class ConstRef {
public:
	ConstRef (int i) ;
private:
	int i;
	const int ci ;
	int &ri;
};
```

**和其他常量对象或者引用一样，成员ci和ri都必须被初始化**。因此，如果我们没有为它们提供构造函数初始值的话将引发错误: 

类必须包含一个默认构造函数以便在上述情况下使用，其中的大多数情况非常容易判断。**不那么明显的一种情况是类的某些数据成员缺少默认构造函数**:

```c++
class NoDefault{
public:
	NoDefault (const std::string&) ;
	//还有其他成员，但是没有其他构造函数了
};
struct A {
	//默认情况下my_mem是public的
	NoDefault my_mem;
};
A a; //错误:不能为A合成构造函数
struct B{
	B() {}	//错误:b_member没有初始值
	NoDefault b_member;
};
```

#### 值是如何被返回的

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210814185303372.png" alt="image-20210814185303372" style="zoom:67%;" />

**也就是说，如果返回的是一个类对象，那么会调用该类的拷贝构造函数**。

#### 拷贝、赋值和析构

编译器会默认给类生成默认构造函数、拷贝构造函数、重载的赋值运算符以及析构函数。当我们自定义了构造函数时，默认情况下就不会再隐含生成默认构造函数，但是其他三个函数依然会生成（拷贝构造函数，析构函数，重载赋值运算符）

- 当**初始化对象**时，或**以值的方式传递或返回一个对象**时，调用拷贝构造函数
- 当对对象赋值时，调用赋值运算符
- 当对象不存在时执行销毁操作时调用析构函数。比如一个局部对象会在创建它的块结束时被销毁；vector对象（或数组）销毁时存储在其中的对象也会被销毁。

### 使用class或struct关键字

使用class定义类的默认访问权限是private，使用struct定义类的默认访问权限是pubic。这是二者的唯一区别。

### 类的作用域

![image-20210814231235052](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210814231235052.png)

例如，我们回顾一下 `Window_mgr`类的clear成员，该函数的参数用到了`Window_mgr`类定义的一种类型`ScreenIndex`:

```c++
void Window_mgr::clear(ScreenIndex i){
	Screen &s = screens[i];
	s.contents = string(s.height * s.width,' ') ;
}
```

因为编译器在处理参数列表之前已经明确了我们当前正位于`window_mgr`类的作用域中，所以不必再专门说明`ScreenIndex`是`Window_mgr`类定义的。出于同样的原因，编译器也能知道函数体中用到的screens也是在`window_mgr` 类中定义的。

另一方面，函数的返回类型通常出现在函数名之前。**因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员**。例如，我们可能向`Window_mgr`类添加-一个新的名为`addScreen`的函数，它的返回类型为`ScreenIndex`

```c++
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen &s){
	screens.push_back(s) ;
	return screens.size() - 1;
}
```

**加上作用域，就相当于在类的内部，可以访问该类的私有成员**。



P250

>对于类型Screen来说，在它声明之后定义之前是一一个不
>完全类型( incomplete type)，也就是说，此时我们已知Screen是一一个类类型，但是不清楚它到底包含哪些成员。
>不完全类型只能在非常有限的情景下使用:可以定义指向这种类型的指针或引用，也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。**对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明**。
>否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义,然后才能用引用或者指针**访问**其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到
>底有哪些成员。
>在7.6节(第268页)中我们将描述一种例外的情况: 直到类被定义之后数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才能被定义，所以**一个类的成员类型不能是该类自己**。然而，一.旦一个类的名字出现后，它就被认为是声明过了(但尚未;定义)，**因此类允许包含指向它自身类型的引用或指针**:

class Link_ screen{
Screen window ; .
Link_ screen *next ;
Link_ screen *prev;
};

---
P304

## 关系运算符

>每个容器类型都支持相等运算符(= =和!=);除了无序关联容器外的所有容器都支持
>关系运算符(>、>=、<、<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。
>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算(参见3.2.2节，第79页)类似:
>●如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等;否则.两个容器不等。
>●如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。
>●如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第-一个不相等的元素的比较结果。
>下面的例子展示了这些关系运算符是如何工作的:

```cpp
vector<int>v1={1,3,5,7，9，12};
vector<int> v2 = { 1, 3，9 };
vector<int> v3 = { 1，3，5，7 };
vector<int>v4={1,3,5，7，9，12};
v1 < v2 // true; v1和v2在元素[2]处不同: v1[2]小于等于v2[2]
v1 < v3 // false;所有元素都相等，但v3中元素数目更少
vl == v4 // true; 每个元素都相等，且v1和v4大小相同
v1 == v2 // false; v2元素数目比v1少
```
---
## c++ extern关键字的作用
C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了将程序分为许多文件，则需要在文件中共享代码，例如一个文件的代码可能需要另一个文件中中定义的变量。

为了支持分离式编译，C++允许将声明和定义分离开来。变量的声明规定了变量的类型和名字，即使一个名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义则负责创建与名字关联的实体，定义还申请存储空间。

**如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量：**

```cpp
extern int i;  //声明i而非定义
int j;         //声明并定义i
```
但我们也可以给由extern关键字标记的变量赋一个初始值，但这样就不是一个声明了，而是一个定义：
```cpp
extern int v = 2;
int v = 2;     //这两个语句效果完全一样，都是v的定义
```
利用关键字extern，可以在一个文件中引用另一个文件中定义的变量

---
---
函数签名：函数的名称及其参数类型组合在一起，就定义了一个唯一的特性，称为函数签名。（不包括返回类型）

c++要求重载函数具有不同的签名。返回类型不是函数签名的一部分。
函数重载要求函数的参数个数不同或者参数类型不同。
因为调用函数的时候无法确认函数的返回类型，所以仅返回类型不同的函数都可以匹配，这样就造成二义性，所以仅仅是返回类型不同是不能重载的
https://www.cnblogs.com/happybirthdaytoyou/p/10358137.html

----
---
```cpp
#include<iostream>
#include<bitset>
#include<string>
using namespace std;
class fuck
{
public:
	int mother;
	fuck()
	{
		mother = 10;
	}
};
int main()
{
	int* p = new int;
	int* p2 = new int();//对于内置类型，不加括号不初始化，加括号默认初始化
	cout << *p << endl;
	cout << *p2 << endl;
	fuck* p3 = new fuck;
	fuck* p4 = new fuck();//对于类类型，无论加不加括号都是默认初始化
	cout << p3->mother << endl;
	cout << p4->mother << endl;

}

```
析构函数和默认构造函数搭配使用：
在默认构造函数中：打开文件，链接数据库，动态分配内存
在析构函数中：关闭文件，关闭数据库，回收动态分配内存
构造函数一个类可以有多个，而析构函数只能有一个

```cpp
int main()
{
	sales_item a;
	sales_item b = a;//这里是拷贝初始化，所以调用的是拷贝构造函数
	b = a;//这里是赋值，所以调用的是赋值运算符
}
```
一个类中并不是一定要有一个默认构造函数，比如当一个类中有一个拷贝构造函数时，编译器不会帮我们写一个合成的默认构造函数，此时如果我们没有写默认构造函数，这个类中就没有默认构造函数，如果我们声明对象时不需要进行默认初始化，则这个类是合法的
也就是说，只有当我们需要默认初始化对象时，才需要默认构造函数

-------------------------------------------------------------------------------------------------------------------------------------
**const成员函数**

```cpp
class sales_item {
public:
	string isbn()const { return bookno; };
	double avg()const {};
private:
	string bookno;
};
```
默认情况下，this的类型是指向非常量的常量指针（因为this永远指向调用它的对象，所以是一个常量指针），而const成员函数的作用是把这个函数中的this指针声明为指向**常量**的常量指针（即无法修改对象的属性）
**综上，const成员函数的意义为：
1·在const成员函数中无法修改对象的属性
2.一个被声明为常量（const）的对象只能调用常量（const）成员函数，不能调用其他成员函数**
 **所以，一个成员函数，如果对数据成员只涉及读操作，而不进行修改操作，则尽可能声明为常量成员函数**
 _----------------------------------------------------------------------------------------------------------------------------------

**C++中将整形数字转化为字符串的最简单的方法**
使用std::to_string
不但可以转换10进制整形数据，还可以是16进制的。
#include <string>
#include <iostream>
int value=10;
std::string s = std::to_string(value) ;
std::cout<<s<<std::endl;
std::cout<<std::to_string(0xfa11);

_----------------------------------------------------------------------------------------------------------------------------------

静态语言（强类型语言）
静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 
例如：C++、Java、Delphi、C#等。

动态语言（弱类型语言）
动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 
例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

_----------------------------------------------------------------------------------------------------------------------------------

**常量与常量表达式的区别**
**常量**是固定值,在程序执行期间不会改变
**常量表达式**是指值不会改变且**在编译过程中就能够得到计算结果**的表达式，能在编译时求值的表达式。
用const声明的即为常量（无法改变），但不一定是常量表达式
一个对象是不是常量表达式由它的**数据类型**和**初始值**共同决定
只有用常量表达式（或具体值在编译阶段就能获取的值）初始化的const对象才是常量表达式

```cpp
	
	const int a1 = 10;           // a1是常量表达式。
 
	const int a2 = a1 + 20;      // a2是常量表达式
 
	int a3 = 5;                  // a3不是常量表达式
 
	const int a4 = a3;           // a4不是常量表达式，因为a3程序的执行到达其所在的声明处时才初始化，所以变量a4的值程序运行时才知道。但编译没问题！
	const int a5=get_size();  //a5不是常量表达式，a5本身是一个常量，但具体值直到运行时才能获取
```
**说明了const声明的不一定就是常量表达式！**

使用const时，使用者无法确认是否是常量表达式，有可能是常量，也有可能是常量表达式
因此C++11新标准规定，允许将变量声明为constexpr 类型以便由**编译器来验证**变量的值是否是常量表达式。
如果一个表达式不是常量表达式，编译器会报错。

```cpp
const int a1 = 10;           // a1是常量表达式。
 
	const int a2 = a1 + 20;      // a2是常量表达式
 
	int a3 = 5;                  // a3不是常量表达式
 
	constexpr int a4 = a3; 
	//  a4不是常量表达式，因为a3程序的执行到达其所在的声明处时才初始化，所以变量a4的值程序运行时才知道。编译报错！
	//只有当a3是一个常量表达式时。才是一条正确的语句
	constexpr int sz=get_size();
	//只有当get_size()是一个constexpr函数时，才是一条正确的语句

```
**constexpr函数**
constexpr函数是指能用于常量表达式的函数，函数的返回类型以及所有形参类型都得是字面值类型，且函数体中有且只有一条return语句
constexpr函数允许返回一个非常量，即调用constexpr函数的结果不一定是常量表达式
**也就是说，能用于常量表达式的函数一定是constexpr函数，但只有当constexpr函数的返回值是一个常量表达式时才能用于常量表达式**
![](https://img-blog.csdnimg.cn/20200418105655813.png)
由于数组需要在编译阶段分配空间，所以声明数组时，数组的大小必须是**常量表达式**

_----------------------------------------------------------------------------------------------------------------------------------


**四种初始化方式**
默认初始化、直接初始化、拷贝初始化、列表初始化

_----------------------------------------------------------------------------------------------------------------------------------

**C++指向类成员的指针的使用**
首先普通函数指针不能被赋值为成员函数的地址，即使返回类型和参数完全匹配。例如：下面是的pfi是一个普通函数指针，它没有参数，返回类型为int：
 int (*pfi)();
若有两个全局函数，HeightIs()和WidthIs():
 int HeightIs();
 int WidthIs();
则下面的的赋值操作是合法的：
 pfi = HeightIs();
 pfi = WidthIs();

但如今有一个类Screen也定义了两个访问函数－height()和width()，它们也没有参数，
返回类型也为int：
 inline int Screen::height() { return _height; }
 inline int Screan::width()  { return _width;  }
但是下面的赋值是非法的，会导致编译错误产生。
 pfi = &Screen::height();

**为什么会出现违例？因为，成员函数有一个非成员函数不具有的属性－它的类(class)。
指向成员函数的指针必须与其赋值的函数类型匹配，不是两个方面而是三个方面：
(1)参数类型和个数(2)返回类型 (3) 它所属的类类型。**

成员函数指针和普通函数指针之间的不匹配是由于这两种指针在表示上的区别

**指向类成员的指针语法不
能被用来引用类的静态成员静态类成员**

_----------------------------------------------------------------------------------------------------------------------------------

我们可以把基类的**指针或引用**绑定到派生类的对象上，派生类会发生隐式类型转换。

只有在我们使用基类的**引用或指针**调用一个**虚成员函数**时才会发生动态绑定，即在运行时根据绑定到指针或引用上的对象的实际类型来调用对应的函数。

只有上述情况才会发生动态绑定，其他的任何情况，调用的成员都是根据声明对象的静态类型确定的，
对象声明时的类型是什么，实际类型就是什么。

****派生访问说明符对于派生类的成员（及友元）能否访问其直接基类没什么影响。**

**派生类对直接基类的访问权限取决于直接基类内部的访问控制说明符。**

**派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。****

-----------------------------------------------------------------------------------------------------------------------------------------

数组的名字可以当做指针，但并不是所有指针都可以当做数组名
所以数组的初始化方式如下

```cpp
int main()
{
    int a[] = { 1,2,3 };
    int* a2 = a;
    int* a3 = { 1,2,3 };//错误
}
```

字符串属于静态存储类别，如果在函数中使用字符串常量 ，该字符串只会被储存一次，用双括号括起来的内容被视为指向该字符串储存位置的指针（类似于把数组名作为指向该数组位置的指针） 
所以字符数组初始化有两种方式：

```cpp
int main()
{
    char s1[] = "fuck";//数组表示法初始化
    char* s2 = "you";//指针表示法初始化
}
```
但以上两种形式并不完全相同
数组表示法把静态存储区的字符串拷贝到数组中，此时字符串有两个副本，一个在静态内存中的字符串字面量，另一个是储存在数组中的字符串
数组名是该数组首元素地址的别名，是常量，无法更改，如果更改，即意味着改变了数组的储存位置。
可以进行p+1这样的操作，但无法进行p++这样的操作。
指针表示法把静态存储区的字符串地址赋值给指针

```cpp
int main()
{
    char s1[] = "fuck";
    char* s2 = "you"；
    int a[] = { 1,2,3 };
    a++;//错误
    s1++;//错误
}
```

```cpp
	int(*a)[4] = { 0 };//声明了一个指针，指向含有4个元素的数组，相当于int a[][4](实际可以)
	int a[][4]={0};
    int* a2[4] = { 0 };//声明了一个数组，含有4个指针，即可放下4个字符串的地址，不规则数组，适用于字符串数组，相当于int a2[4][](实际不可行)
```
------------------------------------------------------------------------------------------------------------------------------------------
一个**方法**可以访问**所属类**的**所有对象**的的私有属性
私有数据只能在类内访问，**即便是子类也不能访问从父类继承的私有属性**

如果构造子类对象时需要初始化从父类继承来的属性，则必须（最好）在子类的构造函数后显示的调用父类的构造函数
如果子类的构造函数后没有显式的调用父类的构造函数，将自动调用父类的无参数构造函数（默认构造函数）。如果父类没有无参数构造函数，并且子类的构造器中又没有显式地调用父类的其他构造函数，编译器就会报错

子类的构造基本上都需要调用父类的构造函数
```cpp
class employee
{
private:
	double salary;
	string name;
	
public:
	
	employee(string name,double salary)
	{
		this->name = name;
		this->salary = salary;
	}
	~employee();
	string getname()
	{
		return name;
	}
	double getsalary()
	{
		return salary;
	}
	void fuck(employee staff)
	{
		staff.name;//一个**方法**可以访问**所属类**的**所有对象**的的私有属性
	}
};
class manager:public employee
{
private:
	double bonus;
public:
	manager(string name, double salary, double bonus):employee(name,salary)//调用父类的构造函数
	{
		this->bonus = bonus;	`
	}
};
```
-------------------------------------------------------------------------------------------------------------
对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数（virtual）**
派生类并不是一定要覆盖它继承的虚函数，如果没有覆盖，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本，派生类可以在这样的函数之前加上virtual，但并不是非得这么做
当我们用基类的引用或指针调用一个虚函数时将发生**动态绑定（dynamic binding）**，根据指针或引用所绑定的对象类型不同，该调可能执行基类的版本，也可能执行派生类的版本
我们必须区分一个表达式的**静态类型**和**动态类型**，静态类型在编译时是已知的，它是变量声明的类型，动态类型是变量或表达式表示的内存中的对象的类型，直到运行时才知道。
所以动态绑定之后也无法调用子类特有的属性或方法，因为此时对象的类型为基类。

只有基类的引用或指针的静态类型才可能与其动态类型不一致。
---------------------------------------------------
**对于一个空类，编译器默认生成四个成员函数：默认构造函数、析构函数、拷贝构造函数、赋值函数**

C++ primer p406 ：复制构造函数是一种特殊的构造函数，具有单个形参，该形参**（常用const修饰）**是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用复制构造函数。当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用复制构造函数。

 

C++支持两种初始化形式：复制初始化（int a = 5;）和直接初始化（int a(5);）对于其他类型没有什么区别，对于类类型直接初始化直接调用实参匹配的构造函数，复制初始化总是调用复制构造函数，也就是说：

A x(2);　　//直接初始化，调用构造函数
A y = x;　　//复制初始化，调用复制构造函数

 

必须定义复制构造函数的情况：

只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义复制构造函数也可以复制；有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源，这两种情况下都必须定义复制构造函数。

为什么复制构造函数的参数需要加const和引用
https://www.cnblogs.com/engraver-lxw/p/7580403.html

C++重载++和--（自增和自减运算符）
http://c.biancheng.net/view/247.html

前置++运算符的返回值类型是 CDemo &，而后置++运算符的返回值类型是 CDemo，这是因为运算符重载最好保持原运算符的用法。**C++ 固有的前置++运算符的返回值本来就是操作数的引用，而后置++运算符的返回值则是操作数值修改前的复制品。**例如：
int a = 5;
(++a) = 2;
上面两条语句执行后，a 的值是 2，因为 ++a 的返回值是 a 的引用。而
(a++) = 2;
这条语句是非法的，因为 a++ 的返回值不是引用，不能作为左值。

**C++中的函数重复定义问题**
头文件中直接写函数实现会出现重复定义的错误,但是如果是在类中直接写函数实现就不会出现此错误,原因是两个cpp都包含该头文件,相当于头文件中的同一个函数实现被编译了两次,那么就出现了二义性问题,即调用该函数的地方不知道应该使用哪个函数实现.

类中写函数实现就没这个问题,因为会被当成inline函数处理.

另外,这与函数重载不一样,函数重载由于特征标的存在编译器能够区分调用哪个实现,其实相当于两个不同的函数,而同一个函数两个实现(哪怕是完全一样的实现)在编译器看来是没法区分开来的,无法知道调用哪个实现,所以出现二义性错误.




--------------------------------------------------------------------------------------------------
**关于ios::sync_with_stdio(false);和 cin.tie(0)加速c++输入输出流**
https://www.cnblogs.com/PrayG/p/5749832.html