# MySQL是怎样运行的

启动MySQL服务器程序：

```
sudo service mysql start
sudo service mysql stop
sudo service mysql restart
```

启动MySQL客户端程序：

```
mysql -h主机名 -u用户名 -p密码
```

- -h表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填 localhost 或者 127.0.0.1

- 如果服务器进程监听的端口号不是默认的 3306 ，我们也可以在使用 mysql 启动客户端程序时使用 -P 参数（大写的 P ，小写的 p 是用来指定密码的）来指定需要连接到的端口号。

比如：`mysql -hlocalhost -uroot -p123456`

输入 quit退出客户端程序

可以在一台电脑上同时启动多个客户端程序连接到一个服务器，也可以在不同的电脑上使用IP地址作为主机名连接到另一条电脑上的服务器。

不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：**客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）**。

## 服务器处理客户端请求

服务器程序处理客户端请求的流程：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211112171647481.png" alt="image-20211112171647481"  />

- 连接管理：

  客户端进程可以采用TCP/IP 、 命名管道或共享内存 、 Unix域套接字 这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个 客户端的交互，**当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端**。这样就起到了不频 繁创建和销毁线程的效果，从而节省开销。

- 解析与优化：

  MySQL 服务器获得了文本形式的请求后，需要经过以下步骤对其进行处理

  - 查询缓存：**MySQL 服务器程序会把之前处理过的查询请求和结果缓存起来**，如果下一次有一模一样的请求过来，直接从缓存中查找结果。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送 了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。
    - 如果两个查询请求在任何字符上的不同，都会导致缓存不会命中
    - MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除
  - 语法解析：对MySQL语句做分析，判断请求的语法是否正确，然后从文本中将要查询的表、 各种查询条件提取出来
  - 查询优化：**对MySQL语句做优化，使查询效率更高**。会生成一个执行计划，表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用 EXPLAIN 语句来查看某个语句的执行计划

- 存储引擎：**接收上层传下来的指令，然后对表中的数据进行提取或写入操作**。

**连接管理 、 查询缓存 、 语法解析 、 查询优化 这些并不涉及真实数据存储的功能被划分 为 MySQL server 的功能，真实存取数据的功能被划分为 存储引擎 的功能**。各种不同的存储引擎向上边的 MySQL server 层提供统一的调用接口

所以在 MySQL server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了

## 存储引擎

MySQL支持的存储引擎：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211112174843910.png" alt="image-20211112174843910" style="zoom:50%;" />

查看当前服务器程序支持的存储引擎：

```
SHOW ENGINES;
```

**我们可以为不同的表设置不同的存储引擎**，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。

如果创建表的语句没有指定表的存储引擎，就会使用默认的存储引擎InnoDB。也可以显式地指定表的存储引擎：

```
CREATE TABLE 表名(
 建表语句;
) ENGINE = 存储引擎名称
```

修改表的存储引擎：

```
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

## InnoDB

InnoDB将表中的数据存储到磁盘上，真正处理数据的过程发生在内存中。InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 16 KB。

### 行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 **行格式** 或者 **记录格式**

InnoDB中有4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、 Dynamic 和 Compressed 行格式

我们可以在创建或修改表的语句中指定 行格式 ：

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称 
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

![image-20211113105703928](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113105703928.png)

#### COMPACT行格式

![image-20211113104809261](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113104809261.png)

在 Compact 行格式中，把所有变长字段（比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB类型）的真实数据**占用的字节长度都存放在记录的开头部位**，从而形成一个**变长字段长度列表**，各变长字段数据占用的字节数按照列的顺序**逆序**存放

变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度 是不储存的

填充完变长字段长度列表 的两条记录的对比图如下：

![image-20211113110138356](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113110138356.png)

表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 记录的真实数据 中存储会很占地方，所以 **Compact 行格式把这些值为 NULL 的列统一管理起来，存储到 NULL 值列表中**

除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 **记录头信息** ，它是由固定的 5 个字节组 成。 

![image-20211113111116247](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113111116247.png)

**记录的真实数据**：

对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据 以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ）

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113111426601.png" alt="image-20211113111426601" style="zoom:50%;" />

InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则 选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。

**InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）**

加上 记录的真实数据 的两个记录的内容：

![image-20211113111650645](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113111650645.png)

1. 表 record_format_demo 使用的是 ascii 字符集，所以 0x61616161 就表示字符串 'aaaa' ， 0x626262 就表 示字符串 'bbb' ，以此类推。 
2. 注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是： 'cc' ，而 ascii 字符集中 的字节表示是 '0x6363' ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，**除真实数据以外的8个字节的统统都用空格字符填充**，空格字符在 ascii 字符集的表示就是 0x20 。 
3. 注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处 就不再冗余存储，从而节省存储空间。

**变长字段长度列表中不止存储变长字段，还存储用变长字符集编码的定长字段**。

比如第1条记录中 c3 列的值，它是 CHAR(10) 类型的，采用ASCII编码时每个字符为一个字节，我们知道这个字段就占十个字节，不需要将它加入变长字段长度列表。而如果采用utf8编码，c3列占用的长度也会被存储到变长字段长度列表中。

比如我们修改一下 record_format_demo 表第三列的字符集： 

```
mysql> ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8; 
```

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113112941426.png" alt="image-20211113112941426" style="zoom:50%;" />

#### Redundant行格式

![image-20211113142812025](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113142812025.png)

现在我们把表 record_format_demo 的行格式修改为 Redundant ：

```
mysql> ALTER TABLE record_format_demo ROW_FORMAT=Redundant;
```

![image-20211113143554918](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113143554918.png)

Redundant格式与compact格式不同的地方：

- Compact 行格式的开头是 *变长字段长度列表* ，而 Redundant 行格式的开头是 *字段长度偏移列表*

  - Redundant 行格式会把该条记录中**所有列**（包括 隐藏列 ）的长度信息都按 照**逆序**存储到 字段长度偏移列表
  - 偏移表示 **采用两个相邻数 值的差值来计算各个列值的长度**

  <img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113143624121.png" alt="image-20211113143624121" style="zoom:50%;" />

- 记录头信息：

#### 行溢出数据

**VARCHAR(M) 类型的列最多可以占用 65535 个字节**。其中的 M 代表该类型最多存储的字符数量，如 果我们使用 ascii 字符集的话，一个字符就代表一个字节

 MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之 外，**其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。所以 MySQL 服 务器建议我们把存储类型改为 TEXT 或者 BLOB 的类型。**这个 65535 个字节除了列本身的数据之外，还包括一些 其他的数据（ storage overhead ）**，比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间：

- 真实数据 
- 真实数据占用字节的长度 
- NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间

MySQL 中磁盘和内存交互的基本单位是页 ，也就是说 **MySQL 是以 页 为基本单位来管理存储空间的**，我们 的记录都会被分配到某个 页 中存储。而一个页的大小一般是 16KB ，也就是 16384 字节，而一个 VARCHAR(M) 类 型的列就最多可以存储 65532 个字节，这样就可能造成**一个页存放不了一条记录的情况**。

在 Compact 和 Reduntant 行格式中，对于占用存储空间超过某个临界点的列，**在本记录的真实数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中**，这个 过程也叫做 **行溢出** ，存储超出 768 字节的那些页面也被称为 **溢出页** 。

![image-20211113150524052](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113150524052.png)

在列存储多少字节的数据时会发生行溢出：

- **MySQL 中规定一个页中至少存放两行记录**

![image-20211113151050959](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113151050959.png)

### 页结构

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113152222691.png" alt="image-20211113152222691" style="zoom:50%;" />

![image-20211113152315489](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113152315489.png)

我们自己存储的记录会按照我们指定的 行格式 存储到 User Records 部分。但是在一开 始生成页的时候，其实并没有 User Records 这个部分，**每当我们插入一条记录，都会从 Free Space 部分，也就 是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分**，当 Free Space 部分的空间全部 被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新 的页了

![image-20211113152451570](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113152451570.png)

#### 记录头信息

```
mysql> CREATE TABLE page_demo(
 -> c1 INT,
 -> c2 INT,
 -> c3 VARCHAR(10000),
 -> PRIMARY KEY (c1)
 -> ) CHARSET=ascii ROW_FORMAT=Compact;
```

![image-20211113162025697](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113162025697.png)

![image-20211113162110064](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113162110064.png)

下边我们试着向 page_demo 表中插入几条记录（记录中的实际数据用十进制表示出来）：

![image-20211113162503591](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113162503591.png)

- delete_mask

  这个属性**标记着当前记录是否被删除**，占用1个二进制位，值为 0 的时候代表记录并没有被删除，为 1 的时 候代表记录被删除掉了。

  所有被删除掉的记 录都会组成一个所谓的 垃圾链表 ，之后如果有 新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- min_rec_mask

  B+树的每层非叶子节点中的最小记录都会添加该标记

- heap_no 

  表示当前记录在本页中的位置。

  在每个页中自动存在两条记录，也称为 **伪记录** 或者 **虚拟记录**，这两个伪记录一个代表 最小记录 ，一个代表 最大记录（对于一条完整的记录来说，比较记录的大小就是比较主键的大小），最小记录和最大记录的 heap_no 值分别是 0 和 1

  这两条记录都是由5字节大小的 记录头信息 和8字节大小的一个固定 的部分组成的，

  <img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113163541396.png" alt="image-20211113163541396" style="zoom: 33%;" />

  由于这两条记录不是我们自己定义的记录，所以它们并不存放在 页 的 User Records 部分，他们被单独放在 一个称为 Infimum + Supremum 的部分

  <img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113163734534.png" alt="image-20211113163734534" style="zoom:50%;" />

- record_type 

  这个属性表示当前记录的类型，一共有4种类型的记录， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表 示最小记录， 3 表示最大记录。

- next_record

  **从当前记录的真实数据到下一条记录的真实数据的地址偏移量**，下一条记录 指得并不是按照我们插入顺序的下一条记录，而 是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是 本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就 是最大记录） 

  <img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113164037157.png" alt="image-20211113164037157" style="zoom:67%;" />

  **我们的记录按照主键从小到大的顺序形成了一个单链表**。

  

为什么next_record指针指向真实数据的起始位置，而不是额外信息开头的位置呢？

- 因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以**使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率**

删除第二条记录：

```
mysql> DELETE FROM page_demo WHERE c1 = 2;
```

![image-20211113164741829](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113164741829.png)

- 第2条记录并没有从存储空间中移除，而是把该条记录的 delete_mask 值设置为 1 。
- 第2条记录的 next_record 值变为了0，意味着该记录没有下一条记录了。
- 最大记录 的 n_owned 值从 5 变成了 4

当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成 一个垃圾链表，以备之后重用这部分存储空间



record组织方式和malloc组织方式的异同：

- malloc需要将空闲的区域链接起来，不需要将使用的块链接起来（显式空闲链表），因为用户知道正在使用的块的地址，可以直接找到该块。
- record需要将使用的区域链接起来，也需要将可重用的区域（即user record中的空闲区域）链接起来。

#### Page Directory（页目录）

InnoDB在每个页中都有一个目录：

- 将所有**正常的记录**（包括最大和最小记录，**不包括标记为已删除的记录**）划分为几个组。
- 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该组内共有几条记录。
- 将**每个组的最后一条记录的地址偏移量**单独提取出来按顺序存储到靠近页的尾部的Page Directory 中，这些地址偏移量被称为槽（slot），所以这个页面目录就是由 槽 组成的。

![image-20211113181117589](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113181117589.png)

槽1 中的值是 112 ，代表最大记录 的地址偏移量（就是从页面的0字节开始数，数112个字节）； 槽0 中的值是 99 ，代表最小记录的地址偏移 量。

![image-20211113182822798](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113182822798.png)

在一个数据页中查找指定主键值的记录的过程分为两步： 

1. 先通过二分法确定该记录所在的槽（比较查找的主键与被查找的槽中的最大的主键值），再找到该槽中主键值最小的那条记录。 
2. 通过记录的 next_record 属性遍历该槽所在的组中的各个记录。

注意！page中的record不是按照插入的顺序存放的，也不是按照主键的大小顺序存放的，**而是哪里有空闲空间就往哪里插，由链表将存储的record按照主键的顺序从小到大连接起来**。

#### Page Header（页面头部）

这个部分占用固定的 56 个字节，专门存储当前页的各种状态信息，比如本页中已经存储了多少条记录，第 一条记录的地址是什么，页目录中存储了多少个槽等等

![image-20211113183125119](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113183125119.png)

#### File Header（文件头部）

**Page Header 是专门针对 *数据页* 记录的各种状态信息，而 File Header 针对各种类型的页都通用**，也就是说不同类型的页都会以 File Header 作 为第一个组成部分，它**描述了一些针对各种页都通用的一些信息**，比方说这个页的编号是多少，它的上一个页、 下一个页是谁。

![image-20211113183507920](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113183507920.png)

- `FIL_PAGE_PREV` 和 `FIL_PAGE_NEXT`：

  InnoDB 都是以页为单位存放数据的，一张表中可以有成千上万条记录， InnoDB 不能一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要用双向链表把这些页关联起来

**所有的数据页其实是一个双向链表**

![image-20211113184212391](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113184212391.png)

#### File Trailer

 **InnoDB 会把数据存储到磁盘上，但是磁盘速度太慢，需要以 页 为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中**。但是在同步了一半的时候断电了怎么办？

**为了检测一个页是否完整（也就是在同步的时候有没有发生只同 一半的情况）**，InnoDB在每个页的尾部都加了一个 File Trailer 部分，这个部分由 8 个字 节组成，可以分成2个小部分

- 前4个字节代表页的校验和 

  这个部分是**和 File Header 中的校验和相对应的**。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 File Header 在页面的最前面，所以File Header中的校验和会被首先同步到磁盘，当完全写完时，File Trailer中的校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

### 索引

如果在一个页中搜索：

- 以主键为搜索条件可以较快地搜索（因为我们对主键建立了页目录）
- 非主键则只能遍历链表中的每条记录

如果一个表中的记录由多个页存储，则需要在多个页中搜索：

- **在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，都只能从第一个页开始沿着双向链表遍历查找**。

索引的实现：

复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为 **目录项记录**，使用记录头信息中的record_type属性来区分一条记录是普通的 用户记录（0） 还是 目录项记录（1）

![image-20211113215143419](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211113215143419.png)

目录项记录和普通的用户记录的不同点：

- 目录项记录 的 record_type 值是1，而普通用户记录的 record_type 值是0

- 目录项记录 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列， 另外还有 InnoDB 自己添加的隐藏列

- B+Tree非叶结点中每一层的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0

除此之外，它们没有任何区别，它们用的是一样的数据页，页的组成结构也是一样的，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用二分法来加快查 询速度。

#### 聚簇索引

上面建立的索引称为**聚簇索引**，它有两个特点：

- 使用record的主键来建立索引
- **B+Tree的叶节点存储的是完整的用户record，这个record中存储了所有列的值（包括隐藏列）**

这种聚簇索引 并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建， InnoDB 存储引擎会自动的为我们创建聚簇索引。**在 InnoDB 存储引擎中， 聚簇索引 就是数据的存储方式（所有的用户记录都存储在了叶子节点 ），也就是所谓的索引即数据，数据即索引**。

####  二级索引

上边的 聚簇索引 是对主键建立的索引，我们也可以多建几颗B+Tree，对记录中的其他的列建立索引。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114114903079.png" alt="image-20211114114903079" style="zoom:50%;" />

这个 B+ 树与上边介绍的聚簇索引有几处不同

- 使用用户记录中的c2列建立索引
- B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值
- 目录项记录中不再是 主键+页号 的搭配，而变成了 c2列+页号 的搭配

如果我们现在想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树，**查找到对应的叶节点后得到我们要查找的记录的主键值，再拿着主键值到聚簇索引中查找一遍**。这个过程也被称 为 回表 。也就是根据 c2 列的值查询一条完整的用户记录需要使用到 2 棵 B+ 树

所以这种 B+ 树也被称为 二级索引 （secondary index ），或者 辅助索引

**联合索引**：

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引

一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表 建立一个索引，那么**它的 根节点 的页号便会被记录到某个地方**，然后凡是 InnoDB 存储引擎需要用到这个索引的 时候，都会从那个固定的地方**取出 根节点 的页号，从而来访问这个索引**。

####  MyISAM中的索引方案

InnoDB 中索引即数据，也就是 聚簇索引的那棵 B+ 树的叶子节点中已经把所有完整的用户记录都包含了，而 **MyISAM 的索引方案是将索引和数据分开存储**

- 将表中的记录按照记录的插入顺序单独存储在**一个文件**中，称之为 数据文件 。这个文件并不划分为若干个数据页，我们可以通过行号而快速访问到一条记录。
-  MyISAM 会单独为表的主键创建一个索引，只不过**在索引的叶子节点中存储的不是完整的用户记录，而是 主键值 + 行号 的组合**。需要先通过索引找到对应的行号，再通过行号去找对应的记录！
- 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，这些索引在叶子节点处存储的也都是 列 + 行号，都是二级索引

也就是说MyISAM中的索引全部都是二级索引。对于变长记录，MyISAM会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量。

15445中的索引实际上类似于MyISAM中的索引

- InnoDB中的聚集索引中的叶节点直接存储record，所以主键值相近的record都存在同一个页中。
- 15445的record在磁盘中的组织形式是什么？主键值相邻的record存储在磁盘中的物理距离是否相邻？

#### MySQL中创建和删除索引的语句

**InnoDB 和 MyISAM 会自动为主键或者声明为 UNIQUE 的列去自动建立 B+ 树索引。如果我们想为其他的列建立索引就需要我们显式的去指明**

我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列： 

```
CREATE TALBE 表名 (
 各种列的信息 ··· ,
 [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)
```

比方说我们想在创建 index_demo 表的时候就为 c2 和 c3 列添加一个 联合索引：

```
CREATE TABLE index_demo(
 c1 INT,
 c2 INT,
 c3 CHAR(1),
 PRIMARY KEY(c1),
 INDEX idx_c2_c3 (c2, c3)
);
```

修改表结构时添加或删除索引

```
ALTER TABLE index_demo DROP INDEX idx_c2_c3;
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);
```



#### B+Tree示例

```
CREATE TABLE person_info(
 id INT NOT NULL auto_increment,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

该表的主键为id， InnoDB 存储引擎会自动为 id 列建立聚簇索引；我们额外定义了一个二级索引 idx_name_birthday_phone_number ，它是由3个列组成的联合索引，所以在这 个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 name 、 birthday 、 phone_number 这三个列的值 以及主键 id 的值，并不会保存 country 列的值。

![image-20211114153240025](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114153240025.png)

从图中可以看出，这个 idx_name_birthday_phone_number 索引对应的 B+ 树中页面和记录的排序方式是这样的： 

- 先按照 name 列的值进行排序。 
- 如果 name 列的值相同，则按照 birthday 列的值进行排序。 
- 如果 birthday 列的值也相同，则按照 phone_number 的值进行排序

**如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列**。

**对于字符串类型的索引列来说，我们只匹配 它的前缀也是可以快速定位记录的**，比方说我们想查询名字以 'As' 开头的记录，那就可以这么写查询语句：

```
SELECT * FROM person_info WHERE name LIKE 'As%'; 
```

但是如果只给出**后缀**或者中间的某个字符串，比如这样： 

```
SELECT * FROM person_info WHERE name LIKE '%As%'; 
```

MySQL 就无法快速定位记录位置了，因为字符串中间有 'As' 的字符串并没有排好序，所以**只能全表扫描**了。

####  主键插入顺序

对于一个使用 InnoDB 存储引擎的表来说，表中的数据实际上都是存储在 聚簇索引 的叶子节点的，**数据页和记录又是按照记录主键值从小到大的顺序进行排序**，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插。**而如果我们插入的主键值是随机的，那么可能会插入到已满的页中，此时就需要分裂成两个页面，将旧的页面中一半的record移到新的页面中，这样就会造成性能损耗**。

所以我们建议：**让主键具有 AUTO_INCREMENT** ，让存储引擎自己为表生成主键，而不是我们手动插入，**在插入记录时存储引擎会自动为我们填入自增的主键值**。

```
CREATE TABLE person_info(
 id INT UNSIGNED NOT NULL AUTO_INCREMENT,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
); 
```

综上，B+ 树索引适用于下边这些情况： 

- 全值匹配 
- 匹配左边的列 
- 匹配范围值 
- 精确匹配某一列并范围匹配另外一列 
- 用于排序 
- 用于分组

### MySQL的数据目录

 InnoDB 、 MyISAM 这样的存储引擎都是把表存储在磁盘上的，而操作系统使用文件系统来管理磁盘，所以**像 InnoDB 、 MyISAM 这样的存储引擎都是把表存储在文件系统上的**

MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储 到这个目录下的某些文件中，这个目录就称为数据目录

查看数据目录：

```
SHOW VARIABLES LIKE 'datadir';
```

**每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹**。每当我们使用 `CREATE DATABASE 数据库名` 语句创建一个数据库的时候，mysql会做两件事：

- 在 数据目录 下创建一个和数据库名同名的子目录（或者说是文件夹）。 
- 在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则

#### 表在文件系统中的表示

每个表的信息其实可以分为两种： 

- 表结构的定义 

  MySQL在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是： 表名.frm

- 表中的数据

  InnoDB 提出了一个概念为 表空间 或者 文件空间 （table space 或 者 file space ），表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。**每一个 表空间 可以被划分为很多很多很多个页 ，我们的表数据就存放在某个 表空间 下的某些页里**。

**系统表空间（system tablespace）**：

- 系统表空间 可以对应文件系统上一个或多个实际的文件，默认情况下， InnoDB 会在 **数据目录** 下创 建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示。

  从MySQL5.5.7到MySQL5.6.6之间的各个版本中，**我们表中的数据都会被默认存储到这个 系统表空间**

**独立表空间(file-per-table tablespace)**：

- 在MySQL5.6.6以及之后的版本中， InnoDB 并不会默认的把各个表的数据存储到系统表空间中，而是**为每一个表建立一个独立表空间**，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据 的话，会在**该表所属数据库对应的子目录**下创建一个表示该 独立表空间 的文件，文件名和表名相同，后加.ibd的扩展名。

对MyISAM来说，索引全部都是 二级索引 ，数据和索引是分开存放的。所以在文件系统 中也是**使用不同的文件来存储数据文件和索引文件**

视图在文件系统中的表示：

- MySQL 中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储 视图 的时候是不 需要存储真实的数据的，**只需要把它的结构存储起来就行了**

### InnoDB的表空间

#### 页面类型

InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引 都是以 B+ 树的形式保存到表空间的，而 **B+ 树的节点就是数据页**，数据页的类型名其实 是： `FIL_PAGE_INDEX`

除此之外，InnoDB还设计了其他的不同类型的页：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114171727313.png" alt="image-20211114171727313" style="zoom:50%;" />

所有的页的组成中有两个部分是通用的，任何类型的页都会包含file header和file trailer这两个部分：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114175250252.png" alt="image-20211114175250252" style="zoom: 33%;" />

file header的组成为：

![image-20211114175511223](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114175511223.png)

**表空间中的每一个页都对应着一个页号**，也就是 FIL_PAGE_OFFSET ，这个页号由4个字节组成，也就是32个 比特位，所以**一个表空间最多可以拥有2³²个页**，如果按照页的默认大小16KB来算，一个表空间最多支持 64TB的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3...依此类推

#### 独立表空间结构

##### 区（extent）

对于16KB的页来说，连续的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小。**不论是系统 表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组，每个组的最开始的几个页面类型是固定的**。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114175809080.png" alt="image-20211114175809080" style="zoom:50%;" />

![image-20211114180034799](https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114180034799.png)

- extent 0 这个区最开始的3个页面的类型是固定的， 分别是：

  - `FSP_HDR` 类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的 区 ，也就是 extent 0 ~ extent 255 这256个区的属性
  - `IBUF_BITMAP` 类型：这个类型的页面是存储本组所有的区的所有页面关于 INSERT BUFFER 的信息
  - INODE 类型：这个类型的页面存储了许多称为 INODE 的数据结构

- 其余各组最开始的2个页面的类型是固定的：

  - XDES 类型：全称是 extent descriptor ，用来登记本组256个区的属性，也就是说对于在 extent 256 区中的该类型页面存储的就是 extent 256 ~ extent 511 这些区的属性。

  - IBUF_BITMAP 类型

#####  段（segment）

B+Tree的范围查询需要沿着叶节点的链表扫描，如果是以 页 为单位来分配存储空间的话，双向链表相 邻的两个页之间的物理位置可能离得非常远，就会发生大量的随机I/O。磁盘上的随机IO速度很慢，我们应该**尽量让链表中相邻的页的物理位置也相邻**，这样进行范围查询的时候才可 以**使用顺序I/O** 。

所以才引入了 区 （ extent ）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大 的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是**按照 区 为单位分配**，甚至在表中的数据 十分非常特别多的时候，可以一次性分配多个连续的区。**虽然可能会造成一些空间浪费（数据不足填充整个区），但是可以消除大量的随机IO**。

同时，由于范围查询只扫描叶节点，所以如果我们将叶结点和内部节点放在同一个区中，效果也会大打折扣。所以叶子节点和非叶子节点都有自己独有的区 。**存放叶子节点的区的集合就算是一个 段** （ segment ），存放非叶 子节点的区的集合也算是一个 段 。也就是说**一个索引会生成2个段，一个叶子节点段，一个非叶子节点段**。

默认情况下一个表都有一个聚簇索引，一个索引会生成两个段，每个段至少占用一个区，所以一个表至少需要2M的存储空间，这样对于一些只有几条记录的小表就会浪费大量的空间。

因此提出了一个**碎片（fragment） 区**的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是**碎片区中的页 可以用于不同的目的**，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

**所以此后为某个段分配存储空间的策略是这样的**： 

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。 
- 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合

#### 区的分类

这些区大体上可以分为4种类型：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20211114183600845.png" alt="image-20211114183600845" style="zoom:50%;" />

