

# 第1章、基础

## 1、栈

- 调整数组大小

  选择用数组表示栈内容意味着用例必须预先估计栈的最大容量。在Java中，数组一旦创建，其大小是无法改变的，因此栈使用的空间只能是这个最大容量的一部分。因此，我们修改了数组的实现，动态调
  整数组a[]的大小，使得它既足以保存所有元素，又不至于浪费过多的空间。实际上，完成这些目标非常简单。首先，实现一个方法将栈移动到另一个大小不同的数组中: 

  ```java
  private void resize(int max){
      //将大小为N<=max的栈移动到一个新的大小为max的数组中
  	Item[] temp=(Item[])new Object[max];
      for(int i=0;i<N;i++)
          temp[i]=a[i];//将旧的栈中的元素复制到新的栈中
      a=temp;//将旧的栈的引用变成新的栈
  }
  ```

  现在，在push()中，检查数组是否太小。我们会通过检查栈大小N和数组大小a.1ength是否相等来检查数组是否能够容纳新的元素。如果没有多余的空间，我们会将数组的长度加倍。然后就可以用a[N++] = item插人新元素了:

  ```java
  public void push(Item item){
      if(N==a.length)resize(2*N);
      a[N++]=item;
  }
  ```

  类似，在pop()中，首先删除栈顶的元素，然后如果栈的大小小于数组的四分之一我们就将数组的长度减半。在数组长度被减半之后，它的状态约为半满，在下次需要改变数组大小之前仍然能够进行多次push()和pop()操作。

  ```java
  public Item pop(){
      Item item=a[--N];//从栈顶删除元素
      a[N]=null;//避免对象游离
      if(N>0&&N==a.length/4)resize(a.length/2);
      return item;
  }
  ```

- 对象游离

  Java的垃圾收集策略是回收所有无法被访问的对象的内存。在我们对pop()的实现中，被弹出的元素的引用仍然存在于数组中。这个元素实际上已经是一个孤儿了，它永远也不会再被访问了，但Java的垃圾收集器没法知道这一点，除非该引用被覆盖。这种情况(保存一个不需要的对象的引用)称为**游离**。避免对象游离需将被弹出的数组元素的值设为null，这将覆盖无用的引用并使系统可以在用例使用完被弹出的元素后回收它的内存。

- 迭代

  **集合类数据类型的基本操作之一就是，能够使用java的foreach语句通过迭代遍历并处理集合中的每个元素**。

  ```java
  Stack<String> collection = new Stack<String> O);
  for (String S : collection)
  	StdOut.print1n(s);
  ```

  foreach语句只是while语句的一种简写方式(就好像for语句一样)。它本质上和以下while语句是等价的:

  ```java
  Iterator<String> i = co1lection.iterator();
  while (i. hasNext()){
  	String S = i.next();
  	StdOut.print1n(s);
  }
  ```

  **这段代码展示了一些在任意可迭代的集合数据类型中我们都需要实现的东西:**

  - 集合数据类型必须实现一个iterator()方法并返回一个Iterator对象;
  - Iterator类必须包含两个方法: hasNext( (返回一个布尔值)和next() (返回集合中的一个泛型元素 )。

  要使一个类可迭代

  1. 第一步实现 `Iterable<Item>`接口，对应的接口(即java.lang.Iterable)为:

     ```java
     pub1ic interface Iterab1e<Item>{
     	Iterator<Item> iterator() ;
     }
     ```

  2. 然后重写iterator( )方法并返回一个**迭代器（即一个实现了`Iterator<Item>`接口的类的对象）**。对于一直使用的数组表示法，我们需要逆序迭代遍历这个数组，因此我们将迭代器命名ReverseArrayIterator,并添加了以下方法

     ```java
     pub1ic Iterator<Item> iterator()
     { return new ReverseArrayIterator(); }
     ```

  3. 迭代器：一个实现了`Iterator<Item>`接口的类的对象，由以下接口所定义(即java.util.Iterator) :

     ```java
     public interface Iterator<Item>{
     	boolean hasNext() ;
     	Item next();
     	void remove() ;
     }
     ```

     迭代器的类需要实现hasNext()和next()方法，它们实现在栈类的一个内部类中

     ```java
     private class ReverseArrayIterator implements Iterator<Item>{
             private int i=N;//i是计数器，记录集合中还剩下多少元素
             @Override
             public boolean hasNext() { return i>0;}//i大于0就说明集合中还有下一个元素
             @Override
             public Item next() { return a[--i]; }//栈从顶部往下遍历，即从数组的最后向前
         										//遍历，因为数组最后一个元素的位置等于
         										//数组的大小减一，所以先将i减1再访问
         }
     ```

下压栈完整实现（能够动态调整数组大小的实现）：

```java
import java.util.Iterator;
public class ResizingArrayStack<Item> implements Iterable<Item>{
    private Item[] a=(Item[])new Object[1];
    private int N=0;
    public boolean isEmpty(){return N==0;}
    public int size(){return N;}
    private void resize(int max){
        Item[]temp=(Item[])new Object[max];
        for(int i=0;i<N;i++)
            temp[i]=a[i];
        a=temp;
    }
    public void push(Item item){
        if(N==a.length)resize(2*a.length);
        a[N++]=item;
    }
    public Item pop(){
        Item item=a[--N];
        a[N]=null;
        if(N>0&&N==a.length/4)resize(a.length/2);
        return item;
    }
    public Iterator<Item> iterator(){
        return new ReverseArrayIterator();
    }
    private class ReverseArrayIterator implements Iterator<Item>{
        private int i=N;
        @Override
        public boolean hasNext() { return i>0;}
        @Override
        public Item next() { return a[--i]; }
    }
}
```

## 2、链表

ResizingArrayStack几乎（但还没有）达到了任意集合类数据类型的最佳性能。

- 每项操作的用时都与集合大小无关;
- 空间需求总是不超过集合大小乘以一个常数。

它的缺点在于某些push()和pop()操作会调整数组的大小:这项操作的耗时和栈大小成正比。 我们可以使用链表来组织数据，来避免这个问题。

### 链表的实现

- 节点记录：

  我们首先用一个嵌套类来定义结点的抽象数据类型:

  ```java
  private class Node{
  	Item item;
  	Node next;
  }
  ```

  我们通过new Node() 触发(无参数的)构造函数来创建一个Node类型的对象。调用的结果是一个指向Node对象的引用，它的实例变量均被初始化为null。Item 是一个占位符，表示我们希望用链表处理的任意数据类型(我们将会使用Java的泛型使之表示任意引用类型);Node类型的实例变量显示了这种数据结构的链式本质。

- 构造链表：

  我们只需要一个Node类型的变量就能表示一条链表， 只要保证它的值是null或者指向另一个Node对象且该对象的next域指向了另一条链表即可。例如，要构造一条含有元素to、be和or的链表，我们首先为每个元素创造一个结点:

  ```java
  Node first = new Node() ;
  Node second = new Node() ;
  Node third = new Node() ;
  ```

  并将每个结点的item域设为所需的值(简单起见，我们假设在这些例子中Item为String) :

  ```java
  first.item = "to";
  second.item = "be";
  third.item = "or";
  ```

  然后设置next域来构造链表:

  ```java
  first.next= second;
  second.next = third;
  ```

  (注意: third.next仍然是null， 即对象创建时它被初始化的值。)结果是，third 是一条链表(它是一个结点的引用，该结点指向null，即一个空链表)，second 也是一条链表(它是一个结点的引用，且该结点含有一个指向third的引用，而third是一条链表)，first也是一条链表(它是一个结点的引用，且该结点含有一个指向second 的引用，而second是一条链表)。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214133703901.png" alt="image-20210214133703901" style="zoom:67%;" />

- 在表头插入节点

  例如，要在首结点为first的给定链表开头插入字符串not, 我们先将first保存在oldfirst中,然后将一个新结点赋予first,并将它的item域设为not, next域设为oldfirst。 

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214134236771.png" alt="image-20210214134236771" style="zoom: 67%;" />

- 从表头删除节点：

  假设你希望删除一条链表的首结点，只需将first指向first.next即可。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214134621523.png" alt="image-20210214134621523" style="zoom:50%;" />

  一旦改变了first的值，就再也无法访问它曾经指向的结点了。曾经的结点对象变成了一个孤儿，Java 的内存管理系统最终将回收它所占用的内存。

- 在表尾插入节点：

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214135108058.png" alt="image-20210214135108058" style="zoom:67%;" />

- 其他位置的插入和删除操作：

  对于单向链表，很难实现

  - 删除指定的节点
  - 在指定节点前插入一个新节点

  例如，如果要删除链表的尾结点， last 链接帮不上忙，因为我们需要将链表尾结点的前一个结点中的链接(它指向的正是last)值改为null。我们无法通过last访问到它的前一个节点，唯一的解决办法，就是遍历整条链表并找出指向last的结点，这种方法所需的时间和链表的长度成正比。

  实现任意插入和删除的标准解决方案是使用 **双向链表**。

- 遍历：

  ```java
  for (Node x = first; x != nu11; x = x.next)
  {
  	//处理x.item
  }
  ```

- 迭代：

  嵌套类ListIterator维护了一个实例变量current来记录链表的下一个结点。hasNext() 方法会检测current是否为null, next()方法会返回current的引用，并将current移动到下一个节点。

  ```java
  @Override
      public Iterator<Item> iterator() {
          return new ListIterator();
      }
      private class ListIterator implements Iterator<Item>{
          private Node current=first;
          @Override
          public boolean hasNext() {
              return current!=null;
          }
          @Override
          public Item next() {
              Item item=current.item;
              current=current.next;
              return item;
          }
      }
  ```

  

### 用链表实现栈

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214153433231.png" alt="image-20210214153433231" style="zoom: 80%;" />

**由于使用的是单向链表，只能删除表头的元素，无法删除表尾的元素，所以栈的实现只能将表头作为栈顶**

```java
public class Stack<Item> implements Iterable<Item>{
    private class Node{
        Item item;
        Node next;
    }
    private Node first;//栈顶
    private int N;//元素数量
    public boolean isEmpty(){return N==0;}//或：first==null;
    public int size(){return N;}
    public void push(Item item){
        //向栈顶添加元素
        Node oldFirst=first;
        first=new Node();
        first.item=item;
        first.next=oldFirst;
        N++;
    }
    public Item pop(){
        //从栈顶删除元素
        Item item=first.item;
        first=first.next;
        N--;
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    private class ListIterator implements Iterator<Item>{
        private Node current=first;
        @Override
        public boolean hasNext() {
            return current!=null;
        }
        @Override
        public Item next() {
            Item item=current.item;
            current=current.next;
            return item;
        }
    }
}
```

### 用链表实现队列

基于链表数据结构实现Queue，它将队列表示为一条从最早插人的元素到最近插入的元素的链表，实例变量first指向队列的开头，实例变量last指向队列的结尾。这样，要将一个元素人列( enqueue() ),我们就将它添加到表尾(但是在链表为空时需要将first和last都指向新结点) ;要将一个元素出列( dequeue() )，我们就删除表头的结点(代码和Stack的pop()方法相同，只是当链表为空时需要更新last的值)。size()和isEmpty()方法的实现和Stack相同。和Stack一样，Queue 的实现也使用了泛型参数。

**由于使用的是单向链表，只能删除表头的元素，无法删除表尾的元素，所以队列的实现只能将表头作为队列的开头，将表尾作为队列的结尾**
在链表的尾部添加一个新结点：我们需要一个指向链表最后一个结点的链接，因为该结点的链接必须被修改并指向一个含有新元素的新结点。我们不能在链表代码中草率地决定维护一个额外的链接，例如，我们刚刚讨论过的删除链表首结点的代码就可能改变指向链表的尾结点的引用，因为当链表中只有一个结点时，它既是首结点又是尾结点。另外，这段代码也无法处理链表为空的情况(它会使用空链接)。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214153558961.png" alt="image-20210214153558961" style="zoom:80%;" />

```java
public class Queue<Item>implements Iterable<Item> {
    private class Node{
        Item item;
        Node next;
    }
    private Node first;//指向最早添加的节点的链接
    private Node last;//指向最近添加的节点的链接
    private int N;
    public boolean isEmpty(){return N==0;}
    public int size(){return N;}
    public void enqueue(Item item){
        //向表尾添加元素
        Node oldLast=last;//保存原来的最后一个节点的地址
        last=new Node();//实例化一个新节点，赋给last
        last.item=item;
        last.next=null;
        //如果队列为空，last=null，直接让first等于last
        if(isEmpty())first=last;
        //如果不为空，将原来的最后一个节点指向新的最后一个节点
        else oldLast.next=last;
        N++;
    }
    public Item dequeue(){
        Item item=first.item;
        first=first.next;
        if(isEmpty())last=null;
        N--;
        return item;
    }
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    private class ListIterator implements Iterator<Item>{
        private Node current=first;
        @Override
        public boolean hasNext() {
            return current!=null;
        }
        @Override
        public Item next() {
            Item item=current.item;
            current=current.next;
            return item;
        }
    }
}
```

我们用链表达到了最优设计目标:

- 它可以处理任意类型的数据
- 所需的空间总是和集合的大小成正比
- 操作所需的时间总是和集合的大小无关

![image-20210214164643656](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210214164643656.png)

int[ ] a=new int [N]表示N次数组访问，所有数组元素均会被初始化为0。

## 3、union-find

```java
public class UnionFind {
    private int[]rank;//rank[i]表示以i为根的集合所表示的树的层数
    private int[]parent;//parent[i]表示第i个元素所指向的父节点
    private int count;//连通分量的的数量

    //构造函数
    public UnionFind(int count){
        this.count=count;
        rank=new int[count];
        parent=new int[count];
        //初始化，每个节点的父节点是它本身，每个节点都只有一层
        for(int i=0;i<count;i++){
            parent[i]=i;
            rank[i]=1;
        }
    }
    //查找元素p的父节点
    private int find(int p){
        //路径压缩
        if(p!=parent[p])
            parent[p]=find(parent[p]);
        return parent[p];
    }
    //查看元素p和q是否是同一个集合
    public boolean connected(int p,int q){
        return find(p)==find(q);
    }
    //合并元素p和元素q所属的集合
    public void union(int p,int q){
        int pRoot=find(p);
        int qRoot=find(q);
        if(pRoot==qRoot)
            return;
        //当p的层数比q的层数低时，将p的父节点设为q，合并后的树高度不变
        if(rank[pRoot]<rank[qRoot])
            parent[pRoot]=qRoot;
        else if(rank[qRoot]<rank[pRoot])
            parent[qRoot]=pRoot;
        else {//当两个树的高度相同时，合并后的树高度加一
            parent[pRoot]=qRoot;
            rank[qRoot]+=1;//高度加一
        }
    }
}
```

# 第2章、排序

## 1、选择排序

在未排序的元素中找到最小的元素，插入到已排序的元素的最后。直到未排序的元素个数为0.

排序算法:首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

```java
public class selection {
    private static boolean less(Comparable v,Comparable w){
        return v.compareTo(w)<0;
    }
    private static void exch(Comparable[]a,int i,int j){
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    public static boolean isSorted(Comparable[]a){
        for(int i=1;i<a.length;i++){
            if(less(a[i],a[i-1]))return false;
        }
        return true;
    }
    public static void sort(Comparable[]a){
        for(int i=0;i<a.length;i++){//对数组中每一个数，在它后面寻找最小的数
            int min=i;// 设置当前的数为最小值
            for(int j=i;j<a.length;j++){//与自己后面的数一一比较，找到最小的数
                if(less(a[j],a[min]))min=j;
            }
            exch(a,i,min);//将当前的数和后面最小的数交换位置
        }
    }
}
```

![image-20210206133622462](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210206133622462.png)

对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换

特点：

- **运行时间和输入无关**。：为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。
  一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长!我们将会看到，其他算法会更善于利用输入的初始状态。
- **数据移动是最少的**。每次交换都会改变两个数组元素的值，因此选择排序用了N次交换。交换次数和数组的大小是线性关系。我们将研究的其他任何算法都不具备这个特征( 大部分的增长数
  量级都是线性对数或是平方级别)。

**堆排序是对选择排序的优化**

## 2、插入排序

通常人们整理桥牌的方法是一张一张的来,将每一张牌插人到其他已经有序的牌中的适当位置。
在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

从左到右，对数组中的每一个元素，它的左边都是有序的，将该元素插入到左边有序元素中的合适位置（通过反复交换和前一个元素的位置实现，而不是直接插入）。再对下一个元素进行同样的操作，直到最后一个元素插入完毕。

```java
public class insertion {
    public static void sort(Comparable[]a){
        for(int i=1;i<a.length;i++){//将数组中的每个数
            for(int j=i;j>0&&less(a[j],a[j-1]);j--){//和自己之前的数进行比较，直到遇到比自己大的数                                
                exch(a,j,j-1);//对每个比自己小的数都交换一次位置
            }
        }
    }
}
```

![image-20210206133701006](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210206133701006.png)

和选择排序不同的是，**插人排序所需的时间取决于输人中元素的初始顺序**。例如，对一个其中的元素已经有序( 或接近有序)的数组进行排序将会比对随机顺序的数组进行排序要快得多。对于基本有序的数组，每一个元素只需要和自己前一个元素比较一下就行了，线性时间复杂度。

对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要~ N^2/4次比较以及~ N^2/4次交换。最坏情况下需要~ N^2/2次比较和~ N^2/2次交换，最好情况下需要N-1次比较和0次交换。

## 3、插入排序与选择排序的比较：

![image-20210206133903698](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210206133903698.png)

**插人排序不会访问索引右侧的元素，而选择排序不会访问索引左侧的元素**。另外，在这种可视化的轨迹图中可以看到，因为插入排序不会移动比被插入的元素更小的元素，**它所需的比较次数平均只有选择排序的一半。**

对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比应该是一个较小的常数。

## 4、希尔排序

它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。

希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

以增量 **gap=length/2**为例，缩小增量以 **gap = gap/2** 的方式，用序列 **{n/2,(n/2)/2...1}** 来表示。

如图示例：

（1）初始增量第一趟 **gap = length/2 = 4**

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/ShellSort-01.png)

（2）第二趟，增量缩小为 2

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/ShellSort-02.png)

（3）第三趟，增量缩小为 1,得到最终排序结果

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/ShellSort-03.png)

```java
public class shell {
    public static void sort(Comparable[]a){
        int h=1;
        int N=a.length;
        while (h<N/3)h=3*h+1;//计算初始的增长序列
        for(int gap=h;gap>=1;gap/=3){//缩小增长序列，直到1为止
            for(int i=gap;i<N;i++){//对每一个增长序列分出的数组进行插入排序
                                   //没有对分出的数组逐组进行处理，这样在处理完
                                   //一个数组后还要回过头来处理下一个数组。
                                   //而是选择了跨组处理
                for(int j=i;j>=h&&less(a[j],a[j-h]);j-=h)
                    exch(a,j,j-h);
            }
        }
    }
}
```

在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组（这样还得加个for循环去处理分组）比如[5,4,3,2,1,0] ，首次增量设gap=length/2=3,则为3组[5,2] [4,1] [3,0]，实现时不用循环按组处理，我们可以从第gap个元素开始，逐个跨组处理。

希尔排序时间复杂度是 **O(n^(1.3-2))**，空间复杂度为常数阶 **O(1)**。希尔排序没有时间复杂度为 **O(n(logn))** 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 **O(n^2 )** 复杂度的算法快得多。

## 5、归并排序

根据selection sort，我们排序一个大小为n的数组需要n^2/2次操作。

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210315202611410.png" alt="image-20210315202611410" style="zoom:50%;" />

但是如果我们将数组对半分开，将左右两边分别排序，再将左右两个数组归并成一个数组，我们发现，这样只需要

n^2/4+n

我们可以继续划分下去

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210315202720269.png" alt="image-20210315202720269" style="zoom:50%;" />

直到分到只剩一个元素的数组，此时我们不需要排序，只需要将所有的数组自底向上归并就行了。

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210315203127765.png" alt="image-20210315203127765" style="zoom:50%;" />

归并成一个大小为N的数组操作N次，而每一层的数组大小的总和都是N，总共的操作次数是N乘以层数，而层数等于lgN，所以复杂度为O(NlgN)

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

**分而治之**

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1024555-20161218163120151-452283750.png)

**合并**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1024555-20161218194508761-468169540.png)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1024555-20161218194621308-588010220.png)

归并排序流程：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20220128144544387.png" alt="image-20220128144544387" style="zoom:50%;" />

```java
public class merge {
    public static Comparable[]aux;
    public static void merge(Comparable[]a,int lo,int mid,int hi){//将被sort方法分开的												两个数组依次挑选其中最小的元素放入原数组           
        //初始化，i指向左边数组的起始索引位置lo；j指向右边数组的起始索引位置mid+1
        int i=lo,j=mid+1;
        for(int k=lo;k<=hi;k++)
            aux[k]=a[k];//将原数组中的所有元素复制到aux中
        for(int k=lo;k<=hi;k++){//再将aux中的元素归并回原数组中，一个一个放置，循环hi+1次
            
            if(i>mid)a[k]=aux[j++];//如果左半部分元素已经全部处理完毕，此时左边数组的指针超过									  mid，将右边数组的所有元素直接放入原数组对应位置
            
            else if(j>hi)a[k]=aux[i++];//如果右半部分元素已经全部处理完毕，此时右边数组的指									     针超过hi，将左边数组的所有元素直接放入原数组对应位置
            
            else if(less(aux[j],aux[i]))a[k]=aux[j++];//如果右边数组所指的元素比左边数组												  所指的元素小，将右边所指的元素放回原数组
            
            else a[k]=aux[i++];//右边数组所指的元素比左边数组所指的元素大，将左边所指的元素放									 回原数组
        }
    }
    public static void sort(Comparable[]a){
        aux=new Comparable[a.length];//为归并所需的辅助数组分配空间
        sort(a,0,a.length-1);
    }
    public static void sort(Comparable[]a,int lo,int hi){//该方法的作用是将数组分开
        if(lo>=hi)return;//当数组被分到只剩下1个元素时返回
        int mid=lo+(hi-lo)/2;
        sort(a,lo,mid);
        sort(a,mid+1,hi);
        merge(a,lo,mid,hi);//分到只剩两个元素时开始归并
    }
}
```

![image-20210206223813835](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210206223813835.png)

对于长度为N的任意数组，自顶向下的归并排序需要<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210206224531413.png" alt="image-20210206224531413" style="zoom: 33%;" />次比较。

归并排序所需的时间和MgN成正比。它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的。

归并排序的主要缺点是辅助数组所使用的额外空间和N的大小成正比。

## 6、快速排序

快速排序是一种比较快速的排序算法，它的平均运行时间是 **O(nlogn)**，之所以特别快是由于非常精练和高度优化的内部循环，最坏的情形性能为 **O(n^2)**。像归并一样，快速排序也是一种分治的递归算法。从空间性能上看，快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归，空间复杂度也为**O(logn)。**

快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的:归并排序将数组分成两个子数组分别排序,并将有序的子数组归并以将整个数组排序;而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中 ,递归调用发生在处理整个数组之前;在第二种情况中,递归调用发生在处理整个数组之后。**在归并排序中，一个数组被等分为两半;在快速排序中，切分( partition )的位置取决于数组的内容**。

该方法的关键在于切分，这个过程使得数组满足下面三个条件:

- 对于某个j，a[j]已经排定;
- a[lo]到a[j-1]中的所有元素都不大于a[j];
- a[j+1]到a[hi]中的所有元素都不小于a[j]。

我们就是通过递归地调用切分来排序的。

要完成这个实现，需要实现切分方法。一般策略是先随意地取a[lo]作为切分元素,即那个将会被排定的元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此我们交换它们的位置。如此继续，我们就可以保证左指针的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧的元素(a[j] )交换然后返回j即可。

```java
public class quick {
    private static boolean less(Comparable v,Comparable w){
        return v.compareTo(w)<0;
    }
    private static void exch(Comparable[]a,int i,int j){
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    public static void sort(Comparable[]a){
        StdRandom.shuffle(a);//消除对输入的依赖
        sort(a,0,a.length-1);
    }
    public static void sort(Comparable[]a,int lo,int hi){
        if(hi<=lo)return;//当数组被切分到中只剩一个元素时返回
        int j=partition(a,lo,hi);//切割数组
        sort(a,lo,j-1);//对左边的数组进行切割
        sort(a,j+1,hi);//对右边的数组进行切割
    }
    public static int partition(Comparable[]a,int lo,int hi){
        Comparable v=a[lo];//基准数据
        int i=lo,j=hi+1;
        while (true){
            //左指针指向的数小于基准数就将左指针向右移动，当数组中除了基准数本身以外的所有数
            //都小于基准数时，左指针i==hi，跳出循环。
            while (less(a[++i],v))if(i==hi)break;
            //右指针指向的数大于等于基准数就将右指针向左移动，当数组中的所有数
            //都大于等于基准数时，右指针j==lo，跳出循环。
            while (less(v,a[--j]))if(j==lo)break;
            //当i和j相遇时，跳出外循环；由于j右边的数都大于等于基准数
            //而i左边的数都小于基准数，所以i和j不可能超越对方，最多只能相遇
            if (i>=j)break;
            //如果i和j没有相遇，交换i和j的位置
            exch(a,i,j);
        }
        //只有当i和j相遇时才会跳出循环，交换相遇的位置的值和基准数的值。
        exch(a,lo,j);
        return j;
    }
}
```

如果是对近乎有序的数组进行快速排序，每次 partition 分区后子数组大小极不平衡，容易退化成 **O(n^2)** 的时间复杂度算法。所以我们在快速排序前将数组随机排序，消除对输入的依赖。

快速排序最多需要约N^2/2次比较，但随机打乱数组能够预防这种情况。

总的来说，可以肯定的是对于大小为N的数组，快速排序的运行时间在1.39lgN的某个常数因子的范围之内。**归并排序也能做到这一点， 但是快速排序一般会更快**(尽管它的比较次数多39%)，因为它移动数据的次数更少。这些保证都来自于数学概率，你完全可以相信它。

堆排序是借助堆来实现的排序（将所有的元素插入堆中（实际操作是将输入的数组构造成堆），再不停地删除最大的元素），**而快速排序实际上是借助BST来实现的排序（将所有元素插入BST中，再进行中序遍历）**。

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210628141440452.png" alt="image-20210628141440452" style="zoom: 50%;" />

## 7、堆

**堆排序是对选择排序的优化**：选择排序每一次从剩下的未排序的数组中选择最小的数，插入到已排序数组的末尾。此算法慢的根本原因在于：没有借助之前选择最小的数的过程，每一次选择都要从头到尾重新找最小的数。因此我们可以维护一个堆来保存未排序的数组，每次可以以O(1)的时间复杂度获取最小的数，从而解决了选择排序的问题；



数据结构二叉堆能够很好地实现优先队列的基本操作。

堆通常是一个可以被看做一棵完全二叉树的数组对象。

堆满足下列性质：

- 堆中某个节点的值总是不大于或不小于其父节点的值。
- 堆总是一棵完全二叉树。

完全二叉树：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都**连续集中在最左边**。

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1468919-20191103194739538-2034251878.png)

当一颗二叉树的每个结点都大于等于它的两个子节点时，它被称作堆有序。

特别地：根结点是堆有序的二叉树中的最大结点。

堆是利用完全二叉树的结构来维护一组数据，然后进行相关操作，一般的操作进行一次的时间复杂度在 **O(1)~O(logn)** 之间，堆通常用于动态分配和释放程序所使用的对象。

若为优先队列的使用场景，普通数组或者顺序数组，最差情况为 **O(n^2)**，堆这种数据结构也可以提高入队和出队的效率。

|          | 入队    |  出队  |
| :------: | :------ | :----: |
| 普通数组 | O(1)    |  O(n)  |
| 顺序数组 | O(n)    |  O(1)  |
|    堆    | O(logn) | O(log) |

用数组(堆)实现的完全二叉树的结构是很严格的，但**它的灵活性已经足以让我们高效地实现优先队列**。用它们我们将能实现**对数级别**的插入元素和删除最大元素的操作。

### 结构特点：

二叉堆是一颗完全二叉树，且堆中某个节点的值总是不大于其父节点的值，该完全二叉树的深度为 k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边。

其中堆的根节点最大称为最大堆，如下图所示：

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/heap-01.png)

我们可以使用数组存储二叉堆，右边的标号是数组的索引。

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/heap-02.png)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/heap-03.png)

假设当前元素的索引位置为 i，可以得到规律：

```
parent(i) = i/2（取整）
left child(i) = 2*i
right child(i) = 2*i +1
```

### 堆的算法：

使用长度为N+1的私有数组pq[ ]来表示大小为N的堆，不使用pq[0]，堆元素放在pq[1]至pq[N]中。

**注意！二叉树放在数组中一定要从1开始表示！不要使用0！**

- 堆实现的比较和交换方法

  ```java
  private boolean less(int i,int j){
      return pq[i].compareTo(pq[j])<0;
  }
  private void exch(int i,int j){
      Key t=pq[i];
      pq[i]=pq[j];
      pq[j]=t;
  }
  ```

- **由下到上的堆的有序化（上浮）：**

  如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。交换后，这个结点比它的两个子结点都大(一个是曾经的父结点，另一个比它更小，因为它是曾经父结点的子结点)，但这个结点仍然可能比它现在的父结点更大。我们可以一遍遍地用同样的办法恢复秩序，将这个结点不断向上移动直到我们遇到了一个更大的父结点。

  ```java
  private void swim(int k){
  	while(k>1&&less(k/2,k)){//当成为根节点时（k=1），或遇到了一个大于自己的父节点时，停止上浮
  		exch(k/2,k);//当父节点小于自己时，交换自己当前位置的值和父节点位置上的值
  		k=k/2;//将k指向父节点的位置，完成一次上浮
  	}
  }
  ```

- **由上到下的堆的有序化（下沉）：**

  如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式将其修复，将结点向下移动直到它的子结点都比它更小或是到达了堆的底部。由位置为k的结点的子结点位于2k和2k+1可以直接得到对应的代码。当一个结点太小的时候它需要沉( sink )到堆的更低层。

  ```java
  private void sink(int k){
      
      //如果有左节点（2*k<=N)，就有可能继续下沉
      //如果没有左节点，就代表现在已经下沉到了堆底，无法继续下沉
  	while(2*k<=N){
          
          //j执行左节点
  		int j=2*k;
          
          //如果有右节点（j+1<=N），就对左右节点的值进行比较，选出较大的值
          //此时如果左节点小于右节点（less(j,j+1)），就选出右节点（j++，j指向右节点）
          //如果左节点不小于右节点，就选出左节点（j的值不变，依然指向左节点）
          if(j+1<=N&&less(j,j+1))j++;
          
          //如果没有右节点，就直接拿左节点来和自己比较（j=2*k，没有执行上面的if，j指向左节点）
          //如果有右节点，选出较大的值来和自己比较（执行了上面的if，j指向较大的节点）
          if(!less(k,j))break;//当自己大于j所指向的数时，无法下沉，直接跳出循环
          
          exch(k,j);//当自己小于j所指向的数时，交换k和j所指向位置的值
          k=j;//将指针k指向j的位置，完成下沉
  	}
  }
  ```

### 基于堆的优先队列：

**许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序**。很多情况下我们会收集一些元素， 处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。
在这种情况下，一个合适的数据结构应该支持两种操作:删除最大元素和插入元素。这种数据类型叫做**优先队列**。

**优先队列适用于需要频繁取出最大的元素，但是又不需要将整个数组排序的情况。**

优先队列基于**二叉堆**数据结构，而二叉堆通过**用数组保存元素并按照一定条件排序和访问实现**。

- **插入元素**：

  我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置

  ```java
  public void insert(Key v){
  	pq[++N]=v;//先增加堆的大小，将新元素加到数组末尾
      swim(N);//让新元素上浮到合适的位置
  }
  ```

- **删除最大元素**：

  我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置

  ```java
  public Key delMax(){
      Key max=pq[1];//从根节点得到最大的元素
      exch(1,N);//将最大的元素和最后一个节点交换
      pq[N]=null;//将最后一个节点置空
      N--;//收缩堆的大小
      sink(1);//让新的根节点下沉，恢复堆的有序性
      return max;
  }
  ```

![image-20210210112016057](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210210112016057.png)

基于堆的优先队列完整算法实现：

```java
public class MaxPQ<Key extends Comparable<Key>>{
    private Key[] pq;//基于数组的二叉堆结构
    private int N=0;//数组大小

    public MaxPQ(int maxN){
        pq=(Key[])new Comparable[maxN+1];
    }
    public boolean isEmpty(){return N==0;}

    public int size(){return N;}

    private boolean less(int i,int j){
        return pq[i].compareTo(pq[j])<0;
    }

    private void exch(int i,int j){
        Key t=pq[i];
        pq[i]=pq[j];
        pq[j]=t;
    }

    private void swim(int k){
        while (k>1&&less(k/2,k)){
            exch(k/2,k);
            k=k/2;
        }
    }
    private void sink(int k){
        while (k*2<=N){
            int j=2*k;
            if(j+1<=N&&less(j,j+1))j++;
            if(less(j,k))break;
            exch(k,j);
            k=j;
        }
    }
    public void insert(Key v){
        pq[++N]=v;
        swim(N);
    }
    public Key delMax(){
        Key max=pq[1];
        exch(1,N);
        pq[N]=null;
        N--;
        sink(1);
        return max;
    }
}
```

对于一个含有N个元素的基于堆的优先队列,插入元素操作只需不超过( lgN+1 )次比较，删除最大元素的操作需要不超过2lgN次比较。

使用有序或是无序数组的优先队列的初级实现总是需要**线性时间**来完成其中一种操作，但基于堆的实现则能够保证在**对数时间**内完成它们。

### 堆排序：

借助堆可以实现空间复杂度为O(1)的原地**从小到大**排序：

- 构造**最大堆**：对输入数组从右至左用sink()函数构造子堆，开始时我们只需要扫描数组中的一半元素， 因为我们可以跳过大小为1的子堆。最后我们在位置1上调用sink()方法，扫描结束。
- 删除堆中最大的元素，即数组的根节点，将该元素添加到堆的末尾：将根节点和堆的最后一个元素交换位置，将新的根节点sink到合适的位置，将堆的大小减一。如此反复，直到堆的大小为0，原数组就已经排序完成了。



我们可以把任意优先队列变成一种排序方法。**将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按顺序删去**。用基于堆的优先队列这样做等同于一种全新的排序方法：堆排序。

堆排序可以分为两个阶段。在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中; 然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。我们将**使用一个面向最大元素的优先队列并重复删除最大元素**。为了排序的需要，我们不再将优先队列的具体表示隐藏，并将直接使用swim()和sink()操作。这样**我们在排序时就可以将需要排序的数组本身作为堆，因此无需任何额外空间**。

#### 堆的构造：

从右至左用sink()函数构造子堆。数组的每个位置都已经是一个子堆的根结点了，sink() 对于这些子堆也适用。**如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink()可以将它们变成一个堆**。这个过程会递归地建立起堆的秩序。**开始时我们只需要扫描数组中的一半元素， 因为我们可以跳过大小为1的子堆。最后我们在位置1上调用sink()方法，扫描结束**。

#### 堆排序的实现：

```java
public class heap {
    private static void exch(Comparable[]a,int i,int j){
        Comparable temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
    private static boolean less(Comparable v,Comparable w){
        return v.compareTo(w)<0;
    }
    private static void sink(Comparable[]a, int k,int N){
        while (k*2<=N){
            int j=2*k;
            if(j+1<=N&&less(a[j],a[j+1]))j++;
            if(less(a[j],a[k]))break;
            exch(a,k,j);
            k=j;
        }
    }
    public static void sort(Comparable[]a){
        int N=a.length;
        //将输入的数组构造成二叉堆结构，跳过大小为1的堆，从N/2的位置开始（此处就是倒数第二层）
        //对每一个节点使用sink(),一直到根节点(k>=1)
        for(int k=N/2;k>=1;k--){
            sink(a,k,N);
        }
        while (N>1){
            exch(a,1,N);//将根节点和堆的最后一个节点交换位置
            N--;//缩小堆的大小
            sink(a,1,N);//将新的根节点下沉，恢复堆的有序性。
        }
    }
}
```

for循环构造了堆，从有最低的有子叶的节点开始，一直到根节点，挨个使用sink。

然后while循环对数组进行了排序,将堆顶的最大的元素（数组最大的元素）和堆的最后一个元素交换位置（也就是数组的最后一个元素），然后减小堆的大小，对新的堆顶进行下沉，恢复堆的有序性。下一次就是将堆顶的最大的元素（数组第二大的元素）和堆的最后一个元素交换位置（数组的倒数第二个元素）。如此反复。最后堆的大小变为1的时候，数组就从小到大排序好了。整个过程中，堆是在原数组中构造的，从堆中反复删除最大的元素进行排序也是在原数组中进行的，没有任何额外的空间。



将N个元素排序，堆排序只需少于( 2NlgN+2N)次比较(以及一半次数的交换)。

**堆排序在排序复杂性的研究中有着重要的地位**，因为它是唯一可以同时最优利用时间和空间的方法。

另一方面， 用堆实现的优先队列在现代应用程序中越来越重要，因为它能在插入操作和删除最大元素操作混合的动态场景中保证对数级别的运行时间。

## 8、应用

将各种数据排序：

- 我们的实现的排序对象是由实现了Comparable接口的对象组成的数组。Java的约定使得我们能够利用Java的回调机制将任意实现了Comparable接口的数据类型排序。如2.1节所述，实现Comparable接口只需要定义一个compareTo()函数并在其中定义该数据类型中的大小关系。我们的代码直接能够将String、Integer、 Double 和一些其他例如File和URL类型的数组排序，因为它们都实现了Comparable接口。相应，在自定义的数据类型中实现一个compareTo()方法也是很常见的，这样就实现了Comparable接口，**也就使得这种数据类型可以被排序了**(也可以用其构造优先队列)。

指针排序：

- 我们使用的方法在经典教材中被称为指针排序,**因为我们只处理元素的引用而不移动数据本身**。在其他编程语言例如C和C++之中，程序员需要明确地指出操作的是数据还是指向数据的指针，**而在Java中，指针操作是隐式的。除了原始数字类型之外，我们操作的总是数据的引用(指针)**,而非数据本身。指针排序增加了一层间接性，因为数组保存的是待排序的对象的引用,而非对象本身。

多种排序方法：

- 在很多应用中我们都希望根据情况**将一组对象按照不同的方式排序**。**Java 的Comparator接口允许我们在一个类之中实现多种排序方法**。它只有一个compare()方法来比较两个对象。如果一种数据类型实现了这个接口，我们可以像2.5.1.6节中的例子那样将另一个实现了Comparator接口的对象传递给sort()方法( sort() 再将其传递给less()) 。**Comparator接口允许我们为任意数据类型定义任意多种排序方法。**用Comparator接口来代替Comparable接口能够更好地将数据类型的定义和两个该类型的对象应该如何比较的定义区分开来。事实上，比较两个对象的确可以有多种标准，Comparator接口使得我们能够在其中进行选择。

  在应用程序中，一个元素的多种属性都可能被用作排序的键。在交易的例子中，有时可能需要将交易按照客户排序(例如，找出每个客户进行的所有交易) ;有时又可能需要按照金额排序(例如，需要找出交易金额较高的交易) ;有时还可能用另一个属性来排序。要实现这种灵活性，Comparator 接口正合适。我们可以定义多种比较器。

  ![image-20210210182053800](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210210182053800.png)



- **我们应该使用哪种排序算法**

  ![image-20210210182621264](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210210182621264.png)

  - **快速排序是最快的通用排序算法**，在大多数实际情况中，快速排序是最佳选择。例外：如果稳定性很重要而空间又不是问题，归并排序可能是最好的。

  - 对于只有少数元素无序的数组，使用插入排序是最好的（接近线性时间复杂度）。

    例：当有10000个元素的数组输入，我们可以使用快速排序、归并排序、堆排序。随后如果在已排序的数组中随机修改几个元素，此时要让数组重新有序，最好的方法是使用插入排序。

  - 对于元素数量较少的数组（小于15），使用插入排序比归并排序和快速排序更好，因为它们花费了太多时间在切分和合并上。



java系统库的排序算法：

- 这里我们考虑Java系统库中的主要排序方法`java.util.Arrays.sort()`。根据不同的参数类型，它实际上代表了一系列排序方法:

  - 每种原始数据类型都有一个不同的排序方法;
  - 一个适用于所有实现了Comparable接口的数据类型的排序方法;
  - 一个适用于实现了比较器Comparator的数据类型的排序方法。

  Java的系统程序员选择对原始数据类型使用(三向切分的)快速排序，对引用类型使用归并排序。这些选择实际上也暗示着用速度和空间(对于原始数据类型)来换取稳定性(对于引用类型)，



# 第3章、查找

我们会使用**符号表**这个词来描述一张抽象的表格， 我们会将信息(值)存储在其中，然后按照指定的键来搜索并获取这些信息。键和值的具体意义取决于不同的应用。

符号表有时被称为**字典**，类似于那本将单词的释义按照字母顺序排列起来的历史悠久的参考书。在英语字典里，键就是单词，值就是单词对应的定义、发音和词源。

符号表有时又叫做**索引**，即书本最后将术语按照字母顺序列出以方便查找的那部分。在一本书的索引中，键就是术语，而值就是书中该术语出现的所有页码。

## 1、符号表

符号表最主要的目的就是将一个键和一个值联系起来。用例能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值。

符号表是一种存储键值对的数据结构，支持两种操作:插入(put)，即将一组新的键值对存入表中;查找(get)，即根据给定的键得到相应的值。

![image-20210215103623284](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210215103623284.png)

### API

- 重复的键

  我们的所有实现都遵循以下规则: 

  - 每个键只对应着一个值(表中不允许存在重复的键) ;
  - 当用例代码向表中存人的键值对和表中已有的键(及关联的值)冲突时,新的值会替代旧的值。

  在一个关联数组(符号表)中，键可以是任意类型，我们可以用它来快速访问数组的内容。一些编程语言(非Java)直接支持程序员使用`st[key]`来代替`st.get(key)`, `st[key]=val` 来代替`st.put(key, va1)`,其中key ( 键)和va1 (值)都可以是任意类型的对象。

- 空（null）键

  键不能为空，使用空键会产生一个运行时异常。

-  空(null)值

  我们还规定不允许有空值。这个规定的直接原因是在我们的API定义中，**当键不存在时get()方法会返回空**，这也意味着任何不在表中的键关联的值都是空。这个规定产生了两个结果:

  - 我们可以用get()方法是否返回空来测试给定的键是否存在于符号表中;
  - 我们可以将空值作为put()方法的第二个参数存人表中来实现删除。

- 删除操作

  在符号表中，删除的实现可以有两种方法：

  - 延时删除，将键对应的值置为空，然后在某个时候删去所有值为空的键;
  - 即时删除，立刻从表中删除指定的键。

  put(key，null) 是delete(key)的一种简单的(延时型)实现。而实现(即时型) delete()就是为了替代这种默认的方案。在我们的符号表实现中不会使用默认的方案。

### 有序符号表

- 向下取整和向上取整

  对于给定的键,向下取整( floor )操作(找出小于等于该键的最大键)和向上取整( ceiling )操作(找
  出大于等于该键的最小键)。

### 无序链表中的顺序查找

符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。

- get()的实现即为遍历链表，用equals()方法比较需被查找的键和每个结点中的键。如果匹配成功我们就返回相应的值，否则我们返回null。

- put() 的实现也是遍历链表,用equals()方法比较需被查找的键和每个结点中的键。
  - 如果匹配成功我们就用第二个参数指定的值更新和该键相关联的值
  - 否则我们就用给定的键值对创建一个新的结点并将其插入到链表的开头。

```java
public class SequentialSearchST<Key,Value> {
    private Node first;//链表首节点
    private class Node{//链表节点的定义
        Key key;
        Value val;
        Node next;
        public Node(Key key, Value val, Node next) {
            this.key = key;
            this.val = val;
            this.next = next;
        }
    }
    public Value get(Key key){//查找给定的键，返回相关联的值
        for (Node x=first;x!=null;x=x.next){
            if (key.equals(x.key))
                return x.val;//命中
        }
        return null;
    }
    public void put(Key key,Value val){
        //查找给定的键，找到则更新它的值，否则在表中创建新节点
        for (Node x=first;x!=null;x=x.next){
            if (key.equals(x.key)){
                x.val=val;//如果表中已经存在该键，则更新其值
                return;
            }
        }
        //如果不存在该键，就在链表的头部插入新节点
        first=new Node(key,val,first);
    }
}
```

这种方法也被称为顺序查找:在查找中我们一个一个地顺序遍历符号表中的所有键并使用equals()方法来寻找与被查找的键匹配的键。

在含有N对键值的基于(无序)链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2/2次比较。

基于链表的实现以及顺序查找是非常低效的。

### 有序数组中的二分查找

它使用的数据结构是一对平行的数组，一个储存键，一个储存值。

这份实现的核心是rank()方法，使用二分查找，返回表中小于给定键的键的数量。

- 对于get(方法，只要给定的键存在于表中，rank()方法就能够精确地告诉我们在哪里能够找到它(如果找不到，那它肯定就不在表中了)。
- 对于put()方法，只要给定的键存在于表中，rank() 方法就能够精确地告诉我们到哪里去更新它的值，以及当键不在表中时将键存储到表的何处。

我们将所有更大的键向后移动一格来腾出位置(从后向前移动)并将给定的键值对分别插入到各自数组中的合适位置。

尽管能够保证查找所需的时间是对数级别的，BinarySearchST仍然无法支持我们处理大型问题，因为put()
方法还是太慢了。二分查找减少了比较的次数但无法减少运行所需时间，向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问~N^2次数组。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210215203337632.png" alt="image-20210215203337632" style="zoom:50%;" />

### 总结

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210215203630320.png" alt="image-20210215203630320" style="zoom:67%;" />

有序数组的二分查找优化了查找的速度，但是却减慢了插入的速度。

要支持高效的插人操作，我们需要一种链式结构。 但单链接的链表是无法使用二分查找法的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素(但得到一条链表的中间元素的唯一方法只能是沿链表遍历)。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构。能够同时拥有两者的就是**二叉查找树**。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210215204018472.png" alt="image-20210215204018472" style="zoom:67%;" />

![image-20210215204514488](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210215204514488.png)

## 2、二叉查找树

使用每个结点含有两个链接( 链表中每个结点只含有一个链接)的二叉查找树，是能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。

一棵二叉查找树(BST)是一棵二叉树，其中每个结点都含有一个Comparable的键(以及相关联的值)且**每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键**。

### 基本实现：

- 数据表示：

  我们嵌套定义了一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。变量N给出了以该结点为根的子树的结点总数。size()会将空链接的值当作0，这样我们就能保证以下公式对于二叉树中的任意结点x总是成立。
  `size(x) = size(x.1eft) + size(x.right) + 1`

  一棵二叉查找树代表了一组键(及其相应的值)的集合，而同一个集合可以用多棵不同的二叉查找树表示。如果我们将一棵二叉查找树的所有键投影到一条直线上，保证一个结点的左子树中的键出现在它的左边，右子树中的键出现在它的右边,那么我们一定可以得到一条有序的键列。我们会利用二叉查找树的这种天生的灵活性，用多棵二叉查找树表示同一组有序的键来实现构建和使用二叉查找树的高效算法。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210215221633012.png" alt="image-20210215221633012" style="zoom: 67%;" />

- 查找：

  这段代码用二叉查找树实现了有序符号表的API，树由Node对象组成，每个对象都含有一对键值、
  两条链接和一个结点计数器N。每个Node对象都是一棵含有N个结点的子树的根结点，它的左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找
  树。root变量指向二叉查找树的根结点Node对象(这棵树包含了符号表中的所有键值对)。

  ```java
  public class BST<Key extends Comparable<Key>,Value> {
      private Node root;
      private class Node{
          private Key key;//键
          private Value val;//值
          private Node left,right;//指向子树的链接
          private int N;//以该节点为根的子树中的节点总数
          public Node(Key key,Value val,int N){
              this.key=key;this.val=val;this.N=N;
          }
      }
      //公共的方法，供BST的用户使用，返回整个二分搜索树的大小
      public int size(){
          return size(root);
      }
      //私有的方法，供编写BST的程序员使用，返回二分搜索树中某个节点的子树的大小。
      private int size(Node x){
          if(x==null)return 0;
          else return x.N;
      }
      public Value get(Key key){
          return get(root,key);
      }
      //私有的方法，供公共的get方法使用，利用了递归
      private Value get(Node x,Key key){
          //在以x为根节点的子树中查找并返回key所对应的值
          //如果找不到则返回null
          if (x==null)return null;
          int cmp=key.compareTo(x.key);
          if (cmp<0)return get(x.left,key);//如果key小于当前的节点，就在左子树中寻找
          else if(cmp>0)return get(x.right,key);//如果key大于当前的节点，就在右子树中寻找
          else return x.val;//如果找到了（key等于当前节点），则返回当前节点的值
      }
      public void put(Key key,Value val){
          //查找key，找到则更新它的值，否则为它创建一个新的节点
          //从根节点root开始查找，查找完后再从底层一层一层的返回到root
          //在下面的put()方法中递归地更新搜索路上每个父节点指向子节点的链接
          //最后回到这里更新根节点root的链接
          root=put(root,key,val);
      }
      private Node put(Node x,Key key,Value val){
          //如果key不存在（找到空链接），则创建一个以key和val为键值对，节点数量为1的节点，插入到该子树中
          if(x==null)return new Node(key,val,1);
          int cmp=key.compareTo(x.key);
          if(cmp<0)x.left=put(x.left,key,val);
          else if(cmp>0)x.right=put(x.right,key,val);
          else x.val=val;//如果这个键已经存在，则更新该键的值
  
          //更新节点子树的大小（使用这个公式而不是简单对N++的原因是：
          //只有当键不存在时，树的大小才会加1，当键存在时，树的大小不变
          //而使用该公式，则可以将树的大小格式化，同时概括了以上两种情况）
          x.N=size(x.left)+size(x.right)+1;
          //返回当前的节点，重置搜索路上每个父节点指向子节点的链接
          return x;
      }
  }
  ```

  可以将递归调用前的代码想象成沿着树向下走:它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。

  可以将递归调用后的代码想象成沿着树向上爬：

  - 对于get()方法，这对应着一系列的返回指令( return)
  - 对于put()方法，这意味着重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值。

- 分析：

  命题C：在由N个随机键构造的二叉查找树中，**查找命中**平均所需的比较次数为~ 2lnN(约1.39lgN)。

  命题D：在由N个随机键构造的二叉查找树中**插入操作**和**查找未命中**平均所需的比较次数为~ 2lnN (约1.39IgN)。

  命题C说明在二叉查找树中查找随机键的成本比二分查找高约39%。命题D说明这些额外的成本是值得的，因为插人一个新键的成本是**对数级别**的，这是基于二分查找的有序数组所不具备的灵活性，因为它的插人操作所需访问数组的次数是**线性级别**的。

- 最大键和最小键：

  如果根结点的左链接为空，那么一棵二叉查找树中最小的键就是根结点；如果左链接非空，那么树中的最小键就是左子树中的最小键。

  ```java
  public Key min(){
          return min(root).key;//从根节点开始寻找
      }
      private Node min(Node x){
          //如果没有左子树，则当前的根节点就是最小的键
          if(x.left==null)return x;
          return min(x.left);//如果有左子树，就在左子树中寻找最小值
      }
      public Key max(){
          return max(root).key;
      }
      private Node max(Node x){
          if(x.right==null)return x;
          return max(x.right);
      }
  ```

- 向上取整和向下取整

  - 如果给定的键key小于二叉查找树的根结点的键，在根结点的左子树中寻找小于等于key的最大键( floor）
  - 如果给定的键key等于二叉查找树的根结点，**根节点就是查找结果**。

  - 如果给定的键key大于二叉查找树的根结点，在根节点的右子树中寻找
    - 当根结点右子树中存在小于等于key的结点时，该节点就是查找结果
    - 当根结点右子树中不存在小于等于key的结点时，查找结果为null，返回到离自己最近的**右节点的父节点就是小于等于key的最大键**。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210216221636783.png" alt="image-20210216221636783" style="zoom: 67%;" />

  本质上就是：

  - 如果搜索中遇到了与键值相等的节点，就返回该节点
  - 如果没有遇到，就一直向下搜索，直到遇到空节点（null），开始沿着树向上返回
    - 返回到离空节点最近的的右节点的父节点，该节点就是小于等于key的最大键，返回该节点
    - 如果搜索途中没有任何右节点，这棵树中就没有小于等于key的最大键，返回null

  ```java
  public Key floor(Key key){
          Node x=floor(root,key);
          if (x==null)return null;//如果查找的结果为null，就返回null
          return x.key;//如果查找的结果不为null，就返回查找到的键值
      }
      private Node floor(Node x,Key key){
          if(x==null)return null;
          int cmp=key.compareTo(x.key);
          //如果给定的键key小于二叉查找树的根结点的键，在根结点的左子树中寻找小于等于key的最大键
          if (cmp<0)return floor(x.left,key);
          //如果给定的键key等于二叉查找树的根结点，当前的根节点就是查找结果，直接返回
          if(cmp==0)return x;
          //如果给定的键key大于二叉查找树的根结点，在根节点的右子树中寻找
          Node t=floor(x.right,key);
          //在右子树中寻找完后返回到当前函数，t记录了寻找结果。
          //当右子树中不存在小于等于key的结点时，查找结果为null，当前的根节点就是查找结果
          if (t==null)return x;
          //当右子树中存在小于等于key的结点时，t的值为该节点，返回t。
          return t;
      }
      public Key ceil(Key key){
          Node t=ceil(root,key);
          if (t==null)return null;
          return t.key;
      }
      private Node ceil(Node x,Key key){
          if (x==null)return null;
          int cmp=key.compareTo(x.key);
          if(cmp>0)return ceil(x.right,key);
          if(cmp==0)return x;
          Node t=ceil(x.left,key);
          if (t==null)return x;
          return t;
      }
  ```

  在跟着返回（return）语句的条件语句（if）后不需要使用else if，因为执行完当前的条件语句后，当前的函数直接结束了，没有机会执行后面的语句。

- 选择：

  假设我们想找到排名为k的键(即树中正好有k个小于它的键)。

  - 如果左子树中的结点数t大于k,那么我们就继续(递归地)在左子树中查找排名为k的键;
  - 如果t等于k,**我们就返回根结点中的键**;
  - 如果t小于k，我们就(递归地)在右子树中查找排名为(k-t-1)的键。

  这段描述既说明了select()方法的递归实现同时也证明了它的正确性。

  ```java
  public Key select(int k){
          return select(root,k).key;
      }
      private Node select(Node x,int k){
          if (x==null)return null;
          //利用size()求出某一节点子树的节点数量大小
          int t=size(x.left);
          //如果左子树中的结点数t大于k,那么我们就继续(递归地)在左子树中查找排名为k的键;
          if(t>k)return select(x.left,k);
          //如果t等于k,我们就返回根结点中的键;
          if (t==k)return x;
          //如果t小于k，我们就(递归地)在右子树中查找排名为(k-t-1)的键。
          return select(x.right,k-t-1);
      }
  ```

- 排名：

  rank()是select()的逆方法，它会返回给定键的排名。它的实现和select()类似:

  - 如果给定的键和根结点的键相等，我们返回左子树中的结点总数t;
  - 如果给定的键小于根结点，我们会返回该键在左子树中的排名( 递归计算) ;
  - 如果给定的键大于根结点，我们会返回t+1 (根结点)加上它在右子树中的排名(递归计算)。

  ```java
  public int rank(Key key){
          return rank(root,key);
      }
      private int rank(Node x,Key key){
          if (x==null)return 0;
          int cmp=key.compareTo(x.key);
          if (cmp<0)return rank(x.left,key);
          if (cmp==0)return size(x.left);
          return 1+size(x.left)+rank(x.right,key);
      }
  ```

- 删除：

  - 删除最大键和删除最小键：

    对于deleteMin()，我们要不断深入根结点的左子树中直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树(只需要在递归调用中返回它的右链接即可)。此时已经没有任何链接指向要被删除的结点，因此它会被垃圾收集器清理掉。

    ```java
    public void deleteMin(){
            root=deleteMin(root);
        }
        private Node deleteMin(Node x){
            //遇见一个空链接，然后将指向该结点的链接指向该结点的右子树(只需要在递归调用中返回它的右链接即可)
            if (x.left==null)return x.right;
            x.left=deleteMin(x.left);
            //调整子树节点数量的大小
            x.N=size(x.left)+size(x.right)+1;
            return x;
        }
    ```

  - 删除任意键：

    我们可以用类似的方式删除任意只有一个子结点(或者没有子结点)的结点，但无法删除一个拥有两个子结点的结点，因为删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。
    

解决方法：**在删除节点x后用它的右子树中的最小节点填补它的位置**
    
- 首先搜索要删除的节点所在位置
  
- 将指向即将被删除的结点的链接保存为t
    - 将x指向它的右子树中的最小节点min(t.right) 
    - 将x从树中删除，然后将x的父节点指向x的右节点（deleteMin(t.right)），此时在树中已没有任何链接指向x（指向的节点）
    - 将x的右链接指向原来的右子树t.right（deleteMin(t.right)的返回值）
    - 将x的左链接(本为空)设为t.left
    

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217143707903.png" alt="image-20210217143707903" style="zoom: 80%;" />
    

```java
        public void delete(Key key){
            root=delete(root,key);
        }
        private Node delete(Node x,Key key){
            //首先寻找要删除的键值所在的位置
    
            //如果没有找到键值，就返回null
            if (x==null)return null;
            int cmp=key.compareTo(x.key);
            //x.left指向传回来的节点，返回途中更新经过的节点链接
            if (cmp<0)x.left=delete(x.left,key);
            else if (cmp>0)x.right=delete(x.right,key);
            else {
                //如果被删除的节点只有一个子节点或没有子节点，直接返回它的另一个子节点就行了
                //返回之后，它的父节点的指向就变成了被返回的子节点，它就断开了与树的链接
                if (x.right==null)return x.left;
                if (x.left==null)return x.right;
                //如果被删除的节点有两个节点，就进行以下操作
                Node t=x;
                x.right=deleteMin(t.right);
                x.left=t.left;
            }
            x.N=size(x.left)+size(x.right)+1;
            return x;
        }
```

- 中序遍历：

  ```java
  private void print(Node x){
          if (x==null)return;
          print(x.left);
          System.out.println(x.key);
          print(x.right);
      }
  ```

- 范围查找：

  将所有落在给定范围以内的键加人一个队列Queue并跳过那些不可能含有所查找键的子树。Keys()方法返回一个`Iterable<Key>`类型的对象，用例不需要知道我们使用Queue来收集符合条件的键，我们使用什么数据结构来实现`Iterable<Key>`并不重要，用例只要能够使用Java的foreach语句遍历返回的所有键就可以了。

  为了确保以给定结点为根的子树中所有在指定范围之内的键加入队列，我们会(递归地)查找根结点的左子树，然后查找根结点，然后(递归地)查找根结点的右子树。

  ```java
  	//公共接口，供用户使用，查找整个二叉树的所有键值，返回一个可迭代的集合
      public Iterable<Key> Keys(){
          return Keys(min(),max());
      }
      //公共接口，供用户使用，查找指定范围的键值
      public Iterable<Key> Keys(Key lo,Key hi){
          Queue<Key> queue=new Queue<>();
          Keys(root,queue,lo,hi);
          return queue;
      }
      private void Keys(Node x,Queue<Key>queue,Key lo,Key hi){
          if (x==null)return;
          int cmplo=lo.compareTo(x.key);
          int cmphi=hi.compareTo(x.key);
          if (cmplo<0)Keys(x.left,queue,lo,hi);
          if (cmplo<=0&&cmphi>=0)queue.enqueue(x.key);
          if (cmphi>0)Keys(x.right,queue,lo,hi);
      }
  ```

### 性能分析：

在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。

随机键构造的二叉查找树的平均高度为树中结点数的对数级别，对于足够大的N，这个值趋近于2.99lgN。

如果构造树的键不是随机的可以使用**平衡二叉查找树**，它能保证无论键的插人顺序如何，树的高度都将是总键数的对数。

![image-20210217182001655](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217182001655.png)

## 3、平衡查找树

平衡查找树是一种二分查找树，可以保证无论如何构造它，它的运行时间都是对数级别的。理想情况下我们希望能够保持二分查找树的平衡性。在一棵含有N个结点的树中，我们希望树高为~lgN,这样我们就能保证所有查找都能在~lgN次比较内结束,就和二分查找一样。

### 2-3查找树

我们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链接)，而现在我们引入3-结点，它含有两个键和三条链接。

一棵2-3查找树或为一棵空树，或由以下结点组成:

- 2-结点，含有一个键(及其对应的值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
- 3-结点，含有两个键(及其对应的值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217202655972.png" alt="image-20210217202655972" style="zoom:67%;" />

一棵**完美平衡**的2-3查找树中的所有空链接到根结点的距离都应该是相同的。简洁起见，这里我们用2-3树指代一棵**完美平衡**的2-3查找树(在其他情况下这个词应该表示一种更一般的结构)。

- 查找：

  要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中;否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。

  ![image-20210217225857106](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217225857106.png)

- 向2-结点中插入新键：

  把这个2-结点替换为一个3-结点，将要插人的键保存在其中即可，这样树可以保持完美平衡性。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217230219689.png" alt="image-20210217230219689" style="zoom: 50%;" />

- 向一棵只含有一个3-结点的树中插入新键：

  这棵树中有两个键，所以在它唯一的结点中已经没有可插人新键的空间了。

  - 为了将新键插人，我们先临时将新键存入该结点中，使之成为一个4-结点。
  - 它很自然地扩展了以前的结点并含有3个键和4条链接。
  - 然后将它转换为一棵由3个2-结点组成的2-3树,其中一个结点(根)含有中键，一个结点含有3个键中的最小者(和根结点的左链接相连)，一个结点含有3个键中的最大者(和根结点的右链接相连)。

  这棵树既是一棵含有3个结点的二叉查找树,同时也是一棵完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等。插入前树的高度为0，插入后树的高度为1。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217230759576.png" alt="image-20210217230759576" style="zoom:50%;" />

- 向一个父结点为2-结点的3-结点中插入新键：

  - 先创建一个临时的4-节点并将其分解
  - 将中键移动到原来的父节点中

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217231014768.png" alt="image-20210217231014768" style="zoom: 67%;" />

  这次转换也并不影响(完美平衡的) 2-3树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了;树仍然是完美平衡的,插人后所有的空链接到根结点的距离仍然相同。

- 向一个父结点为3-结点的3-结点中插入新键：

  我们一直向上不断分解临时的4-结点并将中键插人更高层的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217231714097.png" alt="image-20210217231714097" style="zoom:80%;" />

- 分解根结点：

  如果从插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个临时的 4-结点。我们将临时的4-结点分解为3个2-结点，使得树高加1。这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217231906755.png" alt="image-20210217231906755" style="zoom:80%;" />



将一个4-结点分解为一棵2-3树可能有6种情况：

![image-20210217232142105](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217232142105.png)

和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210217232350040.png" alt="image-20210217232350040"  />

**2-3树在最坏情况下仍有较好的性能**。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以**任何查找或者插入的成本都肯定不会超过对数级别**。通过对比由相同的键构造的二叉查找树，完美平衡的2-3树要**平展**得多。

例如，含有10亿个结点的一棵 2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是相当惊人的。

### 红黑二叉查找树

我们将树中的链接分为两种类型：

- 红链接将两个2-结点连接起来构成一个3-结点
- 黑链接则是2-3树中的普通链接。

我们将3-结点表示为由一条左斜的红色链接相连的两个2-结点。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218103435162.png" alt="image-20210218103435162" style="zoom: 50%;" />

这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将用这种方式表示2-3 树的二叉查找树称为**红黑二叉查找树**。

红黑树的定义是含有红黑链接并满足下列条件的二叉查找树：

- 红链接均为左链接；
- 没有任何一个结点同时和两条红链接相连；
- 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。

满足这样定义的红黑树和相应的2-3树是一一对应的。

**如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的**。如果我们将由红链接相连的结点合并，得到的就是一棵2-3树。无论我们选择用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树。因此，我们能够将两个算法的优点结合起来:二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。

![image-20210218105943676](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218105943676.png)

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218110551477.png" alt="image-20210218110551477" style="zoom: 67%;" />

#### 基本实现：

- 颜色表示：

  每个结点都只会有一条指向自己的链接(从它的父结点指向它)，我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中。

  如果指向它的链接是红色的，那么该变量为true,黑色则为false。

  我们约定空链接为黑色。

  我们定义了两个常量RED和BLACK来设置和测试这个变量。我们使用私有方法isRed()来测试一个结点和它的父结点之间的链接的颜色。

  **当我们提到一个结点的颜色时，我们指的是指向该结点的链接的颜色**，反之亦然。

  ```java
  private static final boolean RED=true;
      private static final boolean BLACK=false;
      private class Node{
          Key key;//键
          Value val;//相关联的值
          int N;//该子树中的节点总数
          boolean color;//它的父节点指向它的链接颜色
          Node left,right;//左右子树
  
          public Node(Key key, Value val, int n, boolean color) {
              this.key = key;
              this.val = val;
              N = n;
              this.color = color;
          }
      }
      //判断该节点的父节点指向该结点的链接的颜色是不是红色
      private boolean isRed(Node x){
          //如果该节点为空，规定空链接为黑色
          if (x==null)return false;
          return x.color==RED;
      }
  ```

- 旋转：

  在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，通过旋转操作改变红链接的指向。

  左旋转：将一条红色的右链接需要被转化为左链接，对应的方法接受一条指向红黑树中某个节点的链接作为参数，**将用两个键中的较小者作为根结点变为将较大者作为根结点**。

  具体步骤：

  1. 获取另一个节点

  2. 改变两个节点之间的链接关系（左旋转）

     - 将h的右链接指向x的左子树；
     - x的左链接指向h

     从而将x变成根节点

  3. 改变两个节点链接的颜色

     - 因为x变成了根节点，所以x颜色就等于h原来的颜色

     - 红链接现在指向h，所以h的颜色等于红色

  4. 调整子树的节点数

     - 虽然x变成了根节点，但是从3-节点的角度来说，子树的大小没有发生变化，所以x的节点数等于原来的h的节点数；
     - h的子树发生了变化，用公式来调整节点数

  5. 用rotateRight()和rotateLeft()的返回值重置父节点中相应的链接

  ![image-20210218130124676](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218130124676.png)

  ```java
  //左旋转
      public Node rotateLeft(Node h){
          //获取另一个节点
          Node x=h.right;
          //改变两个节点之间的链接关系，将h的右链接指向x的左子树
          //x的左链接指向h，从而将x变成根节点
          h.right=x.left;
          x.left=h;
          //改变两个节点链接的颜色
          //因为x变成了根节点，所以x颜色就等于h原来的颜色
          //红链接现在指向h，所以h的颜色等于红色
          x.color=h.color;
          h.color=RED;
          //改变子树的节点数
          //虽然x变成了根节点，但是从3-节点的角度来说，子树的大小没有发生
          //变化，所以x的节点数等于原来的h的节点数
          //h的子树发生了变化，用公式来调整节点数
          x.N=h.N;
          h.N=1+size(h.right)+size(h.left);
          return x;
      }
      //右旋转
      public Node rotateRight(Node h){
          Node x=h.left;
          h.left=x.right;
          x.right=h;
          x.color=h.color;
          h.color=RED;
          x.N=h.N;
          h.N=1+size(h.left)+size(h.right);
          return x;
      }
  ```

- 颜色转换：

  我们用一个方法flipColors()来转换一个结点的两个红色子结点的颜色。将子结点的颜色由红变黑，同时将父结点的颜色由黑变红。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218182525820.png" alt="image-20210218182525820" style="zoom:67%;" />

- 向 2-结点中插入新键

  - 如果新键小于老键，我们只需要新增一个红色的结点即可，新的红黑树和单个3-结点完全等
    价。
  - 如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接。我们需要使用root =
    rotateLeft(root)来将其旋转为红色左链接并修正根结点的链接，插人操作才算完成。

  ![image-20210218180756677](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218180756677.png)

- 向一个3-结点中插入新键

  - 新键大于原树中的两个键：

    它被连接到3-结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。将两条链接的颜色都由红变黑，就得到了一棵由三个结点组成、高为2的平衡树。其他两种情况最终也会转化成这种情况。

  - 新键小于原树中的两个键：

    它会被连接到最左边的空链接，这样就产生了两条连续的红链接。此时我们只需要将上层的红链接右旋转即可得到第一种情况 (中值键为根结点并和其他两个结点用红链接相连)。

  - 新键介于原树中的两个键之间：

    这又会产生两条连续的红链接，一条红色左链接接一条红色右链接。此时我们只需要将下层的红链接左旋转即可得到第一二种情况(两条连续的红色左链接)。

  ![image-20210218182051883](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218182051883.png)

- 向树底部的3-节点插入新键

  指向新结点的链接可能是3-结点的右链接(此时我们只需要转换颜色即可)，或是左链接(此时我们需要进行右旋转然后再转换颜色)，或是中链接(此时我们需要先左旋转下层链接然后右旋转上层链接,最后再转换颜色)。

  颜色转换使中结点的链接变红，相当于将它送入了父结点。这意味着在父结点中继续插入一个新键，我们也会继续用相同的办法解决这个问题。

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218183706525.png" alt="image-20210218183706525" style="zoom:80%;" />

  插入的三种情况分别需要一次转换、两次转换、三次转换，且每一种情况的操作都在前一种的基础上进行，所以在沿着插入点到根结点的路径向上移动时在所经过的每个结点中**顺序**完成下列操作，我们就能完成插入操作:

  - 第一步：这一步以中间节点为中心，如果右子结点是红色的而左子结点是黑色的，进行左旋转；完成后返回中间的节点

  <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218223327682.png" alt="image-20210218223327682" style="zoom:50%;" />

  - 第二步：这一步以最右边的节点为中心，如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；完成后返回中间的节点。

    所以第一步不能和第二步连续执行，只能等第一步执行完之后，返回到上一个函数调用，中心移动到最右边的节点时，才能执行第二步。

    <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218223420766.png" alt="image-20210218223420766" style="zoom:50%;" />

  - 第三步：这一步以中间的节点为中心，如果左右子结点均为红色，进行颜色转换。执行完第二步后可以紧接着执行第三步。

    <img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210218223533191.png" alt="image-20210218223533191" style="zoom:50%;" />

  ```java
  public void put(Key key,Value val){
          root=put(root,key,val);
          root.color=BLACK;
      }
      private Node put(Node x,Key key,Value val){
          //当x等于null时，插入新的节点，不管是插入到2-节点还是3-节点
          //新的节点的颜色都是红色，插入之后再进行调整。
          if (x==null)return new Node(key,val,1,RED);
          int cmp=key.compareTo(x.key);
          if (cmp<0)x.left=put(x.left,key,val);
          else if (cmp>0)x.right=put(x.right,key,val);
          else x.val=val;
          //添加完节点后，开始自底向上调整树的链接
          if (isRed(x.right)&&!isRed(x.left))x=rotateLeft(x);
          if (isRed(x.left)&&isRed(x.left.left))x=rotateRight(x);
          if (isRed(x.left)&&isRed(x.right))flipColors(x);
          //自底向上对每个节点调整子树的大小
          x.N=size(x.left)+size(x.right)+1;
          return x;
      }
  ```

### 性能分析：

**所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别(范围查找除外）**

无论键的插人顺序如何，红黑树都几乎是完美平衡的。

一棵大小为N的红黑树的高度不会超过2lgN。

一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~ 1.00lgN。

![image-20210220214910381](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210220214910381.png)

## 4、散列表

散列表：我们可以用一个数组来实现无序的符号表，**使用算术操作将键转化为数组的索引，而数组中键i处储存的就是它对应的值**。这样我们就可以快速访问任意键的值。

使用散列的查找算法分为两步：

- 第一步是用散列函数将被查找的键转化为数组的一个索引。

理想情况下，不同的键都能转化为不同的索引值。但是实际我们需要面对两个或者多个键都会散列到相同的索引值的情况。

- 因此，散列查找的第二步就是一个处理碰撞冲突的过程

在描述了多种散列函数的计算后，我们会学习两种解决碰撞的方法:**拉链法**和**线性探测法**。

使用散列表，可以实现在一般应用中拥有(**均摊后**)**常数级别**的查找和插入操作的符号表。这使得它在很多情况下成为实现简单符号表的最佳选择。

### 散列函数

如果我们有一个能够保存M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引( [0,M-1]范围内的整数)的**散列函数**。我们要找的散列函数应该易于计算并且能够均匀分布所有的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之对应(与键无关)。

散列函数和键的类型有关，对于每种类型的键都我们都需要一个与之对应的散列函数。

- 如果键是一个数，比如社会保险号，我们就可以直接使用这个数

  **除留余数法**：我们选择大小为素数M的数组,对于任意正整数k，计算k除以M的余数。这个方法能够有效地将键散布在0到M-1的范围内。

  **如果M不是素数，我们可能无法利用键中包含的所有信息，这可能导致我们无法均匀地散列散列值**。

  如果键是十进制数而M为10^k，那么我们只能利用键的后k位，这可能会产生一些问题。

  - 假设键为电话号码的区号且M=100。由于历史原因，美国的大部分区号中间位都是0或者1，因此这种方法会将大量的键散列为小于20的索引，但**如果使用素数97，散列值的分布显然会更好(一个离100更远的素数会更好)**。
  - 互联网中使用的IP地址也不是随机的，所以如果我们想用除留余数法将其散列就需要用素数(2的幂除外)大小的数组。

- 如果键是0到1之间的浮点数：

  我们可以将它乘以M并四舍五人得到一个0至M-1之间的索引值。尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法(Java就是这么做的)。

- 如果键是一个字符串，比如一个人的名字，我们就需要将这个字符串转化为一个数

  利用除留余数法计算string s的散列值：

  ```java
  int hash = 0;
  for (int i = 0;i < s.length(); i++)
  	hash= (R*hash + s.charAt(i)) % M;
  ```

  使用一个较小的素数，例如31,可以保证字符串中的所有字符都能发挥作用。Java 的String的默认实现使用了一个类似的方法。

- 如果键含有多个部分（组合键），比如邮件地址、日期，我们需要用某种方法将这些部分结合起来

  假设被查找的键的类型是Date，其中含有几个整型的域: day (两个数字表示的日)，month
  (两个数字表示的月 )和year (4个数字表示的年) 。我们可以这样计算它的散列值：

  `int hash = (((day * R + month) %M) * R+year) %M;`

#### hashCode()方法

每种数据类型都需要相应的散列函数，于是Java令所有数据类型都继承了一个能够返回一个**32位整数**的hashCode()方法。

每一种数据类型的hashCode()方法都必须和equals()方法一致：

- 如果a. equals(b)返回true,那么a. hashCode()的返回值必然和b. hashCode()的返回值相同。
- 如果两个对象的hashCode()方法的返回值不同，这两个对象一定是不同的。
- 但如果两个对象的hashCode()方法的返回值相同，这两个对象也有可能不同，我们还需要用equals()方法进行判断。

这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写hashCode()和equals()两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。

- 自定义的hashCode()方法：

  **散列表的用例希望hashCode()方法能够将键平均地散布为所有可能的32位整数**。也就是说，对于任意对象x,你可以调用x. hashCode()并认为有均等的机会得到2^32中的任意一个32位整数值。对于自已定义的数据类型，必须试着自己实现这一点。

  - Date例子展示了一种可行的方案：用实例变量的整数值和除留余数法得到散列值。

    `int hash = (((day * R + month) %M) * R+year) %M;`

  - 在Java中，所有的数据类型都继承了hashCode()方法，因此还有一个更简单的做法：将对象中的每个变量的hashCode()返回值转化为32位整数并计算得到散列值

    ```java
    public Class Transaction
    {
        private final String who;
        private final Date when;
        private final double amount;
        public int hashCode()
        {
            int hash = 17;
            hash = 31 * hash + who.hashCode();
            hash = 31 * hash + when.hashCode();
            hash=31 * hash+ ((Double) amount). hashCode();
            return hash;
        }
    }
    ```

- 软缓存

  如果散列值的计算很耗时，那么我们可以将每个键的散列值缓存起来，即在每个键中使用一个hash变量来保存它的hashCode()的返回值。

  第一次调用hashCode()方法时，我们需要计算对象的散列值,但之后对hashCode()方法的调用会直接返回hash变量的值。Java的String对象的hashCode()方法就使用了这种方法来减少计算量。

- **将hashCode()的返回值转化为一个数组索引**：

  因为我们需要的是数组的索引而不是一个32位的整数,我们在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数:

  ```java
  private int hash(Key x)
  { return (x.hashCode() & 0x7ffffff) % M; }
  ```

  这段代码会将符号位屏蔽(将一个 32位整数变为一个 31位非负整数)，然后用除留余数法计算它除以M的余数。在使用这样的代码时我们一般会将数组的大小M取为素数以充分利用原散列值的所有位。

总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件:

- 一致性：等价的键必然产生相等的散列值
- 高效性：计算简便
- 均匀性：均匀地散列所有的键

注意！**不要修改存在hashset中或者hashmap中的键**！修改后hashCode会改变，有可能导致这个item丢失

重写hashCode方法的同时也要重写equals方法！

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210402143344613.png" alt="image-20210402143344613" style="zoom:50%;" />

### 基于拉链法的散列表

散列算法的第二步是**碰撞处理**，也就是处理两个或多个键的散列值相同的情况。

一种直接的办法是将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为**拉链法**，因为发生冲突的元素都被存储在链表中。

这个方法的基本思想就是选择足够大的M,使得所有链表都尽可能短以保证高效的查找。

**查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键**。

因为我们要用M条链表保存N个键，无论键在各个链表中的分布如何，链表的平均长度肯定是N/M。

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210222141341636.png" alt="image-20210222141341636" style="zoom: 50%;" />

拉链法的一种实现方法是使用一个`SequentialSearchST`（无序链表的顺序查找）对象的数组，在put()和get()的实现中先计算散列函数来选定被查找的`SequantialSearchST`对象，然后使用符号表的put()和get()方法来完成相应的任务。

```java
public class SeparateChainingHashST<Key,Value> {
    private int N;//键值对总数
    private int M;//散列表的大小
    private SequentialSearchST<Key,Value>[]st;//存放链表对象的数组
    //默认构造函数，创建997条链表（数组的大小也就是997）
    public SeparateChainingHashST(){
        this(997);
    }
    public SeparateChainingHashST(int M){
        //创建M条链表
        this.M=M;
        //创建类型为SequentialSearchST的数组，创建时需要进行类型转换，因为java不允许泛型的数组
        st=(SequentialSearchST<Key,Value>[])new SequentialSearchST[M];
        for (int i=0;i<M;i++){
            st[i]=new SequentialSearchST<>();
        }
    }
    private int hash(Key key){
        //将键的hashCode转化为数组的索引
        return (key.hashCode()&0x7fffffff)%M;
    }
    //查找
    public Value get(Key key){
        //首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键
        return st[hash(key)].get(key);
    }
    //插入
    public void put(Key key,Value val){
        //首先根据散列值找到对应的链表，然后在链表中插入
        st[hash(key)].put(key,val);
    }
}
```

这段简单的符号表实现维护着**一条链表的数组**，用散列函数来为每个键选择一条链表。 在创建st[]时需要进行类型转换，因为Java不允许泛型的数组。

hashCode()由数据类型自己实现，返回一个32位的整数，要尽量做到将键平均地散布为所有可能的32位整数。将hashCode()转化为数组索引由散列表实现，将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数。

默认的构造函数会使用997条链表，因此对于较大的符号表，这种实现比SequentialSearchST大约会快1000倍。

在一张含有M条链表和N个键的的散列表中，未命中查找和插入操作所需的比较次数为~N/M。

#### 散列表的大小

在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

而拉链法的一个好处就是这并不是关键性的选择。如果存入的键多于预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些空间浪费但查找会非常快。

当内存不是很紧张时，可以选择一个足够大的M，使得查找需要的时间变为常数；当内存紧张时，选择尽量大的M仍然能够将性能提高M倍。

另一种方法是**动态调整数组**的大小以保持短小的链表。

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210402123102430.png" alt="image-20210402123102430" style="zoom:50%;" />

基于拉链法的散列表最差情况下的时间复杂度为Θ(Q)，Q是最长的链表的长度，平均时间复杂度为Θ(N/M)，N/M是链表的平均长度。

如果数组的容量太小了，就会接近于线性时间复杂度，所以我们不能固定数组的大小，而是随着插入操作，动态地resize数组。

N/M的值被称为**load factor**，我们采取的策略是，当N/M>1.5时，就将数组的长度M翻倍。也就是说链表的平均长度不超过1.5 。

<img src="https://cdn.jsdelivr.net/gh/BoL0150/imgbed@main/image-20210402133328601.png" alt="image-20210402133328601" style="zoom:50%;" />

对散列表的大部分操作耗费Θ(1)，少数操作复杂度为Θ(N)，因为需要resize，但是均摊到每一次，平均时间仍然是Θ(1)。

散列最主要的目的在于均匀地将键散布开来，**因此在计算散列后键的顺序信息就丢失了**。如果你需要快速找到最大或者最小的键，或是查找某个范围内的键，或是实现有序符号表API中的其他任何方法，**散列表都不是合适的选择**，因为这些操作的运行时间都将会是线性的。

### 基于线性探测法的散列表

实现散列表的另一种方式就是用大小为M的数组保存N个键值对，其中**M>N**。我们需要**依靠数组中的空位解决碰撞冲突**。基于这种策略的所有方法被统称为开放地址散列表。

开放地址散列表中最简单的方法叫做线性探测法：当碰撞发生时(当一个键的散列值已经被另个不同的键占用)，我们直接检查散列表中的下一个位置(将索引值加1)。这样的线性探测可能会产生三种结果:

- 该位置的键和被查找的键相同，命中
- 该位置的键和被查找的键不同，继续查找，直接检查数组中的下一个位置(将索引值加1，到达数组结尾时折回数组的开头)
  - 查找到键为null ，散列表中不存在该键，结束查找操作。如果是插入操作的话，此时在该位置插入新的键值对。
  - 找到该键，命中。

开放地址类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标志。

我们在实现中使用了并行数组，一条保存键，一条保存值，并像前面讨论的那样使用散列函数产生访问数据所需的数组索引。

![image-20210222162728481](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210222162728481.png)

```java
public class LinearProbingHashST<Key,Value> {
    private int N;//符号表中键值对的总数
    private int M=16;//线性探测表的大小（即数组的大小）
    private Key[]keys;//键
    private Value[]vals;//值
    public LinearProbingHashST(){
        keys=(Key[])new Object[M];
        vals=(Value[])new Object[M];
    }
    public LinearProbingHashST(int cap){
        M=cap;
        keys=(Key[])new Object[M];
        vals=(Value[])new Object[M];
    }
    private int hash(Key key){
        return (key.hashCode()&0x7fffffff)%M;
    }
    private void resize(int n){};
    public void put(Key key,Value val){
        if (N>M/2)resize(2*M);
        int i;
        //用散列函数产生数组索引，从此处开始向后查找，直到键为null
        //将索引值加1，到达数组结尾时折回数组的开头（i=(i+1)%M）
        for(i=hash(key);keys[i]!=null;i=(i+1)%M){
            if (key.equals(keys[i])){
                vals[i]=val;
                return;
            }
        }
        //在键为null的地方插入新的键值对
        keys[i]=key;
        vals[i]=val;
        N++;
    }
    public Value get(Key key){
        for (int i=hash(key);keys[i]!=null;i=(i+1)%M){
            //找到了就返回值
            if (key.equals(keys[i]))
                return vals[i];
        }
        //没找到就返回空
        return null;
    }
}
```

- 删除操作：

  直接将该键所在的位置设为null是不行的，因为这会使得在此位置之后的元素无法被查找。我们也不能将被删除位置之后所有的元素都向前挪动一位，因为这样会导致部分元素偏离散列值。

  因此，我们需要将簇中被删除键的右侧的所有键**重新插入散列表**。

  ```java
  public void delete(Key key){
          int i=hash(key);
          //查找要删除的键的位置
          while (!key.equals(keys[i]))
              i=(i+1)%M;
          keys[i]=null;
          vals[i]=null;
          i=(i+1)%M;
          //对被删除元素后面的所有元素重新插入，遇到空键为止
          while (keys[i]!=null){
              Key keyToRedo=keys[i];
              Value valToRedo=vals[i];
              keys[i]=null;
              vals[i]=null;
              N--;
              put(keyToRedo,valToRedo);
              i=(i+1)%M;
          }
          N--;
          //M大于等于8而且N等于M/8时就要动态调整大小为M/2
          if (N>0&&N==M/8)resize(M/2);
      }
  ```

  拉链法和开放地址类的散列表的性能都依赖于a =N/M的比值，但意义有所不同。

  我们将a称为散列表的使用率。

  - 对于基于拉链法的散列表，a是链表的平均长度，因此一般大于1
  - 对于基于线性探测的散列表，a是表中已被占用的空间的比例，它是不可能大于1的。事实上，在
    `LinearProbingHashST`中我们不允许a达到1 ( 散列表被占满)，因为此时未命中的查找会导致
    无限循环。为了保证性能，**我们会动态调整数组的大小来保证使用率在1/8到1/2之间**。

当散列表快满的时候查找所需的探测次数是巨大的(a越趋近于1，由公式可知探测的次数也越来越大)，但当使用率a小于1/2时探测的预计次数只在1.5到2.5之间。所以，我们需要为此来考虑动态调整散列表数组的大小。

#### 调整数组的大小

- 线性探测法：

  它会创建一个新的给定大小的`LinearProbingHashST`，保存原表中的keys和values变量，然后将原表中所有的键**重新散列**并插人到新表中（注意！不能直接按照原数组的位置直接插入！要重新散列之后再插入！）

  ```java
  private void resize(int cap){
          LinearProbingHashST<Key,Value>t=new LinearProbingHashST<>(cap);
          for (int i=0;i<M;i++){
              if (keys[i]!=null)
                  t.put(keys[i],vals[i]);
          }
          keys=t.keys;
          vals=t.vals;
          M=t.M;
      };
  ```

- 拉链法：

  对于拉链法，如果你能准确地估计用例所需的散列表的大小N，**调整数组的工作并不是必需的**，只需要根据查找耗时和( 1+N/M)成正比来选取一个适当的M即可。而对于线性探测法，调整数组的大小是必需的，因为当用例插人的键值对数量超过预期时它的查找时间不仅会变得非常长，还会在散列表被填满时进入无限循环。

> Java 的Integer、Double 和Long类型的hashCode()方法是如何实现的?
>
> Integer类型会直接返回该整数的32位值。对于Double和Long类型，Java会返回值的机器表示的前32位和后32位异或的结果。这些方法可能不够随机，但它们的确能够将值散列。
>
> 散列表的查找比红黑树更快吗?
>
> 这取决于键的类型，它决定了hashCode()的计算成本是否大于compareTo()的比较成本。对于常见的键类型以及Java的默认实现，这两者的成本是近似的，因此散列表会比红黑树快得多，因为它所需的操作次数是固定的。但需要注意的是，如果要进行有序性相关的操作，这个问题就没有意义了，因为散列表无法高效地支持这些操作。



```java
public class Test{
    static class person{
        int height;
        int weight;
        String name;

        public person(int height, int weight, String name) {
            this.height = height;
            this.weight = weight;
            this.name = name;
        }
    }
    public static void main(String[] args) {

        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(1,2);
        System.out.println(map.containsKey(1));//true
        //自定义的类如果不重写hashCode，则返回的是对象的引用的地址，而不是对象值的散列
        //而HashMap的本意应该是针对对象的内容
        //类似的还有equals()，自定义的类中如果使用默认的equals()，相当于==，就是判断两边的引用是否相同
        //而equals()的本意应该是判断对象的内容是否相同
        HashMap<person, Integer> map2 = new HashMap<>();
        map2.put(new person(180, 180, "libo"), 250);
        System.out.println(map2.containsKey(new person(180, 180, "libo")));//false
        
    }
}
```

HashMap插入：

- HashCode()返回一个32位的数，Hash()方法使用HashMap数组的大小对该32位的整数进行求余，以求余后的值为索引，在数组中找到该位置。
  - 如果数组的该位置为null，直接插入。
  - 如果该位置不为null，则是一串链表。从头到尾依次比较每个对象和插入对象的HashCode值：
    - 如果HashCode不相同，说明比较的两个对象一定不同，比较下一个对象
    - 如果HashCode相同，则有可能相同，也有可能不同，还需要使用equals()对两个对象进行比较。
      - 如果equals()都相同，才能说明两个对象的内容真的完全相同。用插入的value替换掉原来的value
      - 否则，表明两个对象的内容不相同，比较下一个对象
  - 直到将所有对象都比较完，都不相同，插入到链表的尾部。

**需要用数组索引、HashCode、equals()进行三次判断**

以上过程中的HashCode()方法和equals()方法都需要重写，如果采用默认的方法，HashCode()返回的是对象的引用的地址，而不是对象内容的散列。equals()与==相同，比较的是对象的引用是否相同，而不是对象的内容是否相同。

HashMap不允许存在相同的key（相同的内容，而不是相同的引用）

## 5、应用

![image-20210222213838065](%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210222213838065.png)

- 编译器

  符号表最早期的应用之一就是组织程序代码的信息。最初，计算机程序只是一串简单的数字，但程序员们很快发现使用符号来表示操作和内存地址(变量名)要方便得多。将名称和数字关联起来就需要一-张符号表。 随着程序的增长，符号表操作的性能逐渐变成了程序开发效率的瓶颈，为此而开发的数据结构和算法就是我们在本章中学习的内容。

- 文件系统

  我们都在使用符号表定期整理计算机系统中的数据。也许其中最明显的例子就是文件系统了，因为是它将文件名(键)和文件内容的地址(值)关联起来。音乐播放器同样使用文件系统关联了歌曲名( 键)和歌曲的位置(值)

- 互联网DNS

  域名系统(DNS)是互联网信息组织的基础，它可以将人类能够理解的URL (键，如www.princeton.edu或是www.wikipedia.org )和计算机网络中路由器能够理解的IP地址(值，如208.216.181.15或是207.142.131.206 ) 关联起来。这个系统被称为下一代“电话黄页”。有了它，人们就可以使用便于记忆的域名，而机器也可以高效地处理对应的数字。全球互联网的路由器中每秒钟进行的符号表查找次数是个天文数字，所以性能显然非常重要。每年，互联网上都会新增上百万台电脑和其他设备,因此互联网
  路由器中的符号表也需要能够动态地适应它们。



















