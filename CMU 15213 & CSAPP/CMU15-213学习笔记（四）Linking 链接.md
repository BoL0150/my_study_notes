# CMU15-213学习笔记（四）Linking 链接

## 编译过程

编译系统(compilation system)：预处理器(pre-processor)、编译器(compiler)、汇编器(assembler)、链接器(linker)
![编译系统](https://raw.githubusercontent.com/BoL0150/image2/master/2019032218233554.png)

- **预处理阶段**：处理字符`#`开头的命令，即：

  1. 将头文件的内容插入程序文本中
  2. 宏定义替换
  3. 条件编译(`#if` `#ifdef`)，不被编译的部分变为空行
  4. 删除注释

  预处理的命令：

  ```bash
  $gcc –E hello.c –o hello.i
  $cpp hello.c > hello.i #两条命令等价，都是预处理hello.c文件，然后重定向输出为hello.i文件
  ```

  经过预编译处理后，得到的是预处理文件（如，hello.i) ，它还 是一个可读的文本文件 ，但不包含任何宏定义

  <img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210727224047169.png" alt="image-20210727224047169" style="zoom:50%;" />

- **编译阶段**：通过**编译器**将源程序翻译成*汇编程序(assembly-language program)*

  编译指令：

  ```bash
  $gcc –S hello.i –o hello.s #将hello.i编译，重定向输出为hello.s文件
  $gcc –S hello.c –o hello.s #进行两步操作，先对hello.c预处理，再进行编译
  $/user/lib/gcc/i486-linux-gnu/4.1/cc1 hello.c #也可以直接调用cc1对hello.c进行编译，cc1前面是												该命令所在的位置
  ```

  gcc实际上是GCC编译系统驱动程序，代表用户调用具体的预处理程序ccp、编译程序cc1和 汇编程序as等。从上面的代码可以看到，`gcc -S`等同于 `cc1`，`gcc -E`等同于 `cpp`。

- **汇编阶段**：将汇编程序翻译成机器语言指令，并将其打包成***可重定位目标程序(relocatable object program)***

  汇编指令和机器指令一一对应，前者是后者的符号表示，**它们都属于机器级指令**，所构成的程序称为**机器级代码**

  ```bash
  $gcc –c hello.s –o hello.o
  $gcc –c hello.c –o hello.o #此程序要经过三个阶段
  $as hello.s -o hello.o #（as是一个汇编程序）
  ```

  汇编结果是一个可重定位目标文件（如`hello.o`），其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容（如objdump，gdb）

- **链接阶段**：链接器将各个可重定位目标文件（.o文件）合并成可执行目标文件。**链接器使得分离编译成为可能。在编写大型程序时，可将模块分小，由此达到独立修改和编译不同模块的目的**：未被修改的模块不用重新编译，而只需将修改后的模块编译，重新链接即可。e.g. hello.c中的printf函数存在printf.o(已经单独预编译了的目标文件)中，链接器将其合并后得到可执行文件

  ```bash
  $gcc –static –o myproc main.o test.o 
  $ld –static –o myproc main.o test.o	 
  ```

  链接阶段gcc命令没有对应的参数，只要处理的源程序是`.o`，就认为现在正在链接。`-o myproc`代表输出的可执行文件名为`myproc`。`-static`表示静态链接。

注意，这里`gcc`的**默认输出**就是固定的`a.out`（通过使用参数-o（**o**utput），可以指定输出文件的名称。 例如`gcc b.c -o b.bin`，将生成可执行文件`b.bin`，而不是默认的`a.out`）

```
      -E          -S          -c          
b.c ------> b.i ------> b.s ------> b.o ------> a.out
      gcc         gcc         as          ld
```

## 链接

要使用GNU编译系统构造程序，需要在linux中输入以下命令调用GCC编译器驱动程序。将程序翻译为机器码并且链接

```bash
linux> gcc -Og -o prog main.c sum.c #-o prog 表示生成的可执行文件的名字为prog
```

首先使用cpp（c pre processor）、cc1、as将两个文件分别编译成重定位目标文件，再使用Linker，将两个文件连接在一起，生成可执行目标文件（包含两个文件中所有函数的代码和数据）。

要运行可执行文件`./prog`，在linux shell命令行中输入它的名字。

```c
linux> ./prog
```

shell调用操作系统中一个叫做加载器的函数，它将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210727180635744.png" alt="image-20210727180635744" style="zoom:67%;" />

### 链接器的由来

在机器代码中：

```
0：0101 0110 
1：0010 0101 --|
2： ……		  |	
3： ……		  |
4： …… 		  |
5：0110 0111 <--
6： ……
```

 假设：0010-jmp，第一条指令要求跳转到5，若在第5条指令前加入 指令，则程序员需重新计算jmp指令的目标地 址（重定位）。

汇编语言的出现，使用符号来表示跳转位置和变量位置。

```
0：0101 0110 		add B
1：0010 0101 --|		jmp L0
2： ……		  |		 …… 
3： ……		  |		 ……
4： …… 		  |		 ……
5：0110 0111 <--	 L0：sub C
6： ……				 ……
```

高级编程语言出现后，我们在代码中会声明**全局**变量及函数，这些东西被称之为符号（symbol）。之后会调用变量及函数，也就是对符号的引用（reference）。

```c
void swap() {…} /* define symbol swap */
swap(); /* reference symbol swap */
int *xp = &x; /* define symbol xp, reference x */
```

**最终链接将多个.o文件合并为一个文件，所有的数据和程序处于同一虚拟地址空间中，这些符号的引用全部都要替换为在最终的可执行目标文件中的地址值**。

链接器主要负责做两件事情

- **第一步：符号解析 Symbol resolution**

  - 所有**定义的**符号都会被保存在**符号表(symbol table)**中，而符号表会保存在由汇编器生成的 object 文件中（也就是 `.o` 文件）。符号表实际上是一个结构体数组，在`.symtab`中，每一个表项是一个结构类型，每个表项包含符号名、长度和位置等信息。
  - 将**符号的引用**存放在**重定位节**（`.rel.text`和`.rel.data`）中
    - `.rel.text`存放代码的重定位信息
    - `.rel.data`存放数据的重定位信息

  有了符号表节和重定位节后，在Symbol resolution阶段，**链接器就可以给每个符号引用与一个符号定义建立关联，用作寻找对应符号的标志**。符号解析实际上就是一个符号绑定的过程。

- **第二步：重定位 Relocation**

  这一步所做的工作是把原先分开的代码和数据片段**汇总成一个文件**，将多个代码段和数据段分别合并为一个单独的代码段和数据段，重定位符号，把符号原先在 `.o` 文件中的相对位置转换成在可执行程序的绝对位置，**确定每个符号的地址**（**这个地址实际上是可执行文件映射到虚拟内存空间中的地址**，而不是在可执行文件中的偏移地址），并且**据此更新引用处的地址为重定位后的地址**，在指令中填入新的地址。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728094433385.png" alt="image-20210728094433385" style="zoom: 33%;" />

**注意！局部变量temp分配在栈中，不会在过程外被引用，因此不是符号定义**

使用连接的好处：

- 模块化：我们可以把程序分散到不同的小的源代码中，而不是一个巨大的类中。这样带来的好处是可以复用常见的功能/库，比方说 Math library, standard C library.
- 效率：改动代码时只需要重新编译改动的文件，然后链接在一起就行了。而不需要重新编译所有的文件。而常用的函数和功能可以封装成库，提供给程序进行调用（节省空间，可执行文件和运行时内存中只需包含所调用函数的代码，而不需要包含整个共享库。例如：只包含`printf.o`的代码，不包含`libc.a`中其他函数的代码）

### 连接过程的本质

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728104330368.png" alt="image-20210728104330368" style="zoom: 67%;" />

链接的本质：**合并.o文件中相同的节，合并完后的格式还是ELF**。

链接成可执行目标文件后的格式如下图左边所示，此时文件还存在磁盘中。在shell中输入可执行文件的名字后

```c
linux> ./prog
```

shell调用操作系统中一个叫做加载器的函数，它将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。此时文件被复制到内存中，它在虚拟内存空间中的格式如下图右边所示。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728105104365.png" alt="image-20210728105104365" style="zoom: 50%;" />

对.o文件反汇编得到代码和数据的地址是从0开始，而对可执行目标文件反汇编，代码和数据的地址就是虚拟内存空间中的地址了。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728110000675.png" alt="image-20210728110000675" style="zoom: 50%;" />

### 目标文件的格式

目标代码指编译器和汇编器处理源代码后生成的**机器语言**目标代码。目标文件指包含目标代码的文件。所谓的目标文件(Object File)实际上是一个统称，具体来说有以下三种形式：

- 可重定位目标文件 Relocatable object file (`.o`file)
  - 每个 `.o` 文件都是由对应的 `.c` 文件通过编译器和汇编器生成，包含代码和数据**，每个.o文件的代码和数据的地址都从0开始**。可以与其他可重定位目标文件合并创建一个可执行或共享的目标文件
- 可执行目标文件 Executable object file (linux默认为`a.out` ，windows中为`*.exe`)
  - 由链接器生成，包含的代码和数据可以直接通过加载器加载到内存中充当进程执行的文件。**代码和数据的地址就是虚拟内存空间中的地址**
- 共享目标文件 Shared object file (`.so` file)
  - 在 windows 中被称为 Dynamic Link Libraries(DLLs)，是特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接，称为共享库文件。

上面提到的**三种目标文件有统一的格式**，即 Executable and Linkable Format(ELF)，是一种Unix-like系统上的**二进制文件格式标准**。它是 `.o`文件 `.out`文件 `.so`文件的统一格式。

ELF标准中采用ELF格式的文件分为4类：

![image-20210823203427742](https://raw.githubusercontent.com/BoL0150/image2/master/image-20210823203427742.png)

ELF文件分为两种视图：链接视图和执行视图。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728113350103.png" alt="image-20210728113350103" style="zoom: 50%;" />

#### 链接视图-可重定位目标文件

- 可被链接（合并）生成可执行文件或共享目标文件

- 静态链接库文件由若干个可重定位目标文件组成 
- 包含代码、数据（已初始化.data和未初始化.bss）
- 包含重定位信息（指出哪些符号引用处需要重定位） 
- 文件扩展名为.o（相当于Windows中的 .obj文件）

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728113926109.png" alt="image-20210728113926109" style="zoom: 50%;" />

- .text节
  - 源代码编译后的机器指令

- .data 节
  - 已初始化的全局和静态变量 ，.data节中存放具体的初始值，需要占磁盘空间
- .bss 节 
  - 未初始化的全局和静态变量，和初始化为0的全局和静态变量。仅是占位符，在目标文件中不占据任何实际磁盘空间。.bss节中无需存放初始值，只要说明.bss中的每个变量将来在执行时占用几个字节即可。在运行时，在内存中分配初始值为0 。**因此，.bss节实际上不占用磁盘空间，提高了磁盘空间利用率**

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728121359988.png" alt="image-20210728121359988" style="zoom: 67%;" />

只有`.text`、`.data`、`.bss`、`.rodata`加载到内存中才会占用内存空间，而下图中的这些节只是在链接时才会用，链接完后这些节是不需要装入到内存中的。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728121825965.png" alt="image-20210728121825965" style="zoom: 67%;" />

先通过ELF头找到节头表的位置（ELF头中有节头表的偏移量），再通过节头表找到对应的节（节头表中包含每个节的节名、偏移和大小）。

**局部非静态变量和局部静态变量的区别**：

- 局部非静态变量会保存在栈中
- 局部静态变量会保存在 `.bss` 或 `.data` 中

那如果两个函数中定义了同名的静态变量会怎么样呢？首先，编译器会在 `.data` 部分为每一个静态变量进行定义，如果遇到同名，就会在本地的符号表中自动给出唯一的编号，比如下面例子中的变量 `x`，可能在符号表中是 `x.1` 和 `x.2`

```c
int f()
{
    static int x = 0;
    return x;
}

int g()
{
    static int x = 1;
    return x;
}
```

##### ELF头

使用 `readelf -h`可以读取elf文件的头：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728123104450.png" alt="image-20210728123104450" style="zoom: 67%;" />

- 魔数：文件开头几个字节通常用来确定文件的类型或格式
- Type：文件类型
- Entry point address：因为此文件是可重定位的文件，是链接视图，无法执行，所以装入的地址为0，也就是说根本无法执行。
- Start of program headers：等于0说明不包含程序头表
- Start of section headers:节头表的起始地址
- Size of section headers: 40 (bytes) 节头表每个表项的大小
- Number of section headers: 15  节头表一共有多少表项
- Section header string table index: 12  .strtab在节头表中的索引

##### 节头表Section header table

 节头表中**表项**的数据结构，表项描述了每个节的节名、在文件中的偏移、大小、访问属性、对齐方式等 。以下是32位系统对应的数据结构（每个表项占40B）

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728131238484.png" alt="image-20210728131238484" style="zoom: 67%;" />

使用 `readelf -S`可以读取目标文件的节头表的内容：一共有11个表项，每个表项都是上图的数据结构，每个表项对应elf中的一个节（可以`readelf -SW`在同一排显示，看得更清楚）

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728131432600.png" alt="image-20210728131432600" style="zoom:67%;" />

**所有节的虚拟地址字段都是0，因为这是.o文件，是链接视图，而不是执行视图，无法被加载入内存中执行**。】

#### 执行视图—可执行目标文件

- 包含代码、数据（已初始化.data和未初始化.bss）

- 定义的所有变量和函数已有确定地址（虚拟地址空间中的地址） 
- 符号引用处已被重定位，以指向所引用的定义符号 
- 没有文件扩展名或默认为a.out（相当于Windows中的 .exe文件） 
- 可被CPU直接执行，指令地址和指令给出的操作数地址都是虚拟地址

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728180911667.png" alt="image-20210728180911667" style="zoom:50%;" />



使用 `readelf -h`也可以读取可执行目标文件的头：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728181838090.png" alt="image-20210728181838090" style="zoom:67%;" />

##### 可执行文件的存储器映射

所有的代码（`.init`、`.text`）和只读数据（`.rodata`）映射到只读代码段（Text段），可读可写的数据映射到读写数据段（data段），其他的节不会被装入内存空间，而**程序头表中的信息会描述可执行文件中的节映射到存储空间中的什么位置**。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728182257547.png" alt="image-20210728182257547" style="zoom:67%;" />

##### 可执行文件中的程序头表program header section

**ELF文件中的部分被称为节（section），虚拟内存空间中的部分被称为段（segment）**。

可执行目标文件需要装入内存然后被执行，装入到内存的时候，需要映射到存储空间（虚拟地址空间）对应的**段**中。**程序头表**描述了可执行目标文件中的节和段的对应关系，而可重定位目标文件不会被装入内存空间，所以不需要程序头表。

**程序头表描述可执行文件中的节与虚拟空间中的存储段之间的映射关系**，一个表项（32B）说明虚拟地址空间中 一个连续的段或一个特殊的节，以下是某可执行目标文件程序头表信息 ，有8个表项，其中**两个为可装入段（即 Type=LOAD）**，分别是：

- 所有的代码（`.init`、`.text`）和只读数据（`.rodata`）还有ELF头、程序头表映射到只读代码段（Text段）
- 可读可写的数据（`.data`、`.bss`）映射到读写数据段（data段）

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728185501611.png" alt="image-20210728185501611" style="zoom:67%;" />

注意：.bss在磁盘中不占用空间，但是加载到内存中后，占用虚拟内存空间（因为要给未初始化的变量赋值0）。

综上，section header table描述了链接视图，program header table描述了运行视图。

- 先将多个文件分别编译成可重定位目标文件
- **链接时**由**elf头**找到**节头表Section header table**，再由**节头表**找到对应的节在文件中的位置，合并这些可重定位目标文件中的相同的节，生成一个可执行目标文件。
- 执行该文件时，根据**程序头表program header table**找到节对应加载到虚拟内存空间中的哪些段，将可执行目标文件的数据和代码加载进内存中。（实际上执行时，不会真正从磁盘调入信息到主存，**只是生成一个初始的页表**，将被执行程序的虚拟页和磁盘上的数据/代码建立对应关系）。

###  符号表

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728233321092.png" alt="image-20210728233321092" style="zoom: 50%;" />

**注意！`void swap();`和`extern int buf[];`不算符号的定义！**

每个可重定位目标文件m都有一个符号表，它包含了在m中**定义和引用**的符号，具体来说是以下三种符号： 

- **Global symbols**：定义在本目标模块的全局符号，可以被其他函数引用
- **External symbols**：**在本目标模块中引用的全局符号，但是却没有定义在本模块**。
- **Local symbols**：本模块的局部符号，仅由模块m定义和引用的本地符号，仅在本模块内可见。例如，在模块m中定义的带static 的C函数和全局变量。

注意！链接器局部符号不是指程序中的局部变量（分配在栈中的临时性变量）,**链接器不关心这种局部变量**

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728232347959.png" alt="image-20210728232347959" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210728233637715.png" alt="image-20210728233637715" style="zoom: 50%;" />

`void swap();`和`extern int buf[];`都不属于符号的定义！swap和buf这两个符号出现在符号表中的原因是：它们在本模块中被引用了。如果我们把源码中的引用删去，只留下`void swap();`和`extern int buf[];`，那么符号表中就不会出现这两个符号，说明它们不算符号的定义。

查看符号表使用 `readelf -s`命令，注意！是小写的s。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210731144926860.png" alt="image-20210731144926860" style="zoom:67%;" />

而它们属于UND的原因则是：它们并没有在本模块中定义，所以是未定义的。

**实际上符号定义在别的节中，不是定义在符号表中，符号表只是把这些符号的信息收集起来**，有的是代码中的符号，属于.text；有的是初始化的全局或静态变量，属于.data；有的是未初始化的全局或静态变量，属于.bss（COM）。

#### 符号解析

链接器解析符号引用的方法是将每个引用与它输入的**可重定位目标文件中的符号表**中的一个确定的符号关联起来。

每**个定义符号在代码段或数据段中都被分配了存储空间**，将引用符号与定义符号建 立关联后，就可在重定位时将引用符号的地址重定位为相关联的定义符号的地址。**“符号的定义”的实质是指被分配了存储空间**。为函数名即指其代码所在区；为变量名即指其所占的静态数据区

- 本地符号在本模块内定义并引用，因此，其解析较简单，只要与本模块内唯一的定义符号关联即可。
- 全局符号（外部定义的、内部定义的）的解析涉及多个模块，故较复杂。
  - 当编译器遇到一个不在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个符号表条目，并把它交给链接器处理，如果该链接器在它的任何输入模块中都找不到这个被引用符号的定义，就会输出一条错误信息并终止。

强弱符号：

- 函数名和已初始化的**全局变量名**是强符号 
- 未初始化的**全局变量名**是弱符号

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210729115142651.png" alt="image-20210729115142651" style="zoom:50%;" />

~~注意！符号的类型都是相对于某个文件来说的。目标文件的符号表中只有在本文件中定义的符号！~~

~~比如，对于main.c来说，`void swap()`就是弱符号，因为它在main.c文件中没有初始化；对于swap.c来说，`extern int buf[]`就是弱符号，因为它在swap.c中没有初始化。而`static int*bufp1`是静态变量，不是全局变量，所以它既不是强符号也不是弱符号。同理，之前的全局符号、外部符号、局部符号都是一样的。~~

**以上的理解是错的！**

符号的类型不是相对于某个文件来说的！符号表中不只包括在本文件中定义的符号，还包括引用的符号！

**强弱符号是对符号定义来说的，不是针对引用。`void swap();`和`extern int buf[];`不是符号定义，所以既不是强符号也不是弱符号**。`static int*bufp1`是静态变量，不是全局变量，所以它既不是强符号也不是弱符号。

符号解析规则：

- 强符号不能多次定义 
  - **强符号只能被定义一次，否则链接错误** 
- 若一个符号被定义为一次强符号和多次弱符号，则按强定义为准 
  - 对弱符号的引用被解析为其强定义符号 
- 若有多个弱符号定义，则任选其中一个
  - 使用命令 gcc –fno-common链接时，会告诉链接器在遇到多个弱定义的全局符号时输出一条警告信息。 

**符号解析时只能有一个确定的定义（即每个符号仅占一处存储空间）**

指针实际上就是汇编语言中的地址操作数。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210729174155712.png" alt="image-20210729174155712" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210729174108807.png" alt="image-20210729174108807" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210729174539630.png" alt="image-20210729174539630" style="zoom: 50%;" />

####  静态链接

链接的时候会有两种模块，**一种是可重定位目标文件**，这些文件中可能会调用一些标准库中的函数，这些库称为静态库（.a文件），而库中包含多个.o模块。所以**链接时还会包含静态库（.a文件）中的.o模块**。

静态库 (.a archive files) 

- 将所有相关的目标模块（.o）打包为一个单独的库文件（.a），称为静态库文件 ，也称存档文件（archive）
- **在构建可执行文件时，只需指定库文件名**，链接器会自动到库中寻找那些应用程序用到的目标模块，并且**只把用到的模块从库中拷贝出来** 

在gcc命令行中无需明显指定C标准库libc.a(默认库)

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210729221424945.png" alt="image-20210729221424945" style="zoom: 50%;" />

Archiver（归档器）允许增量更新，只要重新编译需修改的源码并将其.o文件替换到静态库中

链接静态库的过程：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210729221722379.png" alt="image-20210729221722379" style="zoom:50%;" />

- 首先使用 `gcc –c myproc1.c myproc2.c`将这两个文件编译成.o文件
- 再用 `ar rcs mylib.a myproc1.o myproc2.o`将刚才生成的两个.o 文件打包生成`mylib.a`静态库文件。
- 而由于在main.c中调用了`mylib.a`静态库中的模块，所以main.o链接时要指明`mylib.a`静态库：`gcc –static –o myproc main.o ./mylib.a`（ `-static`表示静态链接，`-o myproc`表示生成的可执行文件名为myproc）。

##### 符号解析过程

符号解析时有三个集合：

- E：所有目标文件的集合，这些目标文件将被合并以组成可执行文件
- U：当前所有**未解析**的**引用符号**的集合。当符号解析结束时，如果U中还有未解析的符号引用时，则说明符号解析出现了问题。
- D：当前所有定义符号的集合

符号解析过程：

1. 开始E、U、D为空，命令中给出的第一个链接的文件时main.o，所以首先扫描main.o，把它加入E。
2. 在main.o中有符号表。在符号表中myfun1是未定义的符号，所以把myfun1加入U。而main是已定义的符号，所以将main加入D。main.o此时就处理完了。
3. 接着扫描到 mylib.a，将U中所有符号（本例中为myfunc1）与 mylib.a中所有目标模块（myproc1.o和myproc2.o ）依次匹配，发现在myproc1.o中定义了myfunc1 ，所以myproc1.o是需要链接的模块，故myproc1.o加入E。同时，由于myfunc1找到了定义，myfunc1从U转移到D。
4. 在 myproc1.o中发现还有未解析符号printf，将其加到 U。不断在mylib.a的各模块上进行迭代以匹配U中的 符号，但是printf一直得不到解析。此时U中只有一个未解析符号printf，而D中有main和myfunc1。因为模块 myproc2.o没有被加入E中，因而它被丢弃。
5. 接着，扫描默认的库文件libc.a，发现其目标模块printf.o定义了 printf，于是printf也从U移到D，并将 printf.o加入E，同时把它定义的所有符号 加入D，而所有未解 析符号加入U。 **处理完libc.a时，U一定是空的**。

解析结果： E中有main.o、myproc1.o、printf.o及其调用的模块，D中有main、myproc1、printf及其引用的符号，注意：E中无 myproc2.o！

**被链接模块应按调用顺序指定**，如果我们将链接的顺序调换一下：`gcc –static –o myproc ./mylib.a main.o `，结果会：

- 首先，扫描mylib，因是静态库，应根据其中是否存在U中未解析符号对应的定义符号来确定哪个.o被加入E。因为开始U为空，故其中两个.o模块都不被加入E中而被丢弃。
- 然后，扫描main.o，将myfunc1加入U。此时由于静态库已被丢弃，所以直到最后它都不能被解析。

**所以在链接时，我们应该将静态库放在最后**

**符号解析的过程实际上就是**：

- 按照链接命令中的顺序，从左到右扫描文件。

  每遇到一个新的.o 或 .a 中的模块，将其**符号表**中定义的符号加入D，未定义的符号加入U，同时试图用其来解析U中的符号，将U中的所有符号与所扫描的模块相匹配。

  - **如果是.o模块，则可以直接加入E**；
  - 如果是静态库文件，只有匹配的模块才能加入E

  并将被匹配的符号从U移到D。找出未定义的符号，加入U。找出已定义的符号，加入D。

  - 对于.o模块，扫描结束就可以进入下一个文件
  - 对于静态库文件，所有文件全部扫描结束**或者U为空**，都可以进入下一个文件。

  一直扫描到链接命令中的文件序列结束。 

符号解析的过程实际上就是：

- 给外部符号找到定义
- 收集所有已定义的符号（为了在下一步中重定位符号）
- 以及收集所有需要链接的模块（为了在下一步中合并为一个可执行文件）

的**符号绑定**的过程。

`-lxxx=libxxx.a`，所以`gcc -L. libtest.o -lmine`等同于`gcc -L. libtest.o libmine.a`

##### 重定位

汇编器在遇到汇编代码中的助记符时（也就是变量名和函数名），由于汇编器不知道该变量或函数在文件合并后的地址，所以**汇编器只能生成一个假的临时地址**。同时生成一个**重定位条目**，告诉链接器，在链接时需要在这个位置进行重新定位，定位成合并后真正的地址。

- 数据引用的重定位条目在.rel_data节中 
- 指令中引用的重定位条目在.rel_text节中

重定位条目和汇编后的机器代码在可重定位目标 （.o）文件中。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210731193031475.png" alt="image-20210731193031475" style="zoom:67%;" />

编译器根据语法规则来编译，**它可以知道所在模块中的所有内容**，不管是外部符号还是局部符号，它都知道这些符号的定义是什么（如果使用外部符号需要在模块内用extern声明），相对位置在哪，但是它不知道链接成可执行文件后这些符号在虚拟内存空间中的绝对地址。**编译阶段无法确定任何引用的地址（不管是外部符号还是本地符号），全部使用假的临时地址**，对所有的引用都生成一个重定位条目，等待链接时重定位地址。

**注意！编译器需要根据符号的定义来判断语法是否正确，编译是否通过，它并不是不知道符号的定义在哪。它只是不知道符号在虚拟内存空间中的绝对地址！**

重定位条目中有重定位信息，反映出

- 需要重定位的符号引用的位置（`offset`，在**节内**（.data节或.text节）的偏移位置）
- 绑定的定义符号名（`symbol`，在符号表中的索引）
- 重定位类型（`type`）：绝对地址（也就是把**可执行文件**中的符号在**虚拟地址空间**中的地址直接填入）或相对地址（符号地址相对这条指令的偏移））

用命令`readelf -r main.o`可显示main.o中的重定位条目

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210731224126165.png" alt="image-20210731224126165" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210801161050927.png" alt="image-20210801161050927" style="zoom:67%;" />

符号解析完成后，可进行重定位工作，分三步 

- 合并相同的节 

  将集合E的所有目标模块中相同的节合并成新节。例如，所有.text节合并作为可执行文件中的.text节 

- 对定义符号进行重定位（确定符号定义的地址）

  **确定新节中所有定义符号在虚拟地址空间中的地址**。例如，为函数确定首地址，进而确定每条指令的地址，为变量确定首地址 

  完成这一步后，每条指令和每个全局或局部变量都可确定地址 

- 对引用符号进行重定位（修改符号引用的地址） 

  修改.text节和.data节中对每个符号的引用（地址）。**需要用到在.rel_data和.rel_text节中保存的重定位信息**

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。



## 共享库和动态链接

静态库有一些缺点：

- 库函数（如printf）被包含在每个运行进程的代码段中（因为所有调用静态库函数的文件，都需要包含函数所在的.o模块），对于并发运行上百个进程的系统，造成极大的主存资源浪费
- 库函数（如printf）被合并在可执行目标文件中，磁盘上存放着数千个可执行文件，每个可执行文件都包含相同的库函数的代码，造成磁盘空间的极大浪费
- 静态链接时，静态库函数必须合并到可执行目标文件中，如果静态库函数修改了，需要重新编译和链接，更新到可执行文件中。更新困难，使用不便。

解决方案：Shared Libraries （共享库），Window称其为**动态链接库（Dynamic Link Libraries，.dll文件）** Linux称其为**动态共享对象（ Dynamic Shared Objects, .so文件）**

- 共享库是包含很多.o模块的文件，每个模块都包含代码和数据（与静态链接相同）
- 把公共的，所有程序可以调用的，共享的代码从程序中分离出来，**磁盘和内存中都只有一个备份**（比如printf函数，不包含在调用它的程序当中，专门存放在一个共享库文件中） 
- 可以动态地在调用共享库的程序**装入时或运行时被加载并链接** 

所以，共享模块在内存中只有一个备份，被所有进程共享，**节省内存空间**。共享库文件在磁盘中也只有一个备份，被所有程序共享链接，**节省磁盘空间**。共享库升级时，被自动加载到内存和程序动态链接，**使用方便**。

动态链接可以按以下两种方式进行：

- 在第一次加载并运行时进行 (load-time linking).

  Linux通常由动态链接器(ld-linux.so)自动处理，标准C库 (libc.so) 通常按这种方式动态被链接

- 在已经开始运行后进行(run-time linking).

  在Linux中，通过调用 dlopen()等接口来实现，分发软件包、构建高性能Web服务器等

### 自定义一个动态共享库文件

`gcc –shared –fPIC –o mylib.so myproc1.o myproc2.o`：`–shared –fPIC`表示生成位置无关的共享代码库文件

- PIC：Position Independent Code，位置无关代码
  - 保证共享库代码的位置可以是不确定的 
  - 即使共享库代码的长度发生变化，也不会影响调用它的程序

#### 加载时动态链接

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210801101959084.png" alt="image-20210801101959084" style="zoom:67%;" />

把main.o和mylib.so进行静态链接，将这些文件中的**重定位信息和符号表信息**进行静态链接，生成可执行文件myproc。这个可执行文件只是一个**部分链接**的可执行文件，因为链接的对象是.so共享库文件，所以**并不会把代码链接进可执行文件中**，只是把重定位信息和符号表信息加载到可执行文件中。

当可执行文件被加载到内存中时，调用execve加载器，加载器最终调用动态链接器（ld-linux.so），动态加载器会把之前部分链接的可执行文件myproc和共享库libc.so、mylib.so中的printf.o和myproc1.o代码和数据进行链接。动态链接器生成的重定位以后的代码，实际上是放在存储空间中的，不会放在磁盘中。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210801103429432.png" alt="image-20210801103429432" style="zoom:67%;" />

**注意！以上所有的讨论全部都是不涉及include的，include早在预处理阶段就已经完成了，将include的内容直接插入到程序中。**

### 一、头文件

头文件里面放的就是关于函数，变量，类的"声明"(对函数来说，也叫函数原型)了。记着，是"声明"，不是"定义"。所以，最好不要在头文件里定义什么东西。比如全局变量：

```c
/*xx头文件*/
#ifndef _XX_头文件.H
#define _XX_头文件.H
int A;
#endif
```

那么，很糟糕的是，这里的 int A 是个全局变量的定义，所以如果这个头文件被多次引用的话，你的A会被重复定义，显然语法上错了。只不过有了这个 #ifndef 的条件编译，所以能保证你的头文件只被引用一次，不过也许还是不会出岔子，但若多个 c 文件包含这个头文件时还是会出错的，因为宏名有效范围仅限于本c源文件，所以在这多个 c 文件编译时是不会出错的，但在链接时就会报错，说你多处定义了同一个变量:

```
Linking...
incl2.obj : error LNK2005: "int glb" (?glb@@3HA) already defined in incl1.obj
Debug/incl.exe : fatal error LNK1169: one or more multiply defined symbols found
```

### 二、extern

变量前有extern不一定就是声明，而变量前无extern就只能是定义。注：定义要为变量分配内存空间；而声明不需要为变量分配内存空间。

下面分变量和函数两类来说：

**（1）变量**

尤其是对于变量来说:

```c
extern int a; // 声明一个全局变量 a
int a; // 定义一个全局变量 a
extern int a =0 ; // 定义一个全局变量 a 并给初值。
int a =0;    // 定义一个全局变量 a, 并给初值，
```

第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。

但是定义只能出现在一处。也就是说，不管是int a；还是extern int a=0；还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。

当你要引用一个全局变量的时候，你就必须要声明，extern int a; 这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。

**（2）函数**

函数，对于函数也一样，也是定义和声明，定义的时候用extern，说明这个函数是可以被外部引用的，声明的时候用extern说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体(还有以分号结尾)，所以函数定义和声明时都可以将extern省略掉，反正其他文件也是知道这个函数是在其他地方定义的，所以不加extern也行。

比如：

```c
/*某cpp文件*/
int fun(void)
{
      return 0;
}
```

很好，我们定义了一个全局函数:

```c
/*另一cpp文件*/
int fun(void);
```

我们对它做了个声明，然后后面就可以用了, 加不加extern都一样, 我们也可以把对 fun 的声明放在一个头文件里，最后变成这样:

```c
/*fun.h*/
int fun(void);   //函数声明，所以省略了extern，完整些是extern int fun(void);
/*对应的fun.cpp文件*/
int fun(void)
{
     return 0;
}//一个完整的全局函数定义，因为有函数体，extern同样被省略了。
```

然后，一个客户，一个要使用你的fun的客户，把这个头文件包含进去，ok，一个全局的声明。没有问题。

**总结：**

对变量而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的变量，方法有2种：(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的变量声明，也即在这个头文件中必须用extern声明该变量，否则，该变量又被定义一次。

对函数而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的函数，方法有2种：(1)在A文件中用extern声明在B文件中定义的函数(其实，也可省略extern，只需在A文件中出现B文件定义函数原型即可)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，在头文件中函数可以不用加extern。

