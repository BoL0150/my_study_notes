# 南京大学ics学习笔记：异常控制流

程序的**正常**执行顺序有两种：

1. 按顺序取下一条指令执行 
2. 通过CALL/RET/Jcc/JMP等指令跳转到转移目标地址处执行 

**CPU所执行的指令的地址序列称为CPU的控制流**，通过上述两种方式得到的控制流为**正常控制流**。

## 异常控制流

CPU会因为遇到**内部异常**或**外部中断**等原因而打断程序的正常控制流，转去执行操作系统提供的针对这些特殊事件的处理程序。

由于某些特殊情况**引起用户程序的正常执行被打断**所形成的**意外控制流**称为**异常控制流**（Exceptional Control of Flow，ECF）。

异常控制流形成的原因：

- 内部异常（缺页（页表中V=0，即我要找的页不在内存中，无法取指，所以程序也无法运行下去。**用户程序无法直接访问磁盘，需要转到操作系统处理缺页**。由操作系统去读磁盘，把缺失的页装入内存，更新页表。然后从缺页处理程序返回，**回来以后继续执行之前的程序**）、越权、越级、整除0、溢出等）发生在硬件层
- 外部中断（Ctrl-C、打印缺纸、DMA结束等） 发生在硬件层
- 进程的上下文切换（发生在操作系统层） 
- 一个进程直接发送信号给另一个进程（发生在应用软件层）

### 程序和进程

- **程序（program）**指按某种方式组合形成的代码和数据集合，代码即是机器指令序列，因而程序是一种**静态**概念。 

- **进程（ process）**指程序的**一次运行过程**。更确切说，进程是具有独立功能的**一个程序关于某个数据集合**的一次运行活动，因而进程具有**动态**含义 。**同一个程序处理不同的数据就是不同的进程**

  - 进程是OS对CPU执行的程序的**运行过程**的一种抽象。进程有自己的**生命周期**，它由于任务的启动而创建，随着任务的完成（或终止）而消亡，**它所占用的资源也随着进程的终止而释放**。 

  - 一个可执行目标文件（即程序）可被加载执行多次，也即，**一个程序可能对应多个不同的进程**。

    例如，用word程序编辑一个文档时，相应的用户进程就是 winword.exe，如果多次启动同一个word程序，就得到多 个winword.exe进程，**处理不同的数据**。

操作系统（管理任务）以外的都属于“用户”的任务。**计算机处理的所有“用户”的任务由进程完成**。 为强调进程完成的是用户的任务，通常将进程称为**用户进程**。 计算机系统中的任务通常就是指进程。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210802201714728.png" alt="image-20210802201714728" style="zoom: 50%;" />

**“进程”的引入简化了程序员的编程**以及语言处理系统的处理 ，即简化了编程、编译、链接、共享和加载等整个过程。造成一种整个处理器和存储空间都为我们的程序服务的假象，我们的代码可以随便放在存储空间的任何一个位置，CPU可以按照我们需要的流程执行，程序员不需要管其他的程序。

### 逻辑控制流与物理控制流

对于确定的数据集，某进程指令执行地址序列是确定的 ，称为进程的**逻辑控制流**。对于**单处理器系统**，进程会**轮流**使用处理器，即**处理器的物理控制流由多个逻辑控制流组成**。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210802203329929.png" alt="image-20210802203329929" style="zoom:67%;" />

**逻辑控制流不会因被其他进程打断而改变， 还能回到原被打断的“断点”处继续执行**。不同进程的逻辑控制流在时间上交错或重叠的情况称为**并发（concurrency）**

**OS**根据在shell中输入的可执行文件名，在磁盘中找到对应的可执行文件，把这个可执行文件加载入内存。OS通过处理器调度让处理器**轮流**执行多个进程。**实现不同进程中指令交替执行的机制称为进程的上下文切换（context switching）**，**也就是指把正在运行的进程换下，换一个新的进程到处理器执行**。

在一个进程的生命周期中，可能会有其他不同进程在处理器上交替运行！

处理器调度等事件会引起用户进程正常执行被打断，因而形成**异常控制流**。 进程的**上下文切换**机制很好地解决了这类异常控制流，实现了从一个进程安全切换到另一个进程执行的过程。

进程的**物理实体（代码和数据等）**和**支持进程运行的环境**合称为进程的上下文。 

- 由进程的程序块、数据块、运行时的堆和用户栈（两者通称为用户堆栈）等组成的用户空间信息被称为**用户级上下文**（即进程的物理实体）

- 由进程标识信息、进程现场信息、进程控制信息和系统内核栈等组成的内核空间信息被称为**系统级上下文**；（即支持进程运行的环境）

  - 处理器中各寄存器的内容被称为**寄存器上下文** （也称硬件上下文），即进程的现场信息。 

  - 在进行进程上下文切换时，操作系统把换下进程的寄存器上下文保存到系统级上下文中的现场信息位置。 

- **用户级上下文**地址空间和**系统级上下文**地址空间一起构成了一个进程的整个存储器映像

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210803100922944.png" alt="image-20210803100922944" style="zoom:50%;" />

**上下文切换发生在OS调度一个新进程到处理器上运行时**，它需要完成以下三件事:

1. 将当前处理器的寄存器上下文保存到当前进程的系统级上下文的现场信息中;
2. 将新进程系统级上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中;
3. 将控制转移到新进程执行。

这里，一个重要的上下文信息是PC的值，当前进程被打断的断点处的PC作为寄存器上下文的一部分被保存在进程现场信息中，**这样，下次该进程再被调度到处理器上执行时，就可以从其现场信息中获取到断点处的PC，从而从上次的断点处继续执行**。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210803142224613.png" alt="image-20210803142224613" style="zoom:67%;" />

### 进程的存储器映射

每个用户进程具有独立的私有虚拟地址空间 ，**可执行文件中的符号定义和引用的地址实际上是可执行文件映射到虚拟地址空间中的地址**。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210803103538932.png" alt="image-20210803103538932" style="zoom: 67%;" />

整个虚拟地址空间分为两大部分：内核虚拟存储空间（简称内核空间）和进程虚拟存储空间（简称用户空间）。在采用虚拟存储器机制的系统中，**每个程序的可执行目标文件都被映射到同样的虚拟地址空间上**，也即，所有用户进程的虚拟地址空间是一致的， 只是在相应的只读区域和可读写数据区域中映射的信息不同而已。

#### 进程描述符

Linux将进程对应的虚拟地址空间组织成若干**“区域(area)”**的集合，这些区域是指在虚拟地址空间中的一个有内容的**连续区块( 即已分配的)**（**其实就是只读代码段、可读写数据段、运行时堆、用户栈、共享库等区域**）。每个区域可被划分成若干个大小相等的虚拟页面，每个存在的虚拟页面一定属于某个区域。

OS要对进程进行管理，为进程分配主存空间（从磁盘调取虚页到内存由OS完成），**OS必须要知道进程的地址空间中每个区域的分布**。

Linux内核为每个进程维护了一个**进程描述符**，数据类型为task_ struct 结构。**task_struct 中记录了内核运行该进程所需要的所有信息**，例如，进程的PID、指向用户栈的指针、可执行目标文件的文件名等。**task_struct 结构可对进程虚拟地址空间中的区域进行描述。**

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210803162958567.png" alt="image-20210803162958567" style="zoom:67%;" />

mm_struct中还有一个字段mmap,它指向一个由vm_area_struct 构成的**链表表头**。**Linux 采用链表方**
**式管理用户空间中的区域，使得内核不用记录那些不存在的“空洞”页面**。

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210803163223523.png" alt="image-20210803163223523" style="zoom: 67%;" />

每个vm_area_struct实际上是由mmap()函数生成的，实际上是一个系统调用。

```c
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); 
```

 **读取可执行文件中的程序头表而获得mmap的实参**。

#### Linux中的页故障处理

当CPU中的MMU在对某地址VA进行地址转换时，若检测到页故障（**页表中访问到V=0的表项**），则转由**操作系统内核**进行页故障处理。

- Linux 内核可根据上述对虛拟地址空间中各区域的描述，将VA与vm_area_struct 链表中每个vm_ start 和vm_ end 进行比较，以判断VA是否属于“空洞”页面。

  - 若是，则发生“段故障(segmentationfault)";

  - 若不是，则再判断所进行的操作是否和所在区域的访问权限(由vm_prot 描述)相符。

    - 若不相符，例如，假定VA属于代码区，访问权限为PROT_EXE ( 可执行)，但对地址VA的操作是“写”，那么就发生了**“访问越权”**;

      假定在用户态下访问属于内核的区域，访问权限为PROT_NONE (不可访问)，那么就发生了**“访问越级”**。

  段故障、访问越权和访问越级都会导致终止当前进程。

- 若不是上述几种情况，则内核判断发生了正常的缺页异常，此时，只需在主存中找到一个空闲的页框，从硬盘中将缺失的页面装人主存页框中。若主存中没有空闲页框，则根据页面替换算法，选择某个页框中的页面交换出去，然后从硬盘上装入缺失的页面到该页框中。

**从页故障处理程序返回后，将回到发生缺页的指令重新执行**。

#### 存储管理全局

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20210803165648400.png" alt="image-20210803165648400" style="zoom:67%;" />

**磁盘中的可执行文件中的代码和数据与主存中的页框不能直接映射**，靠**虚拟地址空间**进行映射

- 在生成可执行文件时，通过程序头表，先描述可执行文件与虚拟地址空间之间的映射 
- 生成一个进程时，通过mmap，生成vm_area_struct ，对进程虚拟内存空间中的区域进行描述

- 在进程执行时，生成一个页表，描述虚拟地址空间与主存地址空间之间的映射

