# SRCNN

## HDF5文件：

HDF(Hierarchical Data Format层次数据格式)是一种设计用于存储和组织大量数据的文件格式，h5是HDF5文件格式的后缀。h5文件对于存储大量数据而言拥有极大的优势

<img src="C:\Users\李博\Desktop\mynotes\ai\SRCNN.assets\image-20231019215935477.png" alt="image-20231019215935477" style="zoom:50%;" />

H5中有两个核心的部分：组“group”和数据集“dataset”。 一个h5文件就是 “dataset” 和 “group” 二合一的容器。

 dataset ：简单来讲类似数组组织形式的数据集合，像 numpy 数组一样工作，一个dataset即一个numpy.ndarray。具体的dataset可以是图像、表格，甚至是pdf文件和excel。

group：包含了其它 dataset(数组) 和 其它 group ，像字典一样工作。

一个h5文件被像linux文件系统一样被组织起来：dataset是文件，group是文件夹，它下面可以包含多个文件夹(group)和多个文件(dataset)。

## 色彩空间：

1. 通常情况下，彩色图像使用R、G、B三个通道表示，这种通过三基色可以到其它的各种颜色，但是具体是哪种颜色，我们就无从可知，如果我想知道（R，G，B）三元组具体什么颜色可以用HSV颜色空间表示。

2. HSV即色相(Hue)，饱和度(Saturation)，明亮度（Lightness），又称为HSB，其中B即英语Brightness。

   - 色相（H）是色彩的基本属性，就是平常所说的颜色，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。
   - 饱和度（S）是指色彩的纯度，越高色彩越纯，越低则逐渐变灰，取0-100%的数值。
   - 明度（V），取0-100%。

3. YCbCr有的时候会被写作：YCBCR，是色彩空间的一种，

   - Y表示颜色的明亮度和浓度，也可叫灰度阶（所以通过RGB转换YCBCR提取Y分量也可以得到灰度图像）
   - Cb：表示颜色的蓝色浓度偏移量即RGB输入信号蓝色部分与RGB信号亮度值之间的差异。
   - Cr：表示颜色的红色浓度偏移量即RGB输入信号红色部分与RGB信号亮度值之间的差异。

   ![img](C:\Users\李博\Desktop\mynotes\ai\SRCNN.assets\220px-Barns_grand_tetons_YCbCr_separation.jpg)

   上图中四部分依次是彩色图像的原图，彩色影像只有Y成分的图、只有Cb成分的图、和只有Cr成分的图。同时注意的是**只有Y成分的图基本等同于彩色图像的灰度图。**

如何获得图像的亮度？

1. 将彩色度或转化为灰度图，这样每个像素值都是灰度值，也就是亮度值
2. **将RGB三色图转化YCbCr彩色空间，第一通道(Y成分)就是亮度值**

选择YCbCr的原因：**因为我们感兴趣的不是颜色变化(存储在 CbCr 通道中的信息)而只是其亮度(Y 通道);根本原因在于相较于色差，人类视觉对亮度变化更为敏感**。

## SRCNN的过程：

1. 先将低分辨率图像使用双三次差值放大至目标尺寸（如放大至2倍、3倍、4倍），此时仍然称放大至目标尺寸后的图像为低分辨率图像(Low-resolution image)，即图中的输入(input)；

   - 从数字图像的角度来说，低分辨率图像的矩阵形状小于高分辨率图像的矩阵，而网络要求输入和输出的大小一样，所以需要先把低分辨率图像使用双三次插值法放大到与高分辨率图像形状相同，此时得到的图像从定义上来说就是高分辨率图像了，因为它的分辨率与我们期望的图像分辨率相同，但是这不是我们所期待的结果，因为它并没有变清晰。所以我们还认为放大后的图像是低分辨率的图像，需要经过网络处理才能得到高分辨率图像

   - 双三次插值即BiCubic插值 ， 假设源图像A大小为m * n，缩放K倍后的目标图像B的大小为M*N，即K=M/m。A的每一个像素点是已知的，B是未知的，我们想要求出目标图像B中每一像素点(X,Y)的值，必须先找出像素(X,Y)在源图像A中对应的像素(x,y)，再根据源图像A距离像素(x,y)**最近**的16个像素点作为计算目标图像B(X,Y)处像素值的参数，利用BiCubic基函数求出16个像素点的权重，图B像素(x,y)的值就等于16个像素点的加权叠加。

     三次运算可以得到更接近高分辨率图像的放大效果，但也导致了运算量的急剧增加

2. 将低分辨率图像输入三层卷积神经网络

   <img src="C:\Users\李博\Desktop\mynotes\ai\SRCNN.assets\image-20231016212230614.png" alt="image-20231016212230614" style="zoom: 67%;" />

   - 特征图：就是一个二维的矩阵，每个元素是一个feature。所以如果有64个卷积核，那么就会输出64张特征图

首先使用双三次插值将其放大到所需的大小，这是我们执行的唯一预处理

三层卷积神经网络在概念上由三个操作组成：

1. 补丁（patch）提取和表示：该操作从低分辨率图像Y中提取（重叠）补丁。所谓的补丁就是卷积核所卷积的区域，卷积核从这篇区域中提取信息，并将每个补丁表示为高维向量（向量的维度是卷积核的输出通道数）。这些向量组成一组特征图，其数量等于向量的维数。
2. 非线性映射：该操作是每个高维向量（维度是64）到另一个高维向量（维度是32）的非线性映射。每个映射得到的向量就是高分辨率的补丁。 
3. 重建：该操作聚合高分辨率补丁表示以生成最终的高分辨率图像。

## 数据集的准备

**训练集：**SRCNN的训练集使用91-images。

1、数据增广（augment）：为了提高模型的泛化能力，对数据集进行了增广。方法是：将原始图片先进行**0°、90°、180°、270°**旋转，然后缩放**0.6、0.7、0.8、0.9、1.0**，得到20倍于91-images的数据集，共1820张HR图片。

2、准备LR-HR数据对：

- 将HR图片裁剪为scale的整数倍。（因为后面需要将HR图片压缩scale倍，为了保证HR可以被scale整除，所以需要先把HR图片剪裁，使得它变成scale的整数倍）

- 将HR图片从RGB空间转换到YCbCr空间，之后的训练仅使用YCbCr的Y通道。

  - 由于输入网络的是Y通道，因此在测试时想要得到完整的图片，需要将输出的Y通道与输入前的CbCr组合成完整的YCbCr图像，然后转换成RGB

- 使用‘bicubic’插值方法将HR图片缩小scale倍，这次缩小的目的是得到低分辨率的图像。

- 再使用相同方法将低分辨率图像放大scale倍得到与HR尺寸相同，但经过两次‘bicubic’插值的LR（低分辨率）的图片。这次放大的目的是让网络的输入图像和输出图像的大小一样

- 在**scale=3**的情况下，使用**stride=14，size=33**，对LR和HR图片进行裁剪，得到对应位置的33*33尺寸的sub-images，LR和HR对应位置的sub-images形成一对数据对。

- 由于网络在训练时没有进行padding，所以经过卷积后图片尺寸会变小，根据计算公式：

  ![image-20231016222017450](C:\Users\李博\Desktop\mynotes\ai\SRCNN.assets\image-20231016222017450.png)

  输入33 * 33，经过卷积核大小分别为9、1、5，stride=1的卷积后，得到的输出大小为21*21。因此取HR的sub-images中心21 * 21像素作为label，这样就得到了训练时的数据：<img src="C:\Users\李博\Desktop\mynotes\ai\SRCNN.assets\image-20231016222145979.png" alt="image-20231016222145979" style="zoom: 80%;" />

损失函数选择MSE损失，mse损失为一个batch的损失均值。**选用MSE损失是为了获得高的峰值信噪比PSNR（MSE和PSNR的计算过程相似），而PSNR是常用的图像高分辨率算法的评估指标**。

**验证集：**验证集使用Set5。

与训练集的处理相同，但是可以不用裁剪sub-images，直接将完整的图片作为输入，这样验证的结果更接近实际的测试结果。

**测试集：**测试集使用Set5、Set14

- 测试时的计算公式是PSNR。计算PSNR时，需要将原始的高清图片hr的四个边缘各裁剪scale个像素，由于在测试时会进行padding，因此输出的sr和hr尺寸相同，所以为了计算PSNR，也要对sr进行相同的剪裁。

注意，测试时和训练时的行为不一样，**训练时是对训练集中的图像先使用双三次差值缩小到低分辨率尺寸**，**再将其放大到目标放大尺寸**，最后切割成诸多33×33图像块作为训练数据，作为标签数据的则为图像中心的21×21图像块

而**测试时是直接输入完整图像。要求输出的图像与输入的图像大小相同**，但是由于训练时得到的实际上是除去四周(33-21)/2=6像素外的图像，若直接采用训练时的设置（无padding），得到的图像最后会减少四周各6像素（如插值放大后输入512×512，输出500×500）。因此**在测试时每一层卷积都进行了padding（卷积核尺寸为1×1的不需要进行padding）。这样保证插值放大后输入与输出尺寸的一致性**。