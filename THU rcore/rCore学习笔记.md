# rCore学习笔记

# os的系统调用接口

操作系统内核是一个需要提供各种服务的软件，其服务对象是应用程序

应用程序需要访问操作系统获得操作系统的服务，这就需要通过操作系统的接口才能完成。操作系统的接口形式就是上一节提到的**应用程序二进制接口** (ABI, Application Binary Interface)

> **API 与 ABI 的区别**
>
> 应用程序二进制接口 ABI 是不同二进制代码片段的连接纽带。ABI 定义了二进制机器代码级别的规则，主要包括基本数据类型、通用寄存器的使用、参数的传递规则、以及堆栈的使用等等。ABI 与处理器和内存地址等硬件架构相关，是用来约束链接器 (Linker) 和汇编器 (Assembler) 的。在同一处理器下，基于不同高级语言编写的应用程序、库和操作系统，如果遵循同样的 ABI 定义，那么它们就能正确链接和执行。
>
> 应用程序编程接口 API 是不同源代码片段的连接纽带。API 定义了一个源码级（如 C 语言）函数的参数，参数的类型，函数的返回值等。因此 API 是用来约束编译器 (Compiler) 的：一个 API 是给编译器的一些指令，它规定了源代码可以做以及不可以做哪些事。API 与编程语言相关，如 libc 是基于 C 语言编写的标准库，那么基于 C 的应用程序就可以通过编译器建立与 libc 的联系，并能在运行中正确访问 libc 中的函数。

操作系统对计算机硬件重要组成的抽象和虚拟化，使得应用程序只需基于对简单的抽象概念的访问来到达对计算机系统资源的使用：

- 文件 (File) 是外设的一种抽象和虚拟化。特别对于存储外设而言，文件是持久存储的抽象。
- 地址空间 (Address Space) 是对内存的抽象和虚拟化。
- 进程 (Process) 是对计算机资源的抽象和虚拟化。而其中最核心的部分是对CPU的抽象与虚拟化。

操作系统是管理一台机器的硬件和资源，向这台机器上的应用软件提供服务的软件

分布式系统是管理多台机器的软件，向构建在这些机器上的应用软件提供服务

# 操作系统抽象

## 执行环境

1. 在寒武纪时期的计算机系统中，还没有操作系统，所以对于直接运行在裸机硬件上的应用程序而言，其执行环境是 *计算机的硬件* （现在直接运行在裸机硬件 (Bare-Metal) 上的操作系统，其执行环境也是 *计算机的硬件*）
2. 在第二个阶段，应用程序下面形成了一层比较通用的函数库，这使得应用程序不需要直接访问硬件了，它所需要的功能（比如显示字符串）和资源（比如一块内存）都可以通过函数库的函数来帮助完成。**应用程序的执行环境就变成了 *函数库* -> *计算机硬件*** ，而这时函数库的执行环境就是计算机的硬件。
3. 在第三个阶段，操作系统取代了函数库来访问硬件，函数库通过访问操作系统的系统调用服务来进一步给应用程序 提供丰富的功能和资源。**应用程序的执行环境就变成了 *函数库* -> *操作系统内核* -> *计算机硬件***
4. 在后面又出现了基于 Java 语言的应用程序，**在函数库和操作系统之间，多了一层 Java 虚拟机**，此时 **Java 应用 程序的执行环境就变成了 *函数库* -> *Java 虚拟机* -> *操作系统内核* -> *计算机硬件***
5. 在云计算时代，在传统操作系统与 计算机硬件之间多了一层 Hypervisor/VMM ，此时应用程序的执行环境变成了 *函数库* -> *Java 虚拟机* -> *操作系统内核* -> *Hypervisor/VMM* -> *计算机硬件* 。

这里可以看到，随着软件需求的多样化和复杂化， **执行环境的层次** 也越来越多。

CPU在执行过程中，可以在不同层次的执行环境之间切换，这称为 **执行环境切换** 。**执行环境切换主要是通过特定的 API 或 ABI 来完成的**，这样不同执行环境的软件就能实现数据交换与互操作，而且还保证了彼此之间有清晰的隔离。

![image-20220403172425710](https://raw.githubusercontent.com/BoL0150/image2/master/image-20220403172425710.png)

### 异常控制流

应用程序在执行过程中，如果发出系统调用请求，或出现外设中断、CPU 异常等情况，处理器执行的前一条指令和后一条指令将会位于两个完全不同的位置，即不同的执行环境 。比如，前一条指令还在应用程序的代码段中，后一条指令就跑到操作系统的代码段中去了，这就是一种控制流的“突变”，即**控制流脱离了其所在的执行环境，并产生 执行环境的切换**。 我们把这种“突变”的控制流称为 **异常控制流** (ECF, Exceptional Control Flow) 。

**应用程序 *感知* 不到这种异常的控制流情况**，这主要是由于操作系统把这种情况 *透明* 地进行了执行环境的切换和对各种异常情况的处理，让应用程序从始至终地 *认为* 没有这些异常控制流的产生。

简单地说， **异常控制流 是处理器在执行过程中的突变，其主要作用是通过硬件和操作系统的协同工作来响应处理器状态中的特殊变化**。比如当应用程序正在执行时，产生了时钟外设中断，导致操作系统打断当前应用程序的执行，转而进入 **操作系统** 执行环境去处理时钟外设中断。处理完毕后，再回到应用程序中被打断的地方继续执行。

对于异常控制流的上下文保存与恢复，主要是通过 CPU 和操作系统（手动编写在栈上保存与恢复寄存器的指令）来协同完成；对于函数转移控制流的上下文保存与恢复，主要是通过编译器（自动生成在栈上保存与恢复寄存器的指令）来帮助完成的

在操作系统中，需要处理三类异常控制流：外设中断 (Device Interrupt) 、陷入 (Trap) 和异常 (Exception，也称Fault Interrupt)

- 外设 **中断** (Interrupt) 由外部设备引起的外部 I/O 事件如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。产生中断后，操作系统需要进行中断处理来响应中断请求
- **异常** (Exception) 是在处理器执行指令期间检测到不正常的或非法的内部事件（如除零错、地址访问越界）。产生异常后，操作系统需要进行异常处理
- **陷入** (Trap) 是在程序中使用请求操作系统服务的系统调用而引发的有意事件。产生陷入后，操作系统需要执行系统调用服务来响应系统调用请求

> **在不同的书籍中，对于中断 、陷入和异常的定义会有一些差别**。有的书籍把中断、陷入和异常都统一为一种中断，表示程序的当前控制流被打断了，要去执行不属于这个控制流的另外一个没有程序逻辑先后关系的控制流；也有书籍把这三者统一为一种异常，表示相对于程序的正常控制流而言，出现了的一种没有程序逻辑先后关系的异常控制流。甚至也有书籍把这三者统一为一种陷入，表示相对于程序的正常控制流而言，CPU会陷入到操作系统内核中去执行。
>
> 在 RISC-V 的特权级规范文档中，异常指的是由于 CPU 当前指令执行而产生的异常控制流，中断指的是与 CPU 当前指令执行无关的异常控制流，中断和异常统称为陷入。**当中断或异常触发时，我们首先进行统一的陷入处理流程**，随即根据 `mcause/scause` 等寄存器的内容判定目前触发的是中断还是异常，再对应进行处理。

## 进程

一个进程是一个具有一定独立功能的程序**在一个数据集合上的一次动态执行过程**

## 地址空间

操作系统通过处理器中的内存管理单元 (MMU, Memory Management Unit) 硬件的支持而**给应用程序和用户提供一个大的（可能超过计算机中的物理内存容量）、连续的（连续的地址空间编址）、私有的（其他应用程序无法破坏）的存储空间**。这需要操作系统**将内存和外存结合起来管理**，为用户提供一个容量比实际内存大得多的虚拟存储器，并且需要操作系统为应用程序分配内存空间，使用户存放在内存中的程序和数据彼此隔离、互不侵扰

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20220403182006789.png" alt="image-20220403182006789" style="zoom: 33%;" />

## 文件

文件可理解为存放在持久存储介质（比如硬盘、光盘、U盘等）上，方便应用程序和用户读写的数据。**以磁盘为代表的持久存储介质的数据访问单位是一个扇区或一个块，而在内存中的数据访问单位是一个字节或一个字**。这就需要操作系统通过文件来屏蔽磁盘与内存差异，尽量以内存的读写方式来处理持久存储的数据。当处理器需要访问文件中的数据时，可通过操作系统把它们装入内存。文件管理的任务是有效地支持文件的存储、 检索和修改等操作。

**把文件看成是对外设的一种统一抽象，应用程序通过基本的读写操作来完成对外设的访问**

# 操作系统的特征

操作系统具有五个方面的特征：虚拟化 (Virtualization)、并发性 (Concurrency)、异步性、共享性和持久性 (Persistency)

### 内存虚拟化

程序员在写应用程序的时候，**不用考虑其程序的起始内存地址要放到计算机内存的具体某个位置**，而是用字符串符号定义了各种变量和函数，直接在代码中便捷地使用这些符号就行了。这是由于操作系统建立了一个 *地址固定* ， *空间巨大* 的虚拟内存给应用程序来运行，这是 **内存虚拟化**。进一步可以分为：

- **内存地址虚拟化** ：这里的每个符号在运行时是要对应到具体的内存地址的。这些内存地址的具体数值是什么？程序员不用关心。为什么？因为编译器会自动帮我们把这些符号翻译成虚拟地址，形成可执行程序。
- **内存大小虚拟化**：如果物理内存不够用，可以将物理内存中最近用得少的物理页换到磁盘上缓存起来，这样空闲空间就大了，从而支持比实际物理内存更大的内存空间

**操作系统与应用程序之间的数据交换方式**：

- 系统调用时根据 ABI 规定在（比如）寄存器中传递参数
- 复制数据：在内核占用的空间和用户占用的空间之间互相复制数据，如读写文件的时候从应用程序给出的缓冲区复制写的数据，或者复制读的数据到缓冲区
- （共享内存空间：如 io_uring）

# 应用程序与基本执行环境

生成应用程序二进制执行代码所依赖的是以 **编译器** 为主的开发环境；运行应用程序执行码所依赖的是以 **操作系统** 为主的执行环境。

## 创建运行rust程序

我们使用 Cargo 工具来创建一个 Rust 项目

```bash
$ cargo new os --bin
```

我们加上了 `--bin` 选项来告诉 Cargo 我们创建一个可执行程序项目而不是函数库项目。此时，项目的文件结构如下：

```bash
$ tree os
os
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
```

其中 `Cargo.toml` 中保存着项目的配置，包括作者的信息、联系方式以及库依赖等等。源代码保存在 `src` 目录下，目前为止只有 `main.rs` 一个文件

进入 os 项目根目录下，利用 Cargo 工具即可一条命令实现构建并运行项目：

```bash
$ cargo run # 构建并运行项目
   Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)
    Finished dev [unoptimized + debuginfo] target(s) in 1.15s
     Running `target/debug/os`
Hello, world!
```

```bash
$ cargo build # 编译项目
```

我们也可以直接创建一个rust文件，并编译运行

```bash
$ vim main.rs
$ rustc main.rs # 编译
$ ./main # 运行
```

## 应用程序执行环境

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20220404122300879.png" alt="image-20220404122300879" style="zoom:50%;" />

我们的应用位于最上层，**它可以通过调用编程语言提供的标准库或者其他三方库对外提供的功能强大的函数接口**，使得仅需少量的源代码就能完成复杂的功能。我们在打印 `Hello, world!` 时使用的 `println!` 宏正是由 Rust 标准库 std 和 GNU Libc 库等提供的。

**Hello, world! 用到了哪些系统调用？**

从之前的 `cargo run` 的输出可以看出之前构建的可执行文件是在 target/debug 目录下的 os 。在 Ubuntu 系统上，可以通过 `strace` 工具来运行一个程序并输出程序运行过程当中向内核请求的所有的系统调用及其返回值。我们只需输入 `strace target/debug/os` 即可看到一长串的各种系统调用。

其中，与 `Hello, world!` 应用实际执行相关的只有两个系统调用：

```bash
# 输出字符串
write(1, "Hello, world!\n", 14)         = 14
# 程序退出执行
exit_group(0)
```

## 平台与目标三元组

对于一份用某种编程语言实现的应用程序源代码而言，编译器在将其通过编译、链接得到可执行文件的时候需要知道程序要在哪个 **平台** (Platform) 上**运行**。**这里平台主要是指 CPU 类型、操作系统类型和标准运行时库的组合**。

- 如果用户态基于的内核不同，会导致系统调用接口不同或者语义不一致；
- 如果底层硬件不同，对于硬件资源的访问方式会有差异。特别是如果 ISA 不同，则向软件提供的指令集和寄存器都不同。

它们都会导致最终生成的可执行文件有很大不同。需要指出的是，某些编译器支持同一份源代码无需修改就可编译到多个不同的目标平台并在上面运行。这种情况下，源代码是 **跨平台** 的

我们可以通过 **目标三元组** (Target Triplet) 来描述一个目标平台。它一般包括 **CPU 架构、CPU 厂商、操作系统和运行时库**

比如，我们可以尝试看一下之前的 `Hello, world!` 的目标平台是什么。这可以通过打印编译器 rustc 的默认配置信息：

```bash
$ rustc --version --verbose
   rustc 1.57.0-nightly (e1e9319d9 2021-10-14)
   binary: rustc
   commit-hash: e1e9319d93aea755c444c8f8ff863b0936d7a4b6
   commit-date: 2021-10-14
   host: x86_64-unknown-linux-gnu
   release: 1.57.0-nightly
   LLVM version: 13.0.0
```

从其中的 host 一项可以看出默认的目标平台是 `x86_64-unknown-linux-gnu`，其中 CPU 架构是 x86_64，CPU 厂商是 unknown，操作系统是 linux，运行时库是 GNU libc（封装了 Linux 系统调用，并提供 POSIX 接口为主的函数库）

**现在，我们希望能够在另一个硬件平台上运行 `Hello, world!`，我们将 CPU 架构从 x86_64 换成 RISC-V**。

可以看一下目前 Rust 编译器支持哪些基于 RISC-V 的平台：

```bash
$ rustc --print target-list | grep riscv
riscv32gc-unknown-linux-gnu
riscv32i-unknown-none-elf
riscv32imac-unknown-none-elf
riscv32imc-unknown-none-elf
riscv64gc-unknown-linux-gnu
riscv64gc-unknown-none-elf
riscv64imac-unknown-none-elf
```

这里我们选择的是 `riscv64gc-unknown-none-elf`，目标三元组中的 CPU 架构是 riscv64gc，厂商是 unknown，操作系统是 none，**elf 表示没有标准的运行时库（表明没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序**。

- **这表明编译的文件要直接在裸机上运行，不能使用任何的操作系统的系统调用服务和运行时库的函数调用**

这里我们之所以不选择有 linux-gnu 系统调用支持的版本 `riscv64gc-unknown-linux-gnu`，是因为我们需要开发的是一个操作系统，**它必须直面底层物理硬件（bare-metal），无法使用通用操作系统（Linux）的系统调用服务和运行时库的函数调用**。

现在，我们尝试一下将当前的 `Hello, world!` 程序的目标平台换成 `riscv64gc-unknown-none-elf` 看看会发生什么事情：

```bash
$ cargo run --target riscv64gc-unknown-none-elf
   Compiling os v0.1.0 (/home/shinbokuow/workspace/v3/rCore-Tutorial-v3/os)
error[E0463]: can't find crate for `std`
  |
  = note: the `riscv64gc-unknown-none-elf` target may not be installed
```

这个问题只是单纯的表示**在这个目标平台上找不到 Rust 标准库 std**。我们之前曾经提到过，编程语言的标准库或三方库的某些功能会直接或间接的用到操作系统提供的系统调用。但**目前我们所选的目标平台不存在任何操作系统支持，于是 Rust 并没有为这个目标平台支持完整的标准库 std**。类似这样的平台通常被我们称为 **裸机平台** (bare-metal)。这意味着在裸机平台上的软件没有传统操作系统支持，只能直接访问硬件。

**Rust 语言标准库需要有操作系统的支持。所以，如果你要实现的软件是运行在裸机上的操作系统，就不能直接用 Rust 语言标准库了**。

幸运的是，Rust 有一个对 Rust 语言标准库–std 裁剪过后的 Rust 语言核心库 core。**core库是不需要任何操作系统的系统调用的支持的（直接运行在裸机上的库），它的功能也比较受限**，但是也包含了 Rust 语言相当一部分的核心机制，可以满足我们的大部分功能需求。类似于6s081的实验中也提供了如包含printf的、不依赖于系统调用的核心库，供学生做实验使用。

Rust 语言是一种面向系统（包括操作系统）开发的语言，所以在 Rust 语言生态中，有很多三方库也不依赖标准库 std 而仅仅依赖核心库 core。

于是，**在裸机平台上我们要将对于标准库 std 的引用换成核心库 core**

### 交叉编译

我们要在x86上写一个基于riscv的操作系统，事实上，这是一种**编译器运行的平台（x86_64）与可执行文件运行的目标平台（riscv-64）不同**的情况。我们把这种情况称为 **交叉编译** (Cross Compile)。

参与编译和运行的机器根据其角色可以分成以下三类： 

- 构建（build）系统：执行编译构建动作的计算机（即生成编译器可执行程序的计算机）。 
- 主机（host）系统：运行 build 系统来生成可执行程序的计算机系统（运行编译器，生成可执行程序的计算机）。 
- 目标（target）系统：我们用 target 来描述用来运行 以上生成的可执行程序的计算机系统。 

根据 build/host/target 的不同组合我们可以得到 如下的编译方式分类： 

- 本地（native）编译：build == host == target （即在当平台下编译出来的程序，也只是放到当前平台下运行。如在 Linux x86-64 平台上，编写代码并编译成可在 Linux x86-64 平台上执行的程序）

- 交叉（cross）编译：build == host != target（即**在一种平台上编译出在另一种平台上运行的程序**）

我们开发内核，需要在本机上编写代码，编译代码，再在qemu模拟器或裸机上运行，所以我们的编译器必须要是 `riscv64gc-unknown-none-elf`的。

# 移除标准库依赖

对上一节最简单的 Rust 应用程序进行改造使得它能够被编译到 RV64GC 裸机平台上，为此我们**需要移除它对于 Rust std标准库的依赖**，因为 Rust std标准库自己就需要操作系统内核的支持。这样我们需要添加能够支持应用的裸机级别的库操作系统（LibOS）。

- **LibOS 以函数库的形式存在，为应用程序提供操作系统的基本功能**。

## 移除 `println!` 宏

`println!` 宏所在的 Rust 标准库 std 需要通过系统调用获得操作系统的服务，而如果要构建运行在裸机上的操作系统，就不能再依赖标准库了。所以我们第一步要尝试移除 `println!` 宏及其所在的标准库。

我们首先在 `os` 目录下新建 `.cargo` 目录，并在这个目录下创建 `config` 文件，并在里面输入如下内容：

```bash
# os/.cargo/config
[build]
target = "riscv64gc-unknown-none-elf"
```

这会**对 Cargo 工具在 os 目录下的行为进行调整**：现在默认会使用 riscv64gc 作为目标平台而不是原先的默认 x86_64-unknown-linux-gnu，这使得我们之后在 `cargo build` 的时候不必再加上 `--target` 参数。事实上，这是一种编译器运行的平台（x86_64）与可执行文件运行的目标平台（riscv-64）不同的情况。我们把这种情况称为 **交叉编译** (Cross Compile)。

# 内核第一条指令（基础篇）

了解 Qemu 模拟器[#](#qemu "永久链接至标题")
-------------------------------

我们编写的内核将主要在 Qemu 模拟器上运行来检验其正确性。这样做主要是为了方便快捷，只需在命令行输入一行命令即可让内核跑起来。

在本书中，我们使用**软件** `qemu-system-riscv64` 来**模拟一台 64 位 RISC-V 架构的计算机**，它包含CPU 、物理内存以及若干 I/O 外设。它的具体配置（比如 CPU 的核数或是物理内存的大小）均可由用户通过Qemu的执行参数选项来调整。作为模拟器，在宿主机看来它只是一个用户程序，因此上面提到的资源都是它利用宿主机（即 Qemu 运行所在的平台，如 Linux/Windows/macOS）提供给它的资源模拟出来的。

接下来我们来看如何启动 Qemu 。从各章节代码中的 `os/Makefile` 可以看到，我们使用如下命令来启动 Qemu 并运行我们的内核：

```
$ qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
```

其中各个执行参数选项的含义如下：

* `-machine virt` 表示将模拟的 64 位 RISC-V 计算机设置为名为 `virt` 的虚拟计算机。我们知道，即使同属同一种指令集架构，也会有很多种不同的计算机配置，比如 CPU 的生产厂商和型号不同，支持的 I/O 外设种类也不同。

  Qemu 还支持模拟其他 RISC-V 计算机，其中包括由 SiFive 公司生产的著名的 HiFive Unleashed 开发板。

*   `-nographic` 表示模拟器不需要提供图形界面，而只需要对外输出字符流。

*   **通过 `-bios` 可以指定 Qemu 模拟器开机时用来初始化的引导加载程序（bootloader）**，这里我们使用预编译好的 `rustsbi-qemu.bin` ，它需要被放在与 `os` 同级的 `bootloader` 目录下，该目录可以从每一章的代码分支中获得。（rustsbi就是BootLoader）

*   通过虚拟设备 `-device` 中的 `loader` 属性可以**在 Qemu 模拟器开机之前将一个宿主机上的文件载入到 Qemu 的物理内存的指定位置中**， `file` 和 `addr` 属性分别可以设置待载入文件的路径以及将文件载入到的 Qemu 物理内存上的物理地址。注意这里我们载入的文件带有 `.bin` 后缀，它并不是上一节中我们移除标准库依赖后构建得到的内核可执行文件，而是还要进行加工处理得到内核镜像。

### Qemu 启动流程[#](#id5 "永久链接至标题")

在Qemu模拟的 `virt` 硬件平台上，物理内存的起始物理地址为 `0x80000000` ，物理内存的默认大小为 128MiB ，它可以通过 `-m` 选项进行配置。在本书中，我们只会用到最低的 8MiB 物理内存，对应的物理地址区间为 `[0x80000000,0x80800000)` 。如果使用上面给出的命令启动 Qemu ，**那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中**：

- 把作为 bootloader 的 `rustsbi-qemu.bin` 加载到物理内存以物理地址 `0x80000000` 开头的区域上
- 把内核镜像 `os.bin` 加载到以物理地址 `0x80200000` 开头的区域上。

为什么加载到这两个位置呢？这与 Qemu 模拟计算机加电启动后的运行流程有关。一般来说，**计算机加电之后的启动流程可以分成若干个阶段，每个阶段均由一层软件或 [固件](#term-firmware) 负责，每一层软件或固件的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件或固件的入口地址，也就是将计算机的控制权移交给了下一层软件或固件**。

Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。

*   第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 `0x1000` ，因此 Qemu 实际执行的第一条指令位于物理地址 `0x1000` ，接下来它将执行寥寥数条指令并跳转到物理地址 `0x80000000` 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 `0x80000000` 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。
*   第二阶段：由于 Qemu 的第一阶段固定跳转到 `0x80000000` ，我们需要将负责第二阶段的 **bootloader `rustsbi-qemu.bin`** 放在以物理地址 `0x80000000` 开头的物理内存中，这样就能保证 `0x80000000` 处正好保存 bootloader 的第一条指令。**在这一阶段，bootloader RustSBI 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口`0x80200000` ，即可实现将计算机控制权移交给我们的内核镜像 `os.bin`** 。（这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 `0x80200000` ）
*   第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 `0x80200000` 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 `0x80200000` 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。

### **真实计算机的加电启动流程**

真实计算机的启动流程大致上也可以分为三个阶段：

> * 第一阶段：**加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件**。我们一般将该软件称为固件（Firmware），**它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据（也就是MBR）从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader** 。
>
>   **它大致对应于 Qemu 启动的第一阶段，即在物理地址 `0x1000` 处放置的若干条指令。**可以看到 **Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了**。
>
> *   第二阶段：bootloader（MBR中的引导代码） 同样完成一些 CPU 的初始化工作，**将操作系统镜像从硬盘加载到物理内存中**，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。**在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的**。
>
> *   第三阶段：控制权被转移给操作系统。
>
>
> 值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，**从复杂性上它已接近一个传统意义上的操作系统**。

基于上面对 Qemu 启动流程的介绍，我们可以知道为了让我们的内核镜像能够正确对接到 Qemu 和 RustSBI 上，**我们提交给 Qemu 的内核镜像文件必须满足：该文件的开头即为内核待执行的第一条指令**。但后面会讲到，在上一节中我们通过移除标准库依赖得到的可执行文件实际上并不满足该条件。因此，我们还需要对可执行文件进行一些操作才能得到可提交给 Qemu 的内核镜像。为了说明这些条件，首先我们需要了解一些关于程序内存布局和编译流程的知识。

程序内存布局与编译流程[#](#id6 "永久链接至标题")
------------------------------

### 程序内存布局[#](#id7 "永久链接至标题")

在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： **段** (Section) 。不同的段会被编译器放置在内存不同的位置上，这构成了程序的 **内存布局** (Memory Layout)。一种典型的程序相对内存布局如下所示：

<img src="https://raw.githubusercontent.com/BoL0150/image2/master/image-20230105003624078.png" alt="image-20230105003624078" style="zoom:50%;" />



在上图中可以看到，代码部分只有代码段 `.text` 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：

*   已初始化数据段保存程序中那些已初始化的全局数据，分为 `.rodata` 和 `.data` 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。

*   未初始化数据段 `.bss` 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；

*   **堆** （heap）区域用来存放程序运行时动态分配的数据，如 C/C++ 中的 malloc/new 分配到的数据本体就放在堆区域，它向高地址增长；

*   **栈** （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。

### 编译流程[#](#id8 "永久链接至标题")

从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：

1.  **编译器** (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；

2.  **汇编器** (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 **目标文件** (Object File)；

3.  **链接器** (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。

**汇编器输出的每个目标文件都有一个独立的程序内存布局**，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整**合成一个整体的内存布局**。在此期间链接器主要完成两件事情：

* 第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 `1.o` 和 `2.o` 段被按照段的功能进行分类，**相同功能的段被排在一起放在拼装后的目标文件 `output.o` 中**。

  ![image-20230105003756690](https://raw.githubusercontent.com/BoL0150/image2/master/image-20230105003756690.png)

* 第二件事情是将符号替换为具体地址。


那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？

- 首先我们需要**通过链接脚本调整内核可执行文件的内存布局**，使得内核被执行的第一条指令位于地址 `0x80200000` 处，同时代码段所在的地址(.text段）应低于其他段。

- 其次，我们需要**将内核可执行文件中的元数据丢掉得到内核镜像**，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它**直接将输入的文件逐字节拷贝到物理内存中**（通常情况下生成的可执行文件会包括很多元数据，比如elf头，程序头表等，将可执行文件到内存中时，需要去掉这些元数据）因此也可以说**这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中**。

下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。





























