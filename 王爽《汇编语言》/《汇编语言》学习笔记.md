# 《汇编语言》学习笔记

# 第1章、基础知识

## 1.1 机器语言

**机器语言是机器指令的集合**。机器指令是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。
每一种微处理器（cpu），由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的**机器指令集**，也就是机器语言。

**每一种CPU也都有自己的汇编指令集。**

## 1.2 汇编语言的产生

汇编语言的主体是汇编指令，即机器指令便于记忆的书写格式

![image-20210119172942615](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210119172942615.png)

汇编编译器将程序员写出的汇编代码编译成机器语言，由计算机最终执行。

![image-20210119173144663](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210119173144663.png)

## 1.3 汇编语言的组成

![image-20210119173241396](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210119173241396.png)

## 1.4 存储器

CPU控制计算机的运作和运算，向CPU提供指令和数据使它工作，指令和数据存放在存储器中，即**内存**。程序放在磁盘中，磁盘中的程序和数据只有先读到内存中，才能被CPU使用。

CPU可以**直接使用**的信息在存储器中存放。

## 1.5 指令和数据

指令和数据是应用上的概念，在内存和磁盘上，指令和数据没有任何区别，都是二进制信息。

## 1.7 CPU对存储器的读写

CPU要从内存中读数据，首先要指定存储单元的地址，

还要指明对哪一个器件进行操作，

以及进行什么操作，是从中读数据，还是从中写数据。

因此，CPU要想进行数据的读写，必须和外部器件(芯片)进行以下3类信息的交互：

- 存储单元的地址(地址信息);
- 器件的选择，读或写的命令(控制信息);
- 读或写的数据(数据信息)。

连接CPU和其他芯片的导线的集合称为**总线**，CPU通过总线将三种信息传到其他芯片中。

对应传递三种信息，总线分为：

- 地址总线
- 控制总线
- 数据总线

CPU从3号单元中读取数据的过程如下：

![image-20210120154255390](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120154255390.png)

## 1.8 地址总线

CPU通过地址总线来指定存储器单元。

一个CPU有N根地址线，则这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2的N次方个内存单元（**一个内存单元就是一字节**）。

地址总线的宽度决定了CPU的寻址能力。

## 1.9 数据总线

CPU通过数据总线与内存或其他器件之间进行数据传递。

数据总线的宽度决定了CPU和外界的数据传递速度（一次数据传送量）。

## 1.10 控制总线

**CPU通过控制总线对外部器件进行控制。**

控制总线的宽度决定了CPU对外部器件的控制能力。

## 1.11 CPU对其他器件和外部设备的控制

每一台PC中，都有一个主板，总线就印刷在主板上，主板上有核心器件和一些主要器件（如CPU、存储器、外围芯片组、扩展插槽（RAM内存条和各类接口卡）），这些器件通过总线相连。

**CPU只能直接控制主板上的这些器件**，不能直接控制外部设备（如显示器、音响、打印机）。CPU只能通过总线直接控制主板上的扩展插槽，和插在扩展插槽上的接口卡，接口卡再控制外部设备，从而实现CPU对外部设备的间接控制。

## 1.12 各类存储器芯片

随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储

只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失

PC中的存储器从功能和连接上又分为以下几类：

- 随机存储器

  用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上RAM和插在扩展插槽上的RAM（内存条）。

- 装有BIOS的ROM

  BIOS（Basic Input/Output System，基本输入输出系统）是各类接口卡（显卡网卡）厂商提供的软件系统，作用是：通过它对硬件设备（如显示屏）进行输入输出。所以使用只读存储器（ROM）来存储BIOS。在主板和某些接口卡上插有存储相应BIOS的ROM。

- 接口卡上的RAM

  某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡一上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

![image-20210120123752675](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120123752675.png)

接口卡上一般同时需要RAM和ROM

- ROM用来存储BIOS，来对硬件设备进行输入输出，同时为了防止CPU对BIOS进行修改，用ROM来存储。
- RAM用来暂时存储输入输出数据。

## 1.13 内存地址空间

CPU在操控主板上的存储器的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的**逻辑存储器（即虚拟内存空间）**，这个逻辑存储器就是我们所说的**内存地址空间**。

主存储器和接口卡上的ROM和RAM组成 **逻辑存储器**

![image-20210120124604827](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120124604827.png)

**所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器在物理上是不存在的，是一个虚拟的内存空间，相当于CPU给每个物理存储器在这个虚拟内存空间中划分了一个地址段，即一段地址空间，方便CPU对不同的物理存储器进行读写。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。**

内存地址空间的大小受CPU地址总线宽度的限制，80386CPU 的地址总线宽度为32，则内存地址空间最大为4GB。

在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上。要向显存中写入数据，必须知道显存在内存地址空间中的地址。

# 第2章、寄存器

**CPU由运算器、控制器、寄存器构成。**

**总线相对于CPU又分为外部总线和内部总线，内部总线连接CPU内部的各个器件，外部总线连接CPU和主板上的其他器件。**

- 运算器进行信息处理;
- 寄存器进行信息存储;
- 控制器控制各种器件进行工作;
- 内部总线连接各种器件，在它们之间进行数据的传送。

不同的CPU，寄存器的个数、结构是不相同的。8086CPU 有14个寄存器: AX、BX、CX、DX、SI、 DI、SP、BP、IP、CS、SS、DS、ES、PSW，都是16位的。

## 2.1 通用寄存器

AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。

为了保证兼容，AX、BX、CX、DX都可以分为两个独立的8位寄存器使用：

| 16位 | 8高位 | 8低位 |
| ---- | ----- | ----- |
| AX   | AH    | AL    |
| BX   | BH    | BL    |
| CX   | CH    | CL    |
| DX   | DH    | DL    |

8086CPU可以一次性处理以下两种尺寸的数据。

- 字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。
- 字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)

8086采用小端模式：高地址存放高位字节，低地址存放低位字节。

## 2.3 汇编指令

![image-20210120153543952](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120153543952.png)

注意，**此时al是作为一个独立的8位寄存器来使用的，和ah没有关系**，CPU在执行这条指令时认为ah 和al是两个不相关的寄存器。不要错误地认为，诸如add al,93H的指令产生的进位会存储在ah中，add al,93H进行的是8位运算。

**在进行数据传送或运算时，指令的两个操作对象的位数必须一致！**

![image-20210120154010765](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120154010765.png)

## 2.4 8086CPU给出物理地址的方法

CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，称为**物理地址**。

8086CPU是**16**位结构的CPU，即：

- 运算器一次最多可以处理16位的数据;
- 寄存器的最大宽度为16 位;
- 寄存器和运算器之间的通路为16 位。

**内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放**

8086CPU是16位结构，在内部一次性处理、传输、暂时存储的地址为16位，但是却有20位地址总线，可以传送20位地址，达到1MB寻址能力。

从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。

**8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。**

![image-20210120161740872](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120161740872.png)

当8086CPU要读写内存时：

1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；
2. 地址加法器将两个16位地址合成为一个20位的物理地址；

地址加法器采用**物理地址 = 段地址×16 + 偏移地址**的方法用段地址和偏移地址合成物理地址。

![image-20210120161903163](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120161903163.png)

计算机有多少位就相当于：运算器最多可以进行多少位的运算，寄存器最多可以存储多少位的数据，运算器和寄存器之间的通路是多少位。 **但是！并不等于计算机的总线宽度就是这么多位，总线可以更宽。**总线的宽度决定了计算机可寻址内存空间的大小。

## 2.8 段的概念

内存并没有分段，段的划分来自于CPU（类似于内存地址空间，段也是一个虚拟的概念）。

我们可以将若干地址连续、起始地址为16的倍数的一组内存单元定义为一个段。用段地址x16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。

有两点需要注意:**段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数**;偏移地址为16位，**16位地址的寻址能力为64KB，所以一个段的长度最大为64KB**。

## 2.9 段寄存器

段寄存器：8086CPU有4个段寄存器：`CS、DS、SS、ES`，提供内存单元的段地址。

### 1、CS和IP

CS为代码段寄存器，IP为指令指针寄存器

**CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址**

**在任意时刻，CPU将CS:IP指向的内容当作指令执行**

![image-20210120172726621](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120172726621.png)

![image-20210120173008755](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210120173008755.png)

8086CPU的工作过程简要描述

1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；
2. IP=IP+所读取指令的长度，从而指向下一条指令；
3. 执行指令。转到步骤1，重复这个过程。

在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

CPU只认CS：IP指向的内存单元中的内容为指令，一段代码存放在123B0H~123B9H 内存单元中，将其定义为代码段，如果要让这段代码得到执行，可设CS=123BH、 IP=0000H。

### 2、修改CS、IP的指令

8086CPU大部分寄存器的值，都可以用mov指令修改，mov指令被称为传送指令。

但是，mov指令不能设置CS、IP的值。

8086CPU使用jmp指令修改CS、IP的值，能修改CS、IP的值的指令被称为**转移指令**。

- jmp 段地址:偏移地址：用指令中给出的段地址修改CS，偏移地址修改IP。如：`jmp 2AE3:3`

  ![image-20210121215029040](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210121215029040.png)

- jmp 某一合法寄存器：仅修改IP的内容。如：`jmp ax`。在含义上好似：`mov IP，ax`

8086CPU不支持将数据直接送入段寄存器的操作。

# 实验 1   查看CPU和内存，用机器指令和汇编指令编程

## Debug的使用

- 用R命令查看、改变CPU寄存器的内容;

  - 查看寄存器的内容：

    ![image-20210122111907343](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122111907343.png)

    在所有寄存器的下方，还列出了CS:IP所指向的内存单元的地址，机器码，并将它翻译成汇编指令

  - 改变寄存器的内容：

    在r命令后加寄存器名来改变寄存器的内容

    <img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122112531977.png" alt="image-20210122112531977" style="zoom: 50%;" />

- 用D命令查看内存中的内容：

  用“d 段地址:偏移地址”的格式来查看指定内存中的内容，debug将列出从指定内存单元开始的128个内存单元的内容

  ![image-20210122113209066](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122113209066.png)

  最右侧是每个内存单元中的数据对应的ASCII码字符。

  - 一进入Debug后，用D命令直接查看，将列出Debug预设的地址处的内容。

  - 在使用“d段地址:偏移地址”之后，接着使用D命令，可列出后续的内容。

  - 可以指定D命令的查看范围，此时采用“d  段地址:起始偏移地址  结尾偏移地址”的格式。比如要看1000:0~1000:9中的内容，可以用“d 1000:09”实现。

  - 如果我们只想查看某一个内存单元的内容

    <img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122113957358.png" alt="image-20210122113957358" style="zoom:67%;" />

- 用E命令改写内存中的内容：

  - 可用“e  起始地址  数据  数据  数据...............”的格式进行

    ![image-20210122114728419](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122114728419.png)

  - 也可以用提问的方式一个一个的改写

    ![image-20210122114841879](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122114841879.png)

    

- 用U命令将内存中的机器指令翻译成汇编指令;

- 用T命令执行一条机器指令；

  t命令只会执行CS：IP指向的指令，所以在执行前需要用r命令改写CS：IP中的内容，使其指向我们想要执行的指令。

- 用A命令以汇编指令的格式在内存中写入一条机器指令

  使用a命令，从预设的地址开始输入指令（可以自己给定地址）

  <img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210122120353846.png" alt="image-20210122120353846" style="zoom:67%;" />

  输入一条指令后，按下回车，IP会自动指向下一个内存单元。

  什么都不输入直接按回车表示结束。

# 第3章、寄存器（内存访问）

## 3.1 内存中字的存储

字单元：存放一个字型数据（16位）的内存单元，由两个连续的内存单元组成，高地址内存单元放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

将起始地址为N的字单元称为N地址字单元。

## 3.2 DS和[address]

DS寄存器：通常用来存放要访问数据的段地址

[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中

mov指令将一个内存单元中的内容送入另一个寄存器中：

**mov 寄存器名 [内存单元的偏移地址]**

**指令执行时，8086CPU自动取ds寄存器中的数据为内存单元的段地址。**

所以我们在将一个内存单元中的内容送入一个寄存器中时，需要提前将内存单元的段地址放入ds中。

**8086CPU不支持将数据直接送入段寄存器**，只能通过另一个寄存器中转，先将段地址送入一个一般的寄存器，如bx，再将bx中的内容送入ds。

## 3.4 mov、add、sub指令

mov	寄存器，数据	比如: mov ax,8

mov	寄存器，寄存器	比如: mov ax,bx

mov	寄存器，内存单元	比如: mov ax,[0]

mov	内存单元，寄存器	比如: mov [0],ax

mov	内存单元，段寄存器	比如: mov [0],cs

mov    段寄存器，内存单元	比如: mov cs,[0]

mov	段寄存器，寄存器	比如: mov ds,ax

mov	寄存器，段寄存器	比如：mov ax,ds

mov指令几乎都可以互相传递，唯一要注意的是：**不能将数据直接送入段寄存器！**。

可以将内存单元的内容送入段寄存器，也可以将寄存器的内容送入段寄存器，但是唯独不能将数据直接送入段寄存器！

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210123125623186.png" alt="image-20210123125623186" style="zoom: 50%;" />

## 3.7 CPU提供的栈机制（ss和sp）

在基于8086CPU编程的时候，可以将一段内存当作栈来使用。

8086CPU的入栈和出栈操作都是**以字为单位**进行的。

push和pop指令执行时，CPU从**SS和SP中得到栈顶的地址**。

段寄存器SS，存放栈顶的段地址，SP寄存器存放栈顶的偏移地址，任意时刻，**SS:SP**指向栈顶元素

8086CPU中，**入栈时，栈顶从高地址向低地址方向增长。**

`push ax`表示将寄存器ax中的数据送入栈中，由两步完成。

1. SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321113400430.png)

`pop ax`表示从栈顶取出数据送入ax，由以下两步完成。

1. 将SS:SP指向的内存单元处的数据送入ax中；
2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

当栈为空的时候，不存在栈顶元素，**此时SS：SP指向栈的最底部单元下面的单元。该单元的偏移地址为栈最底部的字单元的偏移地址+2！**

一定要注意，栈最底部的字单元的地址并不是最底部的内存单元的地址！

由于栈从栈底到栈顶是从高地址到低地址的，而字单元的地址是两个字节单元地址中的较低的那一个，所以栈最底部的字单元的地址并不是最底部的内存单元的地址！

## 3.8 栈顶超界的问题

栈顶超界会导致其他内存空间的指令或数据被覆盖，产生无法想象的后果。

8086CPU不保证我们对栈的操作不会超界。

我们在编程时要自己操心栈顶超界的问题。

## 3.9 push、pop指令

push	寄存器 		将一个寄存器中的数据入栈
pop	寄存器		出栈，用一个寄存器接收出栈的数据

push	段寄存器		将一个段寄存器中的数据入栈
pop	段寄存器		出栈，用一个段寄存器接收出栈的数据

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210123180744868.png" alt="image-20210123180744868" style="zoom:67%;" />

**实验**

1. 将10000H~1000FH这段空间当作栈，初始状态栈是空的；
2. 设置AX=001AH，BX=001BH；
3. 将AX、BX中的数据入栈；
4. 然后将AX、BX清零；
5. 从栈中恢复AX、BX原来的内容。

```assembly
mov ax, 1000H 
mov ss, ax 
mov sp, 0010H    ;初始化栈顶
mov ax, 001AH
mov bx, 001BH 

push ax 
push bx    ;ax、bx入栈

sub ax, ax   ;将ax清零，也可以用mov ax，0，
             ;sub ax，ax的机器码为2个字节，
             ;mov ax，0的机器码为3个字节。
        
sub bx, bx 

pop bx  ;从栈中恢复ax、bx原来的数据
pop ax  ;
```

**将10000H~1000FH这段空间当作栈，初始状态栈是空的；**

**mov ax, 1000H** 
**mov ss, ax** 
**mov sp, 0010H**

空栈时SP指向的内存单元的偏移地址为栈最底部的**字单元**的偏移地址+2

空栈时SP指向的内存单元的偏移地址为栈最底部的**字单元**的偏移地址+2

空栈时SP指向的内存单元的偏移地址为栈最底部的**字单元**的偏移地址+2

**问题 3.12**

因为push、pop在执行时只能修改SP，所以栈顶的变化范围是0~FFFFH，一个栈最大可以被设为64KB。

小于64KB的栈，栈顶超界时会覆盖别的内存单元；

而等于64KB的栈，栈顶超界时，SP会溢出，栈顶将环绕，覆盖原来栈中的内容。

## 段的综述

我们可以用一个段存放数据，将它定义为“数据段”;

我们可以用一个段存放代码，将它定义为“代码段”;

我们可以用一个段当作栈，将它定义为“栈段“。

对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问;

对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令;

对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop 指令等，就将我们定义的栈段当作栈空间来用。

**CPU将内存中的某段内容当作代码，是因CS:IP指向了那里; CPU将某段内存当作栈，是因为SS:SP指向了那里。**

**一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不**
**是。关键在于CPU中寄存器的设置，即CS、IP、SS、SP、 DS的指向**。

# 实验 2

我们可以用“d  段地址：偏移地址 ”的方式查看指定内存单元的内容，其中的段地址存储在DS段寄存器中。

我们既可以以数据的方式直接给出段地址，也可以以段寄存器的方式给出段地址。

![image-20210123233545500](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210123233545500.png)

![image-20210123233614479](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210123233614479.png)

# 第4章、第一个程序

## 4.1 一个源程序从写出到最终执行的过程

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321114839761.png)

1. 使用文本编辑器用汇编语言写汇编程序，产生了一个存储源程序的**文本文件**
2. 使用汇编语言编译程序对文件中的源程序进行**编译**，产生**目标文件**
3. 使用连接程序对目标文件进行**连接**，产生可在操作系统中直接运行的**可执行文件**
4. 操作系统执行可执行文件：
   1. OS将可执行文件中的机器码和数据加载入内存
   2. 进行相关的初始化（比如设置CS：IP指向第一条要执行的指令）
   3. 由CPU执行程序。

## 4.2 源程序

在汇编语言源程序中有两种指令：

- 汇编指令：有对应的机器码，可以被编译为机器指令，最终被CPU执行
- 伪指令：没有对应的机器码，由编译器来执行

```assembly
1.asm
assume cs:codesg 将用作代码段的段codesg和段寄存器cs联系起来。

codesg segment 定义一个段，段的名称为“codesg”，这个段从此开始
			   codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址

	mov ax, 0123H
	mov bx, 0456H 
	add ax, bx
	add ax, ax 
	
	mov ax, 4c00H 
	int 21H 这两条指令实现程序的返回
	
codesg ends 名称为“codesg”的段到此结束

end 编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译
```

 源程序：源程序文件中的所有内容称为源程序

程序：源程序中最终由CPU执行处理的指令或数据（即源程序中去掉伪指令的部分）

程序最先以汇编指令的形式存在源程序中，经过编译、连接后变成机器码，存在可执行文件中。

**可执行文件是怎么得到运行的？**

一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行。而当P2运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P1，此后P1继续运行。

**程序返回**：一个程序结束后，将CPU的控制权交还给使它得以运行的程序

所以需要在程序的末尾添加返回的程序段。

```assembly
	mov ax, 4c00H 
	int 21H 这两条指令实现程序的返回
```

![image-20210124161841329](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210124161841329.png)

## 4.5 编译连接

首先在DOSBox Options.bat中对DOSBox中的虚拟目录和本地电脑中的真实目录挂载（mount）

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210124202734924.png" alt="image-20210124202734924" style="zoom: 67%;" />

如图，将DOSBox中的d：目录与本地路径的D:\DOSBox\masm挂载，**即访问DOSBox中的d:目录相当于访问D:\DOSBox\masm**

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321115112266.png)

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321115301209.png)

**连接的作用：**

1. 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接在一起，生成一个可执行文件
2. 程序中调用了某个库文件中的程序，需要将这个库文件和该程序生成的目标文件连接在一起，生成一个可执行文件
3. 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，也不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

## 4.6 以简化的方式进行编译和连接

在masm（link）后面加上被编译（连接）的源程序文件（目标文件）的路径、文件名，**在结尾再加上分号**，编译器就会在编译（连接）过程中自动忽略中间文件的生成。

![image-20210124183748917](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210124183748917.png)

![image-20210124183801196](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210124183801196.png)

## 4.7 exe的执行

![image-20210124203212141](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210124203212141.png)

在可执行文件的目录下输入可执行文件的名字即可执行（由于我将DOSBox中的d：目录与本地路径的D:\DOSBox\masm挂载，而可执行文件又在D:\DOSBox\masm下，所以此时就相当于在可执行文件所在的目录下）

## 4.8 谁将可执行文件中的程序装载入内存并使它运行？

程序P1要想运行，必须要有一个正在运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才能运行；P1运行完毕后，要将CPU的控制权还给使它得以运行的程序P2。

操作系统是由多个功能模块组成的庞大、复杂的软件系统，操作人员通过一个称为shell（外壳）的程序来操作计算机系统进行工作。

在DOS中有一个程序command.com，在DOS中被称为命令解释器，也就是DOS系统的shell

DOS启动时，先完成其他重要的初始化任务，然后运行command，由command执行用户输入的命令，比如：cd、dir、type。

在DOS中，command处理各种输入，命令或要执行的程序的文件名，我们就是通过command来进行工作的。

用户想要执行一个程序：

1. 在command中输入该程序的可执行文件的名称
2. command根据文件名找到可执行文件
3. 将可执行文件中的程序加载入内存
4. 设置CS：IP指向程序的入口
5. command暂时停止运行，将CPU的控制权交给另一个程序
6. 另一个程序运行完后，CPU控制权返回到command中，等待用户的输入。

## 4.9 程序执行过程的跟踪

command将程序加载入内存，CS：IP一指向程序的入口，command就放弃了CPU的控制权，直到程序结束，所以我们无法逐条指令看到程序的执行过程。

而Debug将程序加载入内存后并不放弃CPU的控制，单步执行程序。所以我们使用Debug来逐条执行指令，查看每一条指令的执行结果，跟踪执行过程。

debug a.exe，debug将程序从a.exe中加载入内存

![image-20210124214833334](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210124214833334.png)

程序被装入内存的位置：

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/2019032114041883.png)

(1) 程序加载后，ds中存放着程序所在内存区的段地址（SA），这个内存区的偏移地址为0，则程序所在的内存区的地址为ds:0;

(2) 这个内存区的前256个字节中存放的是PSP， DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。

(3) 程序的物理地址是SAx16+0+256=(SA+16)x16+0，用段地址和偏移地址表示为：SA+10H:0。

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321141657458.png)

# 第5章、[BX]和loop指令

`[bx]` 的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中

描述性符号“( )”：表示一个寄存器或一个内存单元中的内容，比如：(ax)表示ax中的内容，(al)表示al中的内容，(20000H)表示内存20000H单元的内容。

"( )"中的元素可以有3种类型：

- 寄存器名
- 段寄存器名
- 内存单元的物理地址（一个20位的数据）

`idata`表示常量：

![image-20210125122432287](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210125122432287.png)

## 5.2 Loop指令

我们使用loop指令实现循环功能，cx中存放循环次数。

`loop`指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作，

1. (cx) = (cx) - 1；
2. 判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。

```assembly
assume cs:code 

code segment 
	mov ax, 2
	
	mov cx, 11 ;循环次数
s:  add ax, ax 
	loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，
               ;这个地址处有一条指令：add ax，ax。
               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前
               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。
	
	mov ax,4c00h 
	int 21h 
code ends 
end
```

用CS和loop指令相配合实现循环功能的3个要点：

1. 在cx中存放循环次数
2. loop指令中的标号所标识的地址要在前面
3. 要循环的程序段写在标号和loop指令的中间

框架如下：

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210125124844375.png" alt="image-20210125124844375" style="zoom:50%;" />

## 5.3 在Debug中跟踪用loop指令实现的循环程序

如何将8位字节单元中的值赋给16位的寄存器ax？ 将字节单元的值赋给al，让ah=0。

**在汇编源程序中，数据不能以字母开头**，比如：9138h在汇编中可以直接写为“9138h”，而A000h要写为“0A000h”。

g命令表示执行程序到当前代码段的某一地址处，不需要一步一步地执行。比如：“g 0012”使debug从当前的CS：IP指向的指令执行，一直到(IP)=0012h为止。

p命令将循环一次执行完，直到(cx)=0为止。

## 5.4 Debug和汇编编译器masm对指令的不同处理

我们在Debug中和源程序中写入同样形式的指令:“mov a1,[0]”、”mov b1,[1]” 、“mov cl,[2]” 、”mov d1,[3]”，但Debug和编译器对这些指令中的`“[idata]”`却有不同的解释。Debug将它解释为`“[idata]”` 是一-个内存单元，`“idata”`是内存单元的偏移地址；而编译器将`“[idata]”` 解释为`“idata“`。

所以要在源程序中访问内存单元，只有两种办法：

1. 将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元
2. 如果"[ ]"内用一个常量直接给出内存单元的偏移地址，要在"[ ]"的前面显式地给出段地址所在的段寄存器。

![image-20210125171329783](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210125171329783.png)

## 5.5 loop和[bx]的联合应用

计算`ffff:0 ~ ffff:b`单元中的数据的和，结果存储在dx中

问题分析：

1. `ffff:0 ~ ffff:b`中的数据是8位的，我们不能将`ffff:0 ~ ffff:b`中的数据直接累加到16位的dx中
2. 我们也不能将`ffff:0 ~ ffff:b`中的数据直接累加到dl中，并设置dh=0，因为会超出dl的范围，数据会溢出

解决方案：

用一个16位寄存器ax来做中介。将内存单元中的8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx。

```assembly
assume cs:code 

code segment 
	mov ax, 0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0。
	mov ds, ax 
	mov bx, 0   ;初始化ds:bx指向ffff:0
	mov dx, 0   ;初始化累加寄存器dx，（dx）= 0
	
	mov cx, 12  ;初始化循环计数寄存器cx，（cx）= 12
s:  mov al, [bx]
	mov ah, 0
	add dx, ax  ;间接向dx中加上（（ds）* 16 +（bx））单元的数值
	inc bx      ;ds:bx指向下一个单元
	loop s 
	
	mov ax, 4c00h 
	int 21h 
code ends 
end

```

在实际编程中，经常会遇到，用**同一种方法**处理地址连续的内存单元中的数据的问题。我们**需要用循环**来解决这类问题，同时我们必须能够在每次循环的时候按照**同一种方法**来改变要访问的内存单元的地址。**这时，就不能用常量来给出内存单元的地址**(比如，[0]、 [1]、[2]中，0、1、2是常量)，而应用**变量**。“mov al,[bx]” 中的bx就可以看作一个代表内存单元地址的变量，**我们可以不写新的指令，仅通过改变bx中的数值，改变指令访问的内存单元**。

## 5.6 段前缀

```assembly
mov ax, ds:[bx]
mov ax, cs:[bx]
mov ax, ss:[bx]
mov ax, es:[bx]
mov ax, ss:[0]
mov ax, cs:[0]
```

段前缀：出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds:”，“cs:”，“ss:”，“es:”。

## 5.7 一段安全的空间

在不能确定一段内存空间中是否存放着重要的数据或代码时，不能随意向其中写入内容。我们是在操作系统的环境中工作，**操作系统管理所有的资源，也包括内存**。**如果我们需要向内存空间转中写入数据的话，要使用操作系统给我们分配的空间，而不应该用地址任意指定内存空间，向里面写入**。

DOS方式下，一般情况，`0:200~0:2ff`空间值没有系统或其他程序的数据或代码。当我们需要直接向一段内存中写入内容是，就使用`0:200~0:2ff`这段空间。

# 第6章、包含多个段的程序

合法通过操作系统取得的空间都是安全的

通过操作系统取得空间的方法：

- 在加载程序时为程序分配
- 程序在执行过程中向系统申请（略）

若要一个程序在被加载的时候取得所需的空间，必须要在源程序中做出说明，**我们通过在源程序中定义段来进行内存空间的获取**，比如程序在加载时，取得了代码段中的代码的存储空间

## 6.1 在代码段中使用数据

```assembly
;计算 8 个数据的和存到 ax 寄存器
assume cs:code 

code segment 

	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据

	start:	mov bx, 0  ;标号start
			mov ax, 0  
			
			mov cx, 8
	s:		add ax, cs:[bx]
			add bx, 2
			loop s 
			
			mov ax, 4c00h 
			int 21h 
code ends
end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方
	     	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。
```

dw定义字型数据，程序在加载时，会给这8个数据划分内存空间。

这八个数据和后面的指令一起存放在代码段中，位于代码段的最开始，所以段地址在CS中，偏移地址为0，在代码段的偏移0、2、4、6、8、A、C、E处。在内存空间中数据位置的后面才是指令。

由于数据在指令前面，为了方便执行指令，使用标号start指明程序的入口。

可执行文件由**描述信息**和**程序**组成，程序来自源程序中的汇编指令和定义的数据；描述信息是编译、连接程序对源程序中相关伪指令进行处理得到的信息。伪指令end描述了程序的结束和程序的入口，在编译连接后，由`end start`指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。**程序被加载入内存之后，加载者从程序的可执行文件的描述信息值读到程序的入口地址，设置CS：IP。**这样CPU就从我们希望的地址处开始执行。

## 6.2 在代码段中使用栈

![image-20210128113329949](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210128113329949.png)

所以我们需要有一段可以当做栈的内存空间，这段空间由系统来分配。**可以在程序中通过定义数据来取得一段空间，然后将这段空间当做栈空间来用。**

```assembly
;利用栈，将程序中定义的数据逆序存放。
assume cs:codesg 

codesg segment 
	dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元
	dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用
			
	start:	mov ax, cs 
			mov ss, ax 
			mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d
			mov bx, 0
			
			mov cx, 8
	s:		push cs:[bx]
			add bx, 2
			loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈
			
			mov bx, 0
			
			mov cx, 8
	s0:		pop cs:[bx]		
			add bx，2
			loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中
			
			mov ax，4c00h 
			int 21h 
codesg ends 
end start	;指明程序的入口在start处

```

在代码段中定义了16个字型数据，它们的数值都是0。这16个数据的值是多少对程序来说没有意义，**我们定义这些数据的最终目的是，通过它们取得一定容量的内存空间**。所以我们在描述 `dw`的作用时，**可以说用它定义数据，也可以说用它开辟内存空间**。

## 6.3 将数据、代码、栈放入不同的段

将数据、代码和栈放到同一个段中有两个问题：

1. 使程序显得混乱
2. 由于一个段的容量不能大于64kb，所以可能放不下

```assembly
assume cs:code,ds:data,ss:stack 

data segment 
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;0-15单元
data ends 

stack segment 
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;0-31单元
stack ends 

code segment 
	start:	mov ax, stack;将名称为“stack”的段的段地址送入ax
			mov ss, ax
			mov sp, 20h  ;设置栈顶ss:sp指向stack:20。 20h = 32d
			
			mov ax, data ;将名称为“data”的段的段地址送入ax
			mov ds, ax   ;ds指向data段
			
			mov bx, 0    ;ds:bx指向data段中的第一个单元
			
			mov cx, 8
	s:	    push [bx]
			add bx, 2
			loop s       ;以上将data段中的0~15单元中的8个字型数据依次入栈
			
			mov bx, 0
			
			mov cx, 8
	s0:		pop [bx]
			add bx, 2
			loop s0      ;以上依次出栈8个字型数据到data段的0~15单元中
			
			mov ax, 4c00h 
			int 21h 
code ends
end start
;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，
;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令

```

现在程序值有多个段，**每个段的段名相当于一个标号，代表了段地址**，所以指令 `mov ax,data`的含义就是将名称为data的段的段地址送入ax。

我们在源程序中用伪指令 `assume cs:code,ds:data,ss:stack`将cs、ds和ss分别和code、 data、 stack 段相连。但是，**CPU并不会就会将cs指向code， ds指向data，ss指向stack**，从而按照我们的意图来处理这些段。assume是伪指令，由编译器执行，CPU并不知道它们。

**若要CPU按照我们的安排做事，就要用机器指令控制它们。**这三个段本质上没有任何区别，虽然名字是data、stack、code，但是这些伪指令对CPU没有作用，只是划分了三个不同的段，在CPU看来，它们都是内存空间。CPU从CS：IP指向处开始执行代码，就把这一段视为代码段。在代码段中设置了ds，ss的指向，就把data和stack视为数据段和栈段。

在只有一个段的时候，这个段加载入内存后，CS就指向这个段，IP指向这个段最开始的位置，CPU默认从这个段的最开始执行程序；当有多个段的时候，CPU不知道从什么地方开始执行程序，这时候就必须设置start标号，CS：IP被设置为执行start标记的地方，CPU就从这里开始执行程序。

CPU如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，**完全是靠程序中具体的汇编指令，和汇编指令对CS：IP、SS：IP、DS等寄存器的设置来决定的**。

# 第7章、更灵活的定位内存地址的方式

## 7.1 and和or

and指令：逻辑与指令，按位进行与运算。

`mov al, 01100011B`
`and al, 00111011B`

执行后：`al=00100011B`

**通过该指令将操作对象的相应位设为0，其他位不变。**

or指令：逻辑或指令，按位进行或运算。

`mov al, 01100011B`
`or al, 00111011B`
执行后：`al=01111011B` 

**通过该指令将操作对象的相应位设为1，其他位不变。**

## 7.2 ASCII码

在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；文本编辑软件从内存中取出61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。

## 7.3 以字符形式给出的数据

用单引号'........' 的方式指明数据是以字符的形式给出的，编译器将它们转化为对应的ASCII码。

```assembly
assume cs:code,ds:data 

data segment 
	db 'unIx'   ;相当于“db 75H，6EH，49H，58H”
	db 'foRK'
data ends 

code segment
start:	mov al, 'a'  ;相当于“mov al, 61H”，“a”的ASCI码为61H；
		mov b1, 'b'
		
		mov ax, 4c00h 
		int 21h 
code ends
end start

```

## 7.4 大小写转换问题

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321194022547.png)

小写字母的ASCII码值比大写字母的ASCII码值大20H

**大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)**

所以如果我们要将大小写字母相互转换，只需要使用and和or将第五位的0变成1，1变成0。

```assembly
assume cs:codesg,ds:datasg 

datasg segment 
	db 'BaSiC'
	db 'iNfOrMaTion'
datasg end

codesg segment 
	start:	mov ax, datasg 
			mov ds, ax	;设置ds 指向 datasg段
		
			mov bx, 0	;设置（bx）=0，ds:bx指向’BaSic’的第一个字母
			
			mov cx, 5     	 ;设置循环次数5，因为’Basic'有5个字母
	s:		mov al, [bx]     ;将ASCII码从ds:bx所指向的单元中取出
			and al, 11011111B;将al中的ASCII码的第5位置为0，变为大写字母
			mov [bx], al	 ;将转变后的ASCII码写回原单元
			inc bx		     ;（bx）加1，ds:bx指向下一个字母
			loop s 
			
			mov bx, 5	;设置（bx）=5，ds:bx指向，iNfOrMaTion'的第一个字母
			
			mov cx, 11	;设置循环次数11，因为‘iNfOrMaTion'有11个字母
	s0:		mov al, [bx]
			or al, 00100000B;将a1中的ASCII码的第5位置为1，变为小写字母
			mov [bx], al 
			inc bx
			loop s0
			
			mov ax, 4c00h 
			int 21h 
codesg ends

```

## 7.5 [bx+idata]

[bx+idata]表示一个内存单元,它的偏移地址为(bx)+idata。 例如：`mov ax, [bx+200]`
该指令也可以写成如下格式：

```assembly
mov ax, [200+bx]
mov ax, 200[bx]
mov ax, [bx].200
```

## 7.6 用[bx+idata]的方式进行数组的处理

```assembly
assume cs:codesg,ds:datasg 

datasg segment 
	db 'BaSiC';转为大写
	db 'MinIx';转为小写
datasg ends

codesg segment
	start:
		mov ax, datasg 
		mov ds, ax 
		mov bx, 0  ;初始ds:bx
	
		mov cx, 5
	s:	mov al, 0[bx]  ;等同于[0 + bx]，定位第一个字符串中的字符
		and al, 11011111b ;转为大写字母
		mov 0[bx], al ;写回
		mov al, 5[bx]  ;等同于[5 + bx]，定位第二个字符串中的字符
		or al, 00100000b ;转为小写字母
		mov 5[bx], al
		inc bx
		loop s
		
		mov ax, 4c00h 
		int 21h
codesg ends
end start

```

datasg中的两个字符串一个起始地址为0，一个为5，我们可以将这两个字符串看作两个数组，一个从0开始存放，一个从5开始存放。`0[bx],5[bx]`中0和5给定了两个字符串的偏移地址，bx给出了从偏移地址开始的相对地址。

## 7.7 SI和DI

si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。

## 7.8 [bx + si] 和 [bx + di]

[bx+si]和[bx+di]的含义相似

[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）

指令`mov ax, [bx + si]`的含义：将一个内存单元字数据的内容送入ax，段地址在ds中，偏移地址为bx中的值加上si中的值。

该指令也可以写成如下格式：`mov ax, [bx][si]`

## 7.9 [bx+si+idata]和[bx+di+idata]

[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata

指令`mov ax，[bx+si+idata]`的含义：将一个内存单元**字数据**的内容送入ax，段地址在ds中，偏移地址为bx中的值加上si中的值再加上idata。

该指令也可以写成如下格式：

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210130180844557.png" alt="image-20210130180844557" style="zoom: 50%;" />

## 7.10 不同的寻址方式的灵活应用

`[idata]`用一个常量来表示地址，可用于直接定位一个内存单元；
`[bx]`用一个变量来表示内存地址，可用于间接定位一个内存单元；
`[bx+idata]`用一个变量和常量表示地址，**可在一个起始地址的基础上用变量间接定位一个内存单元**；
`[bx+si]`用两个变量表示地址；
`[bx+si+idata]`用两个变量和一个常量表示地址。

# 第8章、数据处理的两个基本问题

## 8.1 bx、si、di和bp

在8086CPU中，**只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址**。

在[ ]中，这4个寄存器可以单个出现，或只能以4种组合出现：`bx和si、bx和di`、`bp和si、bp和di`。

**只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中**

在[……]中使用寄存器bx，而指令中没有显性地给出段地址, 段地址就默认在ds中

## 8.2 机器指令处理的数据在什么地方

数据处理大致可分为3类：读取、写入、运算。

指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/2019032120283492.png)

## 8.3 汇编语言中数据位置的表达

汇编语言中用3个概念来表达数据的位置：

- 立即数（idata）

  对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为：立即数（idata）

  ```assembly
  mov ax, 1                 
  add bx, 2000h             
  or bx, 00010000b
  mov al, 'a'
  ```

- 寄存器

  指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。

  ```assembly
  mov ax, bx     
  mov ds, ax 
  push bx 
  mov ds:[0], bx 
  push ds 
  mov ss, ax
  mov sp, ax
  ```

- 段地址（SA）和偏移地址（EA）

  指令要处理的数据在**内存**中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。

  ```assembly
  mov ax, [0]
  mov ax, [di]
  mov ax, [bx+8]
  mov ax, [bx+si]
  mov ax, [bx+si+8]   ;以上段地址默认在ds中
  
  mov ax, [bp]
  mov ax, [bp+8]
  mov ax, [bp+si]
  mov ax, [bp+si+8]   ;以上段地址默认在ss中
  
  mov ax, ds:[bp]
  mov ax, es:[bx]
  mov ax, ss:[bx+si]
  mov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器
  ```

## 8.4 寻址方式

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321213006102.png)

## 8.5 指令要处理的数据有多长

8086CPU的指令，可以处理两种尺寸的数据，byte和word

1. 通过寄存器名指明要处理的数据的尺寸。
   例如： `mov al, ds:[0]` 寄存器al指明了数据为1字节

2. 在没有寄存器名存在的情况下，用操作符`X ptr`指明内存单元的长度，X在汇编指令中可以为`word`或`byte`。
   例如：`mov byte ptr ds:[0], 1` byte ptr 指明了指令访问的内存单元是一个**字节单元**

   ​			``mov word ptr ds:[0], 1 `` word ptr 指明了指令访问的内存单元是一个**字单元**

3. 有些指令默认了访问的是字单元还是字节单元
   例如，`push [1000H]`，push 指令只进行字操作。

## 8.6 寻址方式的综合应用

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190321215930774.png)

要修改排名、收入和产品

C语言描述：

```c
/*定义一个公司记录的结构体*/
struct company
{
    char cn[3];/*公司名称*/
    char hn[9];/*总裁姓名*/
    int pm;/*排名*/
    int sr;/*收入*/
    char cp[3];/*著名产品*/
};
//sizeof (struct company) == 24
int main()
{
    /*定义一个公司记录的变量，内存中将存有一条公司的记录*/
    struct company dec = {"DEC", "Ken Olsen", 137, 40, "PDP"};

    int i;

    dec.pm = 38;
    dec.sr = dec.sr + 70;

    i = 0;
    dec.cp[i] = 'V'; //mov byte ptr [bx].10h[si], 'V'
    i++;
    dec.cp[i] = 'A';
    i++;
    dec.cp[i] = 'X';

    return 0;
}
```

按照C语言的风格，用汇编描述，注意与C语言的对比。

```assembly
mov ax, seg 
mov ds, ax 
mov bx, 60h   ;确定记录地址，ds:bx 

mov word ptr [bx+0ch], 38   ;排名字段改为38  [bx].0ch
							;C: dec.pm=38;
add word ptr [bx+0eh], 70   ;收入字段增加70  [bx].0eh
							;C: dec.sr = dec.sr + 70;
mov si, 0   ;用si来定位产品字符串中的字符
			;C: i=0;
mov byte ptr [bx+10h+si], 'V'   ;[bx].10h[si]
								;C: dec.cp[i] = 'V';
inc si 							;C: i++;
mov byte ptr [bx+10h+si], 'A'
inc si 
mov byte ptr [bx+10h+si], 'X'

```

我们可以用`[bx+idata+si]`的方式来访问结构体中的数据。用bx定位整个结构体，用idata 定位结构体中的某一个数据项，用si定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如:
`[bx].idata`、`[bx].idata[si]`。

## 8.7 div指令

**div是除法指令**

1. 除数：有8位和16位两种，在一个`寄存器`或`内存单元`中。
2. 被除数：默认放在`AX`或`DX和AX`中，
   如果除数为8位，被除数则为16位，默认在AX中存放；
   如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。
3. 结果：
   如果除数为8位，则`AL存储除法操作的商`，`AH存储除法操作的余数`；
   如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。

```assembly
div byte ptr ds:[0] ;含义:(al)=(ax) / ( (ds) *16+0)的商
					;	 (ah)=(ax) / ( (ds) *16+0)的余数
					
div word ptr es:[0] ;含义:(ax)=[ (dx) *10000H+ (ax) ]/ ( (es) *16+0)的商
					;	 (dx)=[ (dx) *10000H+ (ax)]/ ( (es) *16+0)的余数
					
div byte ptr [bx+si+8];含义: (al)=(ax)/ ( (ds) *16+ (bx)+(si) +8)的商
					  ;		(ah)=(ax)/ ( (ds) *16+ (bx)+ (si) +8)的余数
					  
div word ptr [bx+si+8];含义: (ax)=[ (dx) *10000H+ (ax)]/ ( (ds) *16+ (bx)+ (si) +8)的商				      ;     (dx)=[ (dx) *10000H+ (ax)]/ ( (ds) *16+ (bx)+(si) +8)的余数
```

## 8.8 伪指令`dd`

`db`和`dw`定义字节型数据和字型数据。

`dd`是用来定义`dword`（double word，双字）型数据的伪指令

## 8.9 `dup`

`dup`在汇编语言中同`db、dw、dd`等一样，也是由编译器识别处理的符号。
它和`db、dw、dd`等数据定义伪指令配合使用，用来进行数据的重复

```assembly
db 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。
db 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。
db 3 dup ('abc', 'ABC') ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db 'abc', 'ABC' ,'abc' , 'ABC, 'abc', 'ABC'。
```

`dup`的使用格式如下：

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210130214948964.png" alt="image-20210130214948964" style="zoom:50%;" />

## 8.10 mul指令

**mul 指令**

mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。

- 8 位： 两个相乘的数一个放在`AL`中，另一个放在 `8位寄存器`或`内存字节单元`中；
- 16 位： 一个放在`AX`中，另一个放在`16 位寄存器`或`内存字单元`中。

结果

- 8位：结果默认放在AX中；
- 16位：DX（高位）和 AX（低位）中。

格式：`mul 寄存器` 或 `mul 内存单元`

```assembly
;计算100*10
;100和10小于255，可以做8位乘法
mov al,100
mov bl,10
mul bl

;结果： (ax)=1000（03E8H） 
```

```assembly
;计算100*10000
;100小于255，可10000大于255，所以必须做16位乘法，程序如下：
mov ax,100
mov bx,10000
mul bx

;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）
```

# 第9章、转移指令的原理

可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。

8086CPU的转移行为有以下几类。

- 只修改IP时，称为`段内转移`，比如：`jmp ax`。
- 同时修改CS和IP时，称为`段间转移`，比如：`jmp 1000:0`。

由于转移指令对IP的修改范围不同，段内转移又分为：`短转移和近转移`。

- 短转移IP的修改范围为`-128 ~ 127`。
- 近转移IP的修改范围为`-32768 ~ 32767`。

8086CPU的转移指令分为以下几类。

- 无条件转移指令（如：jmp）
- 条件转移指令
- 循环指令（如：loop）
- 过程
- 中断

## 9.1 操作符offset

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。

```assembly
;将s处的一条指令复制到s0处
assume cs:codesg
codesg segment
 s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）
      mov si, offset s     ;获得标号s的偏移地址
      mov di, offset s0    ;获得标号s0的偏移地址
      
      mov ax, cs:[si]
      mov cs:[di], ax
 s0:  nop                     ;（nop的机器码占一个字节）
      nop
 codesg ends
 ends
```

## 9.2 jmp指令

jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；

jmp指令要给出两种信息：

- 转移的目的地址
- 转移的距离（段间转移、段内短转移，段内近转移）

 `jmp short 标号` `jmp near ptr 标号` `jcxz 标号` `loop 标号` 等几种汇编指令，它们对 IP的修改

**是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。**

### 1、依据位移进行转移的jmp指令

`jmp short 标号`（**段内短转移**）

指令“`jmp short 标号`”的功能为`(IP)=(IP)+8位位移`，转到标号处执行指令

（1）**8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址**；

（2）short指明此处的位移为8位位移；

（3）8位位移的范围为-128~127，用补码表示

（4）**8位位移由编译程序在编译时算出**。

**jmp short s指令的读取和执行过程：**

1. (CS)=0BBDH，(IP)=0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；
2. 读取指令码EB 03进入指令缓冲器；
3. (IP) = (IP) + 所读取指令的长度 = (IP) + 2 = 0008，CS:IP指向add ax,1；
4. CPU指行指令缓冲器中的指令EB 03；
5. 指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax

指令`jmp near ptr 标号`的功能为 `(IP)=(IP)+16位位移`，实现**段内近转移**

(1) 16位位移=标号处的地址-jmp指令后的第一个字节的地址;

(2) `near ptr` 指明此处的位移为16 位位移，进行的是段内近转移;

(3) 16位位移的范围为-32768~32767， 用补码表示;

(4)16位位移由编译程序在编译时算出。

**以上的jmp指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的位移距离。**

### 2、转移的目的地址在指令中的jmp指令

`jmp far ptr 标号`（段间转移或远转移）

指令 “`jmp far ptr 标号`” 功能如下：

- (CS) = 标号所在段的段地址；
- (IP) = 标号所在段中的偏移地址。
- far ptr指明了**指令用标号的段地址和偏移地址修改CS和IP。**

```assembly
assume cs:codesg
codesg segment
   start: mov ax, 0
		  mov bx, 0
          jmp far ptr  s ;s被翻译成转移的目的地址0B01 BD0B
          db 256 dup (0) ;转移的段地址：0BBDH，偏移地址：010BH
    s:    add ax,1
          inc ax
codesg ends
end start
```

### 3、转移地址在寄存器中的jmp指令

`jmp 16位寄存器` 功能：`IP =（16位寄存器）`

### 4、转移地址在内存中的jmp指令

转移地址在内存中的jmp指令有两种格式：

- `jmp word ptr 内存单元地址`（段内转移）

  功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

  ```assembly
  mov ax, 0123H
  mov ds:[0], ax
  jmp word ptr ds:[0]
  ;执行后，(IP)=0123H
  ```

- `jmp dword ptr 内存单元地址`（段间转移）

  功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

  - (CS)=(内存单元地址+2)
  - (IP)=(内存单元地址)

  ```assembly
  mov ax, 0123H
  mov ds:[0], ax;偏移地址
  mov word ptr ds:[2], 0;段地址
  jmp dword ptr ds:[0]
  ;执行后，
  ;(CS)=0
  ;(IP)=0123H
  ;CS:IP 指向 0000:0123。
  ```

### 5、jcxz指令

jcxz指令为有条件转移指令，**所有的有条件转移指令都是短转移**，

**在对应的机器码中包含转移的位移**，而不是目的地址。对IP的修改范围都为-128~127。

指令格式：`jcxz 标号`（如果(cx)=0，则转移到标号处执行。）

当(cx) = 0时，(IP) = (IP) + 8位位移

- 8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址；
- 8位位移的范围为-128~127，用补码表示；
- 8位位移由编译程序在编译时算出。

当(cx)!=0时，什么也不做（程序向下执行）

### 6、loop指令

loop指令为循环指令，**所有的循环指令都是短转移**，在对应的机器码中包含转移的位移，而不是目的地址。

对IP的修改范围都为-128~127。

指令格式：`loop 标号` ((cx) = (cx) - 1，如果(cx) ≠ 0，转移到标号处执行)。

(cx) = (cx) - 1；如果 (cx) != 0，(IP) = (IP) + 8位位移。

- 8位位移 = 标号处的地址 - loop指令后的第一个字节的地址；
- 8位位移的范围为-128~127，用补码表示；
- 8位位移由编译程序在编译时算出。

如果（cx）= 0，什么也不做（程序向下执行）。

## 9.9 根据位移进行转移的意义

 `jmp short 标号` `jmp near ptr 标号` `jcxz 标号` `loop 标号` 等几种汇编指令，它们对 IP的修改是**根据转移目的地址和转移起始地址之间的位移来进行的**，这样设置保证了程序在内存的不同位置都可以正确执行。

# 第10章、CALL和RET指令

call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。

## 10.1 ret 和 retf

- ret指令**用栈中的数据，修改IP的内容**，从而实现近转移；
- retf指令**用栈中的数据，修改CS和IP的内容**，从而实现远转移。

CPU执行ret指令时，相当于进行： `pop IP`：

（1）`(IP) = ( (ss) * 16 + (sp) )`

（2）`(sp) = (sp) + 2`

CPU执行retf指令时，相当于进行：`pop IP, pop CS`：

（1）`(IP) = ( (ss) * 16 + (sp) )`

（2）`(sp) = (sp) + 2`

（3）`(CS) = ( (ss) * 16 + (sp) )`

（4）`(sp) = (sp) + 2`

```assembly
assume cs:code 
stack seqment
	db 16 dup (0)
stack ends 

code segment
		mov ax, 4c00h
		int 21h 
 start:	mov ax, stack 
 		mov ss, ax
 		mov sp, 16
		mov ax, 0
		push ax ;ax入栈
		mov bx, 0
		ret ;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retf
code ends
end start
```

## 10.2 CALL指令

call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：

（1）将当前的 IP 或 CS和IP 压入栈中；

（2）转移（jmp）。

call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。

### 1、依据位移进行转移的call指令（段内近转移）

`call 标号`（近转移）：将当前的IP压栈后，转到标号处执行指令。

CPU执行此种格式的call指令时，相当于进行 `push IP` 	`jmp near ptr 标号`

CPU执行此种格式的call指令时，进行如下的操作:

1.  `(sp)=(sp)-2`	`((ss)* 16+(sp))=(IP)` 
2. `(IP)=(IP)+16 位位移。`

16位位移=标号处的地址-call指令后的第一个字节的地址;
16位位移的范围为-32768~32767，用补码表示;
16位位移由编译程序在编译时算出。

### 2、转移的目的地址在指令中的call指令（段间转移）

`call far ptr 标号`（段间转移）

CPU执行此种格式的call指令时，相当于进行：`push CS，push IP` `jmp far ptr 标号`

CPU执行此种格式的call指令时，进行如下的操作。

1. `(sp)=(sp)-2`

   `((ss)*16+(sp))=(CS)`

   `(sp)=(sp)- 2`

   `((ss)* 16+(sp))=(IP)`

2. `(CS)=标号所在段的段地址`
   `(IP)=标号在段中的偏移地址`

### 3、转移地址在寄存器中的jmp指令

`call 16位寄存器`

CPU执行此种格式的call指令时，相当于进行： `push IP` `jmp 16位寄存器`

`(sp)=(sp)-2`
`((ss)* 16+(sp)=(IP)`
`(IP)=(16位reg)`

### 4、转移地址在内存中的jmp指令

`call word ptr 内存单元地址`（段内转移）

CPU执行此种格式的call指令时，相当于进行：`push IP` `jmp word ptr 内存单元地址`

```assembly
mov sp, 10h
mov ax, 0123h
mov ds:[0], ax
call word ptr ds:[0]
;执行后，(IP)=0123H，(sp)=0EH
```

`call dword ptr 内存单元地址`（段间转移）

CPU执行此种格式的call指令时，相当于进行：`push CS` `push IP` `jmp dword ptr 内存单元地址`

```assembly
mov sp, 10h
mov ax, 0123h
mov ds:[0], ax
mov word ptr ds:[2], 0
call dword ptr ds:[0]
;执行后，(CS)=0，(IP)=0123H，(sp)=0CH
```

## 10.7 call和ret的配合使用

call和ret借用栈实现了函数调用和函数返回。

框架如下：

```assembly
assume CS:code
code segment
	main: :
		  :
		  call  sub1 ;调用子程序sub1
		  :
		  :
		  mov ax, 4c00h
		  int 21h
		  
	sub1: :			  ;子程序sub1开始
		  :
		  Call sub2   ;调用子程序sub2
		  :
		  :
		  ret		   ;子程序返回
		  
	sub2: :			   ;子程序sub2开始
		  :
		  :
		  ret		   ;子程序返回
code ends 
end main
```

## 10.12 寄存器冲突的问题

如何避免子程序中使用的寄存器，在主程序中也被使用从而造成的冲突？

**在子程序的开始将子程序中所提到的寄存器中的内容都保存起来（入栈），在子程序返回前再恢复（出栈）。**

框架：

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210131173743962.png" alt="image-20210131173743962" style="zoom:50%;" />

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210131173639864.png" alt="image-20210131173639864" style="zoom: 50%;" />

# 第11章、标志寄存器

CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。

（1）用来存储相关指令的某些执行结果；

（2）用来为CPU执行相关指令提供行为依据；

（3）用来控制CPU的相关工作方式。

这种特殊的寄存器在8086CPU中，被称为标志寄存器（flag）。

8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW-Program Status Word）

**flag寄存器是按位起作用的**，它的每一位都有专门的含义，记录特定的信息。

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190322182130199.png)
在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令

## 11.1 标志寄存器

### 1、零标志位 (ZF)

零标志位（Zero Flag）。它记录相关指令执行后，其结果是否为0。

如果结果为0，那么zf = 1(表示结果是0)；如果结果不为0，那么zf = 0。

```assembly
mov ax, 1
sub ax, 1 ;执行后，结果为0，则zf = 1

mov ax, 2
sub ax, 1 ;执行后，结果不为0，则zf = 0
```

### 2、奇偶标志位 (PF)

奇偶标志位（Parity Flag）。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。

如果1的个数为偶数，pf = 1，如果为奇数，那么pf = 0。

```assembly
mov al, 1
add al, 10 ;执行后，结果为00001011B，其中有3（奇数）个1，则pf = 0；

mov al, 1
or al, 2  ;执行后，结果为00000011B，其中有2（偶数）个1，则pf = 1；
```

### 3、符号标志位(SF)

符号标志位(Symbol Flag)。它记录相关指令执行后，其结果是否为负。

如果结果为负，sf = 1；如果非负，sf = 0。

计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。

`00000001B`，可以看作为无符号数1，或有符号数+1；
`10000001B`，可以看作为无符号数129，也可以看作有符号数-127。

对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算

**CPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算**

SF标志，就是CPU对**有符号数**运算结果的一种记录，它记录数据的正负。**在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负**。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值

```assembly
mov al, 10000001B 
add al, 1   ;执行后，结果为10000010B，sf = 1，表示：如果指令进行的是有符号数运算，那么结果为负；
12
mov al, 10000001B
add al, 01111111B   ;执行后，结果为0，sf = 0，表示：如果指令进行的是有符号数运算，那么结果为
正
```

### 4、进位标志位(CF)

进位标志位(Carry Flag)。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值
![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190322222505568.png)

```assembly
mov al, 98H
add al, al	;执行后:(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值
add al, al	;执行后:(al)=60H，CF=0，CF记录了从最高有效位向更高位的进位值
```

```assembly
mov al, 97H
sub al, 98H	;执行后: (al)=FFH， CF=1， CF记录了向更高位的借位值
sub al, al	;执行后: (al)=0， CF=0，CF记录了向更高位的借位值
```

### 5、溢出标志位(OF)

溢出标志位(Overflow Flag)。一般情况下，**OF记录了有符号数运算的结果是否发生了溢出。**

如果发生溢出，OF = 1；如果没有，OF = 0。

CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位

CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。

- 对于无符号数运算，CPU用CF位来记录是否产生了进位；
- 对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。

```assembly
mov al, 98
add al, 99   ;执行后将产生溢出。因为进行的"有符号数"运算是：（al）=（al）+ 99 = 98 + 99=197 = C5H 为-59的补码
             ;而结果197超出了机器所能表示的8位有符号数的范围：-128-127。
             ;add 指令执行后：无符号运算没有进位CF=0，有符号运算溢出OF=1
             ;当取出的数据C5H按无符号解析C5H = 197, 当按有符号解析通过SP得知数据为负,即C5H为-59补码存储，
             
mov al，0F0H  ;F0H，为有符号数-16的补码
add al，088H  ;88H，为有符号数-120的补码
              ;执行后，将产生溢出。因为add al, 088H进行的有符号数运算结果是：（al）= -136 
              ;而结果-136超出了机器所能表示的8位有符号数的范围：-128-127。
              ;add 指令执行后：无符号运算有进位CF=1，有符号运算溢出OF=1
```

有符号和无符号只是数学上的意义的不同，对于计算机底层没有任何区别，都是二进制数。不管是有符号数还是无符号数，**在底层中统一按照二进制数运算**，算完了之后才给它们按照不同的映射转换成有符号数或无符号数。

对于两个7位的二进制数（从0开始算），如果第7位向更高位进位，则发生了无符号数溢出。如果第6位向第7位进位，则发生了有符号数溢出。

对于两个十进制数运算，超过了表达范围就是溢出。

## 11.6 adc指令

adc是带进位加法指令，它利用了CF位上记录的进位值。

指令格式：`adc 操作对象1, 操作对象2`

功能：操作对象1 = 操作对象1 + 操作对象2 + CF

```assembly
mov ax, 2
mov bx, 1
sub bx, ax  ;无符号运算借位CF=1，有符号运算OF = 0
adc ax, 1   ;执行后，（ax）= 4。adc执行时，相当于计算：(ax)+1+CF = 2+1+1 = 4。
```

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190323125737798.png)

```assembly
;计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。
;将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。
mov ax, 001EH 
mov bx, 0F000H 
add bx, 1000H
adc ax, 0020H
```

## 11.7 sbb指令

sbb是带借位减法指令，它利用了CF位上记录的借位值。

指令格式：`sbb 操作对象1, 操作对象2`

功能：操作对象1 = 操作对象1 - 操作对象2 - CF

```
;计算 003E1000H - 00202000H，结果放在ax，bx中，程序如下：
mov bx, 1000H
mov ax, 003EH
sub bx, 2000H
sbb ax, 0020H
```

## 11.8 cmp指令

cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。

其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。

cmp指令格式：`cmp 操作对象1，操作对象2`

例如：
指令`cmp ax, ax`，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。
指令执行后：zf=1，pf=1，sf=0，cf=0，of=0。

CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。

| cmp ax, bx  | 无符号比较时     |
| ----------- | ---------------- |
| (ax) = (bx) | zf = 1           |
| (ax) ≠ (bx) | zf = 0           |
| (ax) < (bx) | cf = 1           |
| (ax) ≥ (bx) | cf = 0           |
| (ax) > (bx) | cf = 0 且 zf = 0 |
| (ax) ≤ (bx) | cf = 1 且 zf = 1 |

上面的表格可以正推也可以逆推

如果用cmp来进行有符号数比较时
SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。
但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。

```assembly
mov ah, 08AH  ; -Not(8A-1) = -118  即当成有符号数时为-118
mov bh, 070H  ; 有符号数时最高位为0为正数， 70H = 112
cmp ah, bh    ;（ah）-（bh）实际得到的结果是1AH 
		      ; 在逻辑上，运算所应该得到的结果是：（-118）- 112 = -230
		      ; sf记录实际结果的正负，所以sf=0
12345
```

> `cmp ah, bh`
> （1）如果sf=1，而of=0 。 of=0说明没有溢出，逻辑上真正结果的正负=实际结果的正负； sf=1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）<（bh）
>
> （2）如果sf=1，而of=1： of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负； sf=1，实际结果为负。
> 实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。 这样，sf=1，of=1，说明了（ah）>（bh）。
>
> （3）如果sf=0，而of=1。of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；sf=0，实际结果非负。而of=1说明有溢出，则结果非0，所以，实际结果为正。
> 实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，sf=0，of=1，说明了（ah）<（bh）。
> （4）如果sf=0，而of=0
> of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；sf=0，实际结果非负，所以逻辑上真正的结果非负，所以（ah）≥（bh）。

## 11.9 检测比较结果的条件转移指令

可以根据某种条件，决定是否修改IP的指令

jcxz它可以检测cx中的数值，如果（cx）=0，就修改IP，否则什么也不做。

所有条件转移指令的转移位移都是[-128，127]。

**这些条件转移指令通常和cmp配合使用，它们检测标志寄存器的相关标志位，而这些标志位就是被cmp影响的那些，根据检测的结果来决定是否修改IP。**

因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，**所以根据cmp指令的比较结果进行转移的指令也分为两种**：

- 根据**无符号数**的比较结果进行转移的条件转移指令（**它们检测zf、cf的值**）
- 根据**有符号数**的比较结果进行转移的条件转移指令（**它们检测sf、of和zf的值）**。

下面是根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）

| 指令 | 含义         | 检测的相关标志位 |
| ---- | ------------ | ---------------- |
| je   | 等于则转移   | zf = 1           |
| jne  | 不等于则转移 | zf = 0           |
| jb   | 低于则转移   | cf = 1           |
| jnb  | 不低于则转移 | cf = 0           |
| ja   | 高于则转移   | cf = 0 且 zf = 0 |
| jna  | 不高于则转移 | cf = 1 且 zf = 1 |

j：jump，e：equal，b：below，a：above，n：not

这些指令检测的标志位都是cmp指令进行无符号数比较的时候，记录比较结果的标志位。**如果在这些指令前面使用了cmp，实际上就是间接地检测cmp的比较结果**。

比如je指令，虽然它的逻辑含义是“相等则转移”，但它进行的操作是zf=1是则转移。**“相等则转移”这种逻辑含义，是通过和cmp指令配合使用来体现的，因为是cmp指令为“zf=1”赋予了“两数相等”的含义。**

至于究竟在je之前使不使用cmp指令，在于我们的安排。je 检测的是zf位置，不管je前面是什么指令，只要CPU执行je指令时，zf=1，那么就会发生转移。

```assembly
data segment
	db 8,11,8,1,8,5,63,38
data ends
;编程，统计data段中数值为8的字节的个数，用ax保存统计结果。
mov ax, data 
mov ds, ax 
mov bx, 0   ;ds:bx指向第一个字节
mov ax, 0   ;初始化累加器mov cx，8

s:
	cmp byte ptr [bx], 8   ;和8进行比较
	jne next  ;如果不相等转到next，继续循环
	inc ax  ;如果相等就将计数值加1
next:
	inc bx
	loop s ;程序执行后：（ax）=3
```

## 11.10 DF标志和串传送指令

方向标志位。在串处理指令中，控制每次操作后si、di的增减。

- df = 0每次操作后si、di递增；
- df = 1每次操作后si、di递减。

格式：`movsb`
功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减

格式：`movsw`
功能：将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。

格式：`rep movsb`
movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，
功能：rep的作用是根据cx的值，重复执行后面的串传送指令

8086CPU提供下面两条指令对df位进行设置。

- `cld`指令：将标志寄存器的df位置0
- `std`指令：将标志寄存器的df位置1

```assembly
;将data段中的第一个字符串复制到它后面的空间中。
data segment 
	db 'Welcome to masm!'
	db 16 dup (0)
data ends

mov ax, data 
mov ds, ax 
mov si, 0   ;ds:si 指向data:0
mov es, ax 
mov di, 16  ;es:di指向data:0010

mov cx, 16  ;（cx）=16，rep循环16次
cld  ;设置df=0，正向传送
rep movsb
```

## 11.11 pushf和popf

pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中

pushf和popf，为直接访问标志寄存器提供了一种方法。

## 11.12 标志寄存器在Debug中的表示

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210201125148352.png" alt="image-20210201125148352" style="zoom: 50%;" />

# 第12章、内中断

任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。

**中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。**

中断信息可以来自CPU的内部和外部（内中断，外中断）

## 12.1 内中断的产生

内中断：当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部

8086CPU的内中断（下面四种情况将产生中断信息）

- 除法错误，比如，执行div指令产生的除法溢出；
- 单步执行；
- 执行 into指令；
- 执行 int指令。

中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源（中断源）

上述的4种中断源，在8086CPU中的中断类型码如下。

- 除法错误：0
- 单步执行：1
- 执行into指令：4
- 执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码。

## 12.2 **中断处理程序**

用来处理中断信息的程序被称为中断处理程序。

根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的处理程序

## 12.3 中断向量表

中断向量就是中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表

CPU用8位的**中断类型码**通过**中断向量表**找到相应的**中断处理程序**的**入口地址**
![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20190323182525601.png)

## 12.4 中断过程

中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP。**这个工作是由CPU的硬件自动完成的（程序员无法改变这个过程中所要做的工作）。**

下面是8086CPU在收到中断信息后，所引发的中断过程。简要描述如下：

1. 从中断信息中取得中断类型码N；
2. pushf（标志寄存器的值入栈，因为在中断过程中要修改标志寄存器的值，所以将其保存在栈中）
3. TF=0，IF=0 （设置标志寄存器的第8位TF和第9位IF的值为0）
   - TF设置为0的原因：CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。为了避免CPU在执行中断处理程序时发生单步中断，在进入中断处理程序之前将TF设置为0。
   - IF设置为0的原因：当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。为了在进入中断处理程序后，禁止其他的可屏蔽中断，在进入中断处理程序之前将IF设置为0。
4. push CS , push IP（CS、IP的内容入栈）
5. （IP）=（N * 4），（CS）=（N * 4 + 2）

硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。

## 12.5 中断处理程序和iret指令

CPU随时都可能执行中断处理程序，中断处理程序必须一直存储在内存某段空间之中
而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。

中断处理程序的常规编写步骤：

1. 保存用到的寄存器（中断过程中保存的是CS、IP、Flag寄存器，中断过程是由CPU硬件自动完成的。而中断处理程序是程序员编写的，这里保存的寄存器是中断处理程序中可能会用到的程序）
2. 处理中断；
3. 恢复用到的寄存器；
4. 用`iret`指令返回。（恢复中断过程中保存的CS、IP、flag寄存器）

iret 指令描述为：`pop IP` `pop CS` `popf`

iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序

## 12.6 除法错误中断的处理

```assembly
mov ax, 1000h 
mov bh, 1
div bh ;除法溢出错误
```

1、当CPU执行div bh时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，

2、CPU执行0号中断处理程序

3、系统中的0号中断处理程序的功能：显示提示信息“Divide overflow”后，返回到操作系统中。

**编程实验**

编程：编写0号中断处理程序do0，当发生除法溢出时，在屏幕中间显示“overflow！”，返回DOS。

1、0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，可以将中断处理程序do0传送到内存0000:0200处。

2、中断处理程序do0放到`0000:0200`,再将其地址登记在中断向量表对应表项

- 0号表项的地址`0:0`。`0:0`字单元存放偏移地址，`0:2`字单元存放段地址
- 将do0的段地址0存放在`0000:0002`字单元中，将偏移地址200H存放在`0000:0000`字单元

```assembly
assume cs:code

code segment
start:	
		mov ax, cs
		mov ds, ax
		mov si, offset do0		;设置ds:si指向源地址
		mov ax, 0
		mov es, ax
		mov di, 200h			;设置es:di指向目的地址0000:0200
		mov cx, offset do0end - offset do0		;设置cx为传输长度 编译时给出do0部分代码长度
		cld				        ;设置传输方向为正
		rep movsb ;将do0的代码送入0:200处
		
		mov ax, 0               ;设置中断向量表
		mov es, ax
		mov word ptr es:[0*4], 200h
		mov word ptr es:[0*4+2], 0

      	mov ax,4c00h
      	int 21h

;do0程序的主要任务是显示字符串
do0:	jmp short do0 start 
      	db "overflow!"

do0start:
      	mov ax, cs
      	mov ds, ax
      	mov si, 202h			;设置ds:si指向字符串

      	mov ax, 0b800h
      	mov es, ax
		mov di, 12*160+36*2		;设置es:di指向显存空间的中间位置

        mov cx, 9				;设置cx为字符串长度
	s:	mov al, [si]
      	mov es:[di], al
      	inc si
      	add di, 1
		mov al, 02h             ;设置颜色
		mov es:[di], al        
		add di, 1
      	loop s

      	mov ax, 4c00h
      	int 21h
do0end:	nop

code ends
end start
```

## 12.11 单步中断

CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1

Debug是如何利用CPU所提供的单步中断的功能进行调试？如使用t命令查看寄存器状态

**Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令**

在使用t命令执行指令时，**Debug将TF设置为1**，在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。

**在进入中断处理程序之前，设置TF=0**。从而避免CPU在执行中断处理程序的时候发生单步中断

## 12.12 响应单步中断的特殊情况

**在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应**。主要原因是，ss:sp 联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。所以CPU在执行完设置ss的指令后，不响应中断。我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程。

# 第13章、int指令

int指令的格式为：`int n` ，n为中断类型码，它的功能是引发中断过程。

CPU执行int n指令，相当于引发一个n号中断的中断过程

在程序中使用int指令调用任何一个中断的中断处理程序。我们可以将中断处理程序简称为中断例程。

## 13.4 BIOS和DOS所提供的中断例程

在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统）

BIOS中主要包含以下几部分内容

- 硬件系统的检测和初始化程序；
- 外部中断和内部中断的中断例程；
- **用于对硬件设备进行I/O操作的中断例程**；
- 其他和硬件系统相关的中断例程。

**程序员在编程的时候，可以用int 指令直接调用BIOS和DOS系统提供的中断例程，来完成某些工作。**
和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。

## 13.5 **BIOS和DOS中断例程的安装过程**

前面的课程中，我们都是自己编写中断例程，将它们放到安装程序中，然后运行安装程序，将它们安装到指定的内存区中。此后，别的应用程序才可以调用。

BIOS和DOS提供的中断例程是如何安装到内存中的呢？

1、开机后，CPU一加电，初始化（CS）= 0FFFFH，（IP）= 0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。

2、初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。
注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。

3、硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。

4、DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。

## 13.6 BIOS中断例程应用

一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。

BIOS和DOS提供的中断例程，都用 **ah** 来传递内部子程序的编号。

## 13.7 **DOS中断例程应用**

`int 21h`中断例程是DOS提供的中断例程，`4ch`号功能，即程序返回功能

```assembly
mov ah, 4ch ;调用第21h号中断例程的4ch号子程序，功能为程序返回,可以提供返回值作为参数
mov al, 0 ;返回值
int 21h
```

# 第14章、端口

在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。

- 各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；
- 主板上的接口芯片，CPU通过它们对部分外设进行访问；
- 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。

CPU主板上有接口卡的插槽，插槽上有接口卡，接口卡上有接口芯片，接口芯片上有寄存器。

**在这些芯片中，都有一组可以由CPU读写的寄存器**。这些寄存器，它们在物理上可能处于不同的芯片中，
但是它们在以下两点上相同。

- 都和CPU的总线相连，**这种连接是通过它们所在的芯片进行的**；
- CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出**端口读写命令**。

从CPU的角度，**将这些寄存器都当作端口**，对它们进行**统一编址**，从而建立了一个**统一的端口地址空间**。
每一个端口在地址空间中都有一个地址。**在访问端口的时候，CPU通过端口地址来定位端口**。因为端口所在的芯片和CPU通过总线相连，

CPU可以直接读写以下3个地方的数据。

- CPU内部的寄存器；
- 内存单元；
- 端口。

## 14.1 端口的读写

端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为`0-65535`。

端口的读写指令只有两条：`in`和`out`，分别用于从端口读取数据和往端口写入数据。

在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。

CPU执行内存访问指令和端口访问指令的时候，总线上的信息：

- 访问内存：

  ```assembly
  mov ax,ds: [8] 	;假设执行前(ds)=0
  ```

  执行时与总线相关的操作如下所示。
  ①CPU通过**地址线**将地址信息8发出;
  ②CPU 通过**控制线**发出**内存读命令**，选中**存储器芯片**，并通知它，将要从中读取数据;
  ③**存储器**将8号单元中的数据通过**数据线**送入CPU。

- 访问端口：

  ```assembly
  in al, 60h	;从60h号端口读入一一个字节
  ```

  执行时与总线相关的操作如下。
  ①CPU 通过**地址线**将地址信息60h发出;
  ②CPU通过**控制线**发出**端口读命令**，选中**端口所在的芯片**，并通知它，将要从中读取数据;
  ③**端口所在的芯片**将60h端口中的数据通过**数据线**送入CPU。

```assembly
;对0~255以内的端口进行读写时：
in al, 20h  ;从20h端口读入一个字节
out 20h, al  ;往20h端口写入一个字节

;对256~65535的端口进行读写时，端口号放在dx中：
mov dx, 3f8h  ;将端口号3f8h送入dx
in al, dx  ;从3f8h端口读入一个字节
out dx, al ;向3f8h端口写入一个字节
```

## 14.2 CMOS RAM芯片

PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下

- 包含一个实时钟和一个有128个存储单元的RAM存储器
- 该芯片靠电池供电。关机后内部的实时钟正常工作，RAM中的信息不丢失
- 128个字节的RAM中，内部实时钟占用`0~0dh`单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。
- **该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM**
- 70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。
  可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元：
  1. 将2送入端口70h；
  2. 从端口71h读出2号单元的内容。

## 14.3 shl和shr指令

shl和shr是逻辑移位指令

shl是逻辑左移指令，它的功能为：

1. 将一个寄存器或内存单元中的数据向左移位；
2. 将最后移出的一位写入CF中；
3. 最低位用0补充。

shr是逻辑右移指令，它的功能为：

1. 将一个寄存器或内存单元中的数据向右移位；
2. 将最后移出的一位写入CF中；
3. 最高位用0补充。

如果移动位数大于1时，必须将移动位数放在cl中

```assembly
mov al, 01001000b 
shl al, 1 ;将a1中的数据左移一位执行后（al）=10010000b，CF=0。

mov al, 01010001b 
mov cl, 3 ;如果移动位数大于1时，必须将移动位数放在cl中
shl al, c1

mov al, 10000001b 
shr al, 1  ;将al中的数据右移一位执行后（al）=01000000b，CF=1。
```

将X逻辑左移一位，相当于执行X=X*2。
将X逻辑右移一位，相当于执行X=X/2

## 14.4 **CMOS RAM中存储的时间信息**

在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。长度都为1个字节，
存放单元为：

| 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 年   | 月   | 日   |      |      | 时   |      | 分   |      | 秒   |

这些数据以BCD码的方式存放。

一个字节可表示两个BCD码。则CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。

```assembly
;编程，在屏幕中间显示当前的月份。
assume cs:code
code segment 
start:	mov al，8 ;从CMOS RAM的8号单元读出当前月份的BCD码。
		out 70h，al 
		in al, 71h ;从数据端口71h中取得指定单元中的数据：
		
		mov ah, al ;al中为从CMOS RAM的8号单元中读出的数据
		mov cl, 4
		shr ah, cl ;ah中为月份的十位数码值,左移四位空出四位
		and al, 00001111b ;al中为月份的个位数码值
		
		add ah, 30h ;BCD码值+30h=十进制数对应的ASCII
		add al, 30h 
		
		mov bx, 0b800h 
		mov es, bx 
		mov byte ptr es:[160*12+40*2], ah ;显示月份的十位数码
		mov byte ptr es:[160*12+40*2+2], al ;接着显示月份的个位数码
		
		mov ax，4c00h
		int 21h
code ends
end start
```

# 第15章、外中断

CPU在计算机系统中，除了能够执行指令，进行运算以外，**还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出（I/O能力）**

CPU功能：

1. 执行指令，进行运算。
2. 对外部设备进行控制，接收它们的输入，向它们进行输出（I/O能力）

## 15.1 接口芯片和端口

**PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问**

外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；
CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。
CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。

即：**CPU通过端口和外部设备进行联系**

CPU主板上有接口卡的插槽，插槽上有接口卡，接口卡上有接口芯片，接口芯片上有寄存器，这些寄存器被CPU当作端口访问，CPU将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。

**CPU通过控制端口（芯片上的寄存器）来控制芯片，芯片控制外设。**

## 15.2 外中断信息

内中断：当CPU内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU内部。

外中断：当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。

**PC系统中，外中断源有两类**

**1、可屏蔽中断**

可屏蔽中断是CPU可以不响应的外中断。**CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置**。
当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。

可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。

中断过程中将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。
如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。

8086CPU提供的设置IF的指令：`sti`，设置IF=1；`cli`，设置IF=0。

**2、不可屏蔽中断**

不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。

对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。

不可屏蔽中断的中断过程为：

①标志寄存器入栈，IF=0，TF=0；

②CS、IP入栈；

③（IP）=（8），（CS）=（0AH）。（IP=2*4，CS=2 *4+2）

几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。

## 15.3 PC机键盘的处理过程

键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为`60h`。松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入**60h端口**中。

一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。

扫描码长度为一个字节，通码的第7位为0，断码的第7位为1
即：断码 = 通码 + 80h。比如，g键的通码为22h，断码为a2h

键盘的输入到达60h端口时，**相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息**。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。

![在这里插入图片描述](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/2019032416380958.png)

**BIOS提供了int 9中断例程**，用来进行基本的键盘输入处理，主要的工作如下：
（1）读出60h端口中的扫描码；
（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入**内存中的BIOS键盘缓冲区**； 如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，**则将其转变为状态字节写入内存中存储状态字节的单元**；
（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。

**BIOS键盘缓冲区**是系统启动后，BIOS用于存放int 9中断例程所接收键盘输入的内存区。该内存区的可以存储15个键盘输入，一个键盘输入用一个字单元存放，**高位字节存放扫描码，低位字节存放字符码。**

**`0040:17`单元存储键盘状态字节**，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。

| 0    | 右shift状态    | 置1表示按下右shift键      |
| ---- | -------------- | ------------------------- |
| 1    | 左shift状态    | 置1表示按下左shift键      |
| 2    | Ctrl状态       | 置1表示按下Ctrl键         |
| 3    | Alt状态        | 置1表示按下Alt键          |
| 4    | ScrollLock状态 | 置1表示Scroll指示灯亮     |
| 5    | NumLock状态    | 置1表示小键盘输入的是数字 |
| 6    | CapsLock状态   | 置1表示输入大写字母       |
| 7    | Insert状态     | 置1表示处于删除态         |

按下键盘上的某一个键，产生一个扫描码，扫描码被送入接口芯片的寄存器中（端口地址为60h），芯片向CPU发送9号中断信息，CPU在中断向量表中查询到9号中断例程的地址，执行存放在BIOS中的9号中断例程，9号中断例程读取存放在60h中的扫描码，将扫描码和对应的信息送入内存单元，对外设输入进行处理。

# 指令系统总结

我们对8086CPU的指令系统进行一下总结。读者若要详细了解8086指令系统中的各个指令的用，可以查看有关的指令手册。

8086CPU提供以下几大类指令。

1. 数据传送指令
   `mov、push、pop、pushf、popf、xchg` 等都是数据传送指令，这些指令实现寄存器和内存、寄器和寄存器之间的单个数据传送。
2. 算术运算指令
   `add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa`等都是算术运算指令，这些指令实现存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的`sf、zf、of、cf、pf、af`位。
3. 逻辑指令
   `and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr`等都是逻辑指令。除了not指外，它们的执行结果都影响标志寄存器的相关标志位。
4. 转移指令
   可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令分为以下几类。
   （1）无条件转移指令，比如，`jmp`；
   （2）条件转移指令，比如，`jcxz、je、jb、ja、jnb、jna`等；
   （3）循环指令，比如，`loop`；
   （4）过程，比如，`call、ret、retf`；
   （5）中断，比如，`int、iret`。
5. 处理机控制指令
   对标志寄存器或其他处理机状态进行设置，`cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock`等都是处理机控制指令。
6. 串处理指令
   对内存中的批量数据进行处理，`movsb、movsw、cmps、scas、lods、stos`等。若要使用这些指令方便地进行批量数据的处理，则需要和`rep、repe、repne` 等前缀指令配合使用。

# 第16章、直接定址表

## 16.1 描述了单位长度的标号

普通的地址标号：

```assembly
assume cs:code
code segment
         a : db 1,2,3,4,5,6,7,8  ;在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。
         b : dw 0
start :mov si,offset a
         mov bx,offset b
         mov cx,8
    s : mov al,cs:[si]
         mov ah,0
         add cs:[bx],ax
         inc si
         loop s
         mov ax,4c00h
         int 21h
code ends
end start
```

描述了单位长度的标号

```assembly
assume cs:code
code segment
          a db 1,2,3,4,5,6,7,8 ;标号a、b后面没有":"，因此它们是可以同时描述内存地址和单元长度的标号。
                               ;标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元
          b dw 0               ;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。
start :  mov si,0
          mov cx,8
    s :   mov al,a[si]
          mov ah,0
          add b,ax
          inc si
          loop s
          mov ax,4c00h
          int 21h
code ends
end start
```

code、start、s都是标号。这些标号仅仅表示了内存单元的地址。

a、b这种标号不但表示了内存单元的地址，还表示了内存单元的长度，**可以代表一个段中的内存单元**。

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210202230829387.png" alt="image-20210202230829387" style="zoom:50%;" />![image-20210202231031359](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210202231031359.png)

<img src="%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210202230829387.png" alt="image-20210202230829387" style="zoom:50%;" />![image-20210202231031359](%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20210202231031359.png)

我们称这种标号为**数据标号**，它用来描述存储数据的单元的地址和长度，可以使我们以简洁的形式访问内存中的数据。

## 16.2 在其他段中使用数据标号

```assembly

assume cs:code,ds:data ;用伪指令assume将标号所在的段和一个段寄存器联系起来(编译器需要)
data segment          
          a db 1,2,3,4,5,6,7,8
          b dw 0
data ends
code segment
start:  mov ax,data
          mov ds,ax ;真正确定ds寄存器
          mov si,0
          mov cx,8
s:       mov al,a[si] ;编译为：mov al,[si+0] 默认所访问单元的段地址在ds
          mov ah,0
          add b,ax ;编译为：add [8],ax
          inc si
          loop s
          mov ax,4c00h
          int 21h
code ends
end start
```

注意，**如果想在代码段中直接用数据标号访问数据**，则需要用伪指令aassum;将标号所在的段和一个段寄存器联系起来。否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。当然，这种联系是编译器需要的，但绝对不是说，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。**我们在程序中还要使用指令对段寄存器进行设置**。

经过assume ds:data后，编译器就默认data段的段地址在ds中，数据标号a就相当于ds:[0]，b相当于ds:[8],但是这只是编译器认为的，实际上data段的段地址并不存在ds中。所以我们还需要在程序中，将data的值写入ds中。这个时候才能使用数据标号直接访问数据。

但是对于只有一个段的程序来说（如16.1的程序），assume cs:code后，就不需要将code的值写入cs。因为只有一个段，程序被写入内存时，CS：IP就被设置为指向段的最开始的位置，所以CS中已经存在了code的段地址，我们可以直接使用数据标号。

对于多个段的程序，为了让CPU知道从什么地方开始执行程序，设置了start标号和end start伪指令，CS指向设置了start标号的段的段地址，IP指向start标记的程序。此时，其他的段必须在程序中对段寄存器进行设置，但是start段不需要。

在程序中，我们用ds寄存器和data段相联，则编译器对相关指令的编译如下。
指令:	`mov al,a[si]`
编译为:`mov al,[si+0]`
指令:	`add b,ax`
编译为: `add [8],ax`



可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。

```assembly
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dw a, b ;等价于c dw offset a, offset b
	;数据标号c处存储的两个字型数据为标号a、b 的偏移地址
data ends

data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dd a,b ;等价于c dw offset a, seg a, offset b, seg b
	;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址
data ends
```

seg操作符，功能为取得某一标号的段地址



# 后记

我在学习CSAPP的过程中遇到了汇编语言方面的内容，就找来了这本王爽的《汇编语言》看看。结果发现这本书并不只是汇编语言方面的内容，还涉及到了很多计算机组成原理方面的知识。以前很多困惑我的知识、概念，在这本书中都迎刃而解。

在阅读这本书的过程中，最让我感动和敬佩的就是前言中的这几段话：

> 一门课程是由相互关联的知识构成的，这些知识在一本书中如何组织则是一种信息组织和加工的艺术。学习是一个循序渐进的过程，但并不是所有的教学都是以这种方式完成的，这并不是我们所希望看到的事情，因为任何不以循序渐进的方式进行的学习，都将出现盲目探索和不成系统的情况，最终学习到的也大都是相对零散的知识，并不能建立起一个系统的知识结构。非循序渐进的学习，也达不到循序渐进学习所能达到的深度，因为后者是步步深入的，每一步都以前一步为基础。

> 为学习者构造合理的学习线索，这个学习线索应真正地遵循循序渐进的原则。我们需要打破传统的章节划分，以一种新的艺术来对课程的内容进行补充、分割、重组，使其成为一个个串联在学习线索上的完成特定教学功能的教学节点。本书以此作为创作的核心理念，打破了传统的章节划分，构造了合理的学习线索，将课程的内容拆解到学习线索中的各个教学节点中去。

> 为了按循序渐进的原则构造学习线索，本书采用了一种全新的信息组织和加工艺术，我们称其为知识屏蔽。有的教材只注重知识的授予，并不注重知识的屏蔽。在教学中知识的屏蔽十分重要，这是一个重点突出的问题。计算机是一门交叉学科，一部分知识往往还连带着其他的相关内容，这些连带的相关内容如果处理不好，将影响学习者对目前要掌握的知识的理解。本书采用了知识屏蔽的方法，对教学内容进行了最小化分割，力求使我们在学习过程中所接触到的每一个知识点都是当前唯一要去理解的东西。我们在看到这个知识点之前，已理解了以前所有的内容;在学习这个知识点的过程中，以后的知识也不会对我们造成干扰。我们在整个学习过程中，每一步都走得清楚而扎实，不知不觉中，由当初的一个简单的问题开始，在经历了一个每一步都相对简单的过程之后，被带入了一个深的层次。这同沿着楼梯上高楼一样， 迈出的每一步 都不高，结果却上了楼顶。

这些话说明作者真的把读者放到了一个完完全全的初学者的地位，真的做到了站在读者的角度去思考问题。我从中感受到了作者对读者的尊重。当我读完这本书后，发现真的就如作者所说的一样，如同沿着楼梯上高楼， 迈出的每一步都不高，结果却上了楼顶。

如今很多名为“深入浅出xxxx”的技术书籍，不仅做不到深入，也做不到浅出，以其昏昏，使人昭昭。完全是借着出书捞钱和出名，随便糊弄了事。我希望所有的技术书籍的作者都应该有这样的精神，应该力求达到这本《汇编语言》的境界，真正做到“深入浅出”，让读者不知不觉就走上楼顶。

此书绝对是国内计算机书籍中不可多得的好书，我认为所有学习组成原理和操作系统的同学都应该看看这本书，很多地方比CSAPP讲的还要清楚明白。

由于本人并不准备深入学习汇编语言，所以本书部分关于汇编语言编程的地方我只是匆匆扫过，没有记录在此。



​																																





